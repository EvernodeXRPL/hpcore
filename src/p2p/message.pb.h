// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace p2p {
class HistoryRequest;
class HistoryRequestDefaultTypeInternal;
extern HistoryRequestDefaultTypeInternal _HistoryRequest_default_instance_;
class HistoryResponse;
class HistoryResponseDefaultTypeInternal;
extern HistoryResponseDefaultTypeInternal _HistoryResponse_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class NPL;
class NPLDefaultTypeInternal;
extern NPLDefaultTypeInternal _NPL_default_instance_;
class Proposal;
class ProposalDefaultTypeInternal;
extern ProposalDefaultTypeInternal _Proposal_default_instance_;
class State;
class StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class StateDifference;
class StateDifferenceDefaultTypeInternal;
extern StateDifferenceDefaultTypeInternal _StateDifference_default_instance_;
class StateDifference_CreatedEntry_DoNotUse;
class StateDifference_CreatedEntry_DoNotUseDefaultTypeInternal;
extern StateDifference_CreatedEntry_DoNotUseDefaultTypeInternal _StateDifference_CreatedEntry_DoNotUse_default_instance_;
class StateDifference_DeletedEntry_DoNotUse;
class StateDifference_DeletedEntry_DoNotUseDefaultTypeInternal;
extern StateDifference_DeletedEntry_DoNotUseDefaultTypeInternal _StateDifference_DeletedEntry_DoNotUse_default_instance_;
class StateDifference_UpdatedEntry_DoNotUse;
class StateDifference_UpdatedEntry_DoNotUseDefaultTypeInternal;
extern StateDifference_UpdatedEntry_DoNotUseDefaultTypeInternal _StateDifference_UpdatedEntry_DoNotUse_default_instance_;
class StateRequest;
class StateRequestDefaultTypeInternal;
extern StateRequestDefaultTypeInternal _StateRequest_default_instance_;
class StateResponse;
class StateResponseDefaultTypeInternal;
extern StateResponseDefaultTypeInternal _StateResponse_default_instance_;
class State_PatchEntry_DoNotUse;
class State_PatchEntry_DoNotUseDefaultTypeInternal;
extern State_PatchEntry_DoNotUseDefaultTypeInternal _State_PatchEntry_DoNotUse_default_instance_;
}  // namespace p2p
PROTOBUF_NAMESPACE_OPEN
template<> ::p2p::HistoryRequest* Arena::CreateMaybeMessage<::p2p::HistoryRequest>(Arena*);
template<> ::p2p::HistoryResponse* Arena::CreateMaybeMessage<::p2p::HistoryResponse>(Arena*);
template<> ::p2p::Message* Arena::CreateMaybeMessage<::p2p::Message>(Arena*);
template<> ::p2p::NPL* Arena::CreateMaybeMessage<::p2p::NPL>(Arena*);
template<> ::p2p::Proposal* Arena::CreateMaybeMessage<::p2p::Proposal>(Arena*);
template<> ::p2p::State* Arena::CreateMaybeMessage<::p2p::State>(Arena*);
template<> ::p2p::StateDifference* Arena::CreateMaybeMessage<::p2p::StateDifference>(Arena*);
template<> ::p2p::StateDifference_CreatedEntry_DoNotUse* Arena::CreateMaybeMessage<::p2p::StateDifference_CreatedEntry_DoNotUse>(Arena*);
template<> ::p2p::StateDifference_DeletedEntry_DoNotUse* Arena::CreateMaybeMessage<::p2p::StateDifference_DeletedEntry_DoNotUse>(Arena*);
template<> ::p2p::StateDifference_UpdatedEntry_DoNotUse* Arena::CreateMaybeMessage<::p2p::StateDifference_UpdatedEntry_DoNotUse>(Arena*);
template<> ::p2p::StateRequest* Arena::CreateMaybeMessage<::p2p::StateRequest>(Arena*);
template<> ::p2p::StateResponse* Arena::CreateMaybeMessage<::p2p::StateResponse>(Arena*);
template<> ::p2p::State_PatchEntry_DoNotUse* Arena::CreateMaybeMessage<::p2p::State_PatchEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace p2p {

enum Message_Messagetype : int {
  Message_Messagetype_PROPOSAL = 0,
  Message_Messagetype_NPL = 1,
  Message_Messagetype_STATE_REQUEST = 2,
  Message_Messagetype_STATE_RESPONSE = 3,
  Message_Messagetype_HISTORY_REQUEST = 4,
  Message_Messagetype_HISTORY_RESPONSE = 5
};
bool Message_Messagetype_IsValid(int value);
constexpr Message_Messagetype Message_Messagetype_Messagetype_MIN = Message_Messagetype_PROPOSAL;
constexpr Message_Messagetype Message_Messagetype_Messagetype_MAX = Message_Messagetype_HISTORY_RESPONSE;
constexpr int Message_Messagetype_Messagetype_ARRAYSIZE = Message_Messagetype_Messagetype_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Message_Messagetype_descriptor();
template<typename T>
inline const std::string& Message_Messagetype_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Message_Messagetype>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Message_Messagetype_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Message_Messagetype_descriptor(), enum_t_value);
}
inline bool Message_Messagetype_Parse(
    const std::string& name, Message_Messagetype* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Message_Messagetype>(
    Message_Messagetype_descriptor(), name, value);
}
// ===================================================================

class Message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2p.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return CreateMaybeMessage<Message>(nullptr);
  }

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2p.Message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Message_Messagetype Messagetype;
  static constexpr Messagetype PROPOSAL =
    Message_Messagetype_PROPOSAL;
  static constexpr Messagetype NPL =
    Message_Messagetype_NPL;
  static constexpr Messagetype STATE_REQUEST =
    Message_Messagetype_STATE_REQUEST;
  static constexpr Messagetype STATE_RESPONSE =
    Message_Messagetype_STATE_RESPONSE;
  static constexpr Messagetype HISTORY_REQUEST =
    Message_Messagetype_HISTORY_REQUEST;
  static constexpr Messagetype HISTORY_RESPONSE =
    Message_Messagetype_HISTORY_RESPONSE;
  static inline bool Messagetype_IsValid(int value) {
    return Message_Messagetype_IsValid(value);
  }
  static constexpr Messagetype Messagetype_MIN =
    Message_Messagetype_Messagetype_MIN;
  static constexpr Messagetype Messagetype_MAX =
    Message_Messagetype_Messagetype_MAX;
  static constexpr int Messagetype_ARRAYSIZE =
    Message_Messagetype_Messagetype_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Messagetype_descriptor() {
    return Message_Messagetype_descriptor();
  }
  template<typename T>
  static inline const std::string& Messagetype_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Messagetype>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Messagetype_Name.");
    return Message_Messagetype_Name(enum_t_value);
  }
  static inline bool Messagetype_Parse(const std::string& name,
      Messagetype* value) {
    return Message_Messagetype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kPublicKeyFieldNumber = 2,
    kSignatureFieldNumber = 4,
    kContentFieldNumber = 6,
    kTimestampFieldNumber = 3,
    kTypeFieldNumber = 5,
  };
  // optional string version = 1;
  bool has_version() const;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);

  // optional bytes publicKey = 2;
  bool has_publickey() const;
  void clear_publickey();
  const std::string& publickey() const;
  void set_publickey(const std::string& value);
  void set_publickey(std::string&& value);
  void set_publickey(const char* value);
  void set_publickey(const void* value, size_t size);
  std::string* mutable_publickey();
  std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);

  // optional bytes signature = 4;
  bool has_signature() const;
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);

  // optional bytes content = 6;
  bool has_content() const;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);

  // optional int32 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .p2p.Message.Messagetype type = 5;
  bool has_type() const;
  void clear_type();
  ::p2p::Message_Messagetype type() const;
  void set_type(::p2p::Message_Messagetype value);

  // @@protoc_insertion_point(class_scope:p2p.Message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::int32 timestamp_;
  int type_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class StateDifference_CreatedEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StateDifference_CreatedEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StateDifference_CreatedEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  StateDifference_CreatedEntry_DoNotUse();
  StateDifference_CreatedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StateDifference_CreatedEntry_DoNotUse& other);
  static const StateDifference_CreatedEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StateDifference_CreatedEntry_DoNotUse*>(&_StateDifference_CreatedEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "p2p.StateDifference.CreatedEntry.key");
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "p2p.StateDifference.CreatedEntry.value");
#endif
    return true;
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[1];
  }

  public:
};

// -------------------------------------------------------------------

class StateDifference_UpdatedEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StateDifference_UpdatedEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StateDifference_UpdatedEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  StateDifference_UpdatedEntry_DoNotUse();
  StateDifference_UpdatedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StateDifference_UpdatedEntry_DoNotUse& other);
  static const StateDifference_UpdatedEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StateDifference_UpdatedEntry_DoNotUse*>(&_StateDifference_UpdatedEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "p2p.StateDifference.UpdatedEntry.key");
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "p2p.StateDifference.UpdatedEntry.value");
#endif
    return true;
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[2];
  }

  public:
};

// -------------------------------------------------------------------

class StateDifference_DeletedEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StateDifference_DeletedEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StateDifference_DeletedEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  StateDifference_DeletedEntry_DoNotUse();
  StateDifference_DeletedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StateDifference_DeletedEntry_DoNotUse& other);
  static const StateDifference_DeletedEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StateDifference_DeletedEntry_DoNotUse*>(&_StateDifference_DeletedEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "p2p.StateDifference.DeletedEntry.key");
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "p2p.StateDifference.DeletedEntry.value");
#endif
    return true;
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[3];
  }

  public:
};

// -------------------------------------------------------------------

class StateDifference :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2p.StateDifference) */ {
 public:
  StateDifference();
  virtual ~StateDifference();

  StateDifference(const StateDifference& from);
  StateDifference(StateDifference&& from) noexcept
    : StateDifference() {
    *this = ::std::move(from);
  }

  inline StateDifference& operator=(const StateDifference& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateDifference& operator=(StateDifference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StateDifference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StateDifference* internal_default_instance() {
    return reinterpret_cast<const StateDifference*>(
               &_StateDifference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StateDifference& a, StateDifference& b) {
    a.Swap(&b);
  }
  inline void Swap(StateDifference* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StateDifference* New() const final {
    return CreateMaybeMessage<StateDifference>(nullptr);
  }

  StateDifference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StateDifference>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StateDifference& from);
  void MergeFrom(const StateDifference& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateDifference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2p.StateDifference";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kCreatedFieldNumber = 1,
    kUpdatedFieldNumber = 2,
    kDeletedFieldNumber = 3,
  };
  // map<string, string> created = 1;
  int created_size() const;
  void clear_created();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      created() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_created();

  // map<string, string> updated = 2;
  int updated_size() const;
  void clear_updated();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      updated() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_updated();

  // map<string, string> deleted = 3;
  int deleted_size() const;
  void clear_deleted();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      deleted() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_deleted();

  // @@protoc_insertion_point(class_scope:p2p.StateDifference)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      StateDifference_CreatedEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > created_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      StateDifference_UpdatedEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > updated_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      StateDifference_DeletedEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > deleted_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class State_PatchEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<State_PatchEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<State_PatchEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  State_PatchEntry_DoNotUse();
  State_PatchEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const State_PatchEntry_DoNotUse& other);
  static const State_PatchEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const State_PatchEntry_DoNotUse*>(&_State_PatchEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "p2p.State.PatchEntry.key");
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "p2p.State.PatchEntry.value");
#endif
    return true;
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[5];
  }

  public:
};

// -------------------------------------------------------------------

class State :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2p.State) */ {
 public:
  State();
  virtual ~State();

  State(const State& from);
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  inline State& operator=(State&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const State& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }
  inline void Swap(State* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline State* New() const final {
    return CreateMaybeMessage<State>(nullptr);
  }

  State* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<State>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2p.State";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPatchFieldNumber = 4,
    kPreviousFieldNumber = 1,
    kCurrentFieldNumber = 2,
    kDifferenceFieldNumber = 3,
  };
  // map<string, string> patch = 4;
  int patch_size() const;
  void clear_patch();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      patch() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_patch();

  // optional bytes previous = 1;
  bool has_previous() const;
  void clear_previous();
  const std::string& previous() const;
  void set_previous(const std::string& value);
  void set_previous(std::string&& value);
  void set_previous(const char* value);
  void set_previous(const void* value, size_t size);
  std::string* mutable_previous();
  std::string* release_previous();
  void set_allocated_previous(std::string* previous);

  // optional bytes current = 2;
  bool has_current() const;
  void clear_current();
  const std::string& current() const;
  void set_current(const std::string& value);
  void set_current(std::string&& value);
  void set_current(const char* value);
  void set_current(const void* value, size_t size);
  std::string* mutable_current();
  std::string* release_current();
  void set_allocated_current(std::string* current);

  // optional .p2p.StateDifference difference = 3;
  bool has_difference() const;
  void clear_difference();
  const ::p2p::StateDifference& difference() const;
  ::p2p::StateDifference* release_difference();
  ::p2p::StateDifference* mutable_difference();
  void set_allocated_difference(::p2p::StateDifference* difference);

  // @@protoc_insertion_point(class_scope:p2p.State)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      State_PatchEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > patch_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previous_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_;
  ::p2p::StateDifference* difference_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class Proposal :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2p.Proposal) */ {
 public:
  Proposal();
  virtual ~Proposal();

  Proposal(const Proposal& from);
  Proposal(Proposal&& from) noexcept
    : Proposal() {
    *this = ::std::move(from);
  }

  inline Proposal& operator=(const Proposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proposal& operator=(Proposal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Proposal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Proposal* internal_default_instance() {
    return reinterpret_cast<const Proposal*>(
               &_Proposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Proposal& a, Proposal& b) {
    a.Swap(&b);
  }
  inline void Swap(Proposal* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Proposal* New() const final {
    return CreateMaybeMessage<Proposal>(nullptr);
  }

  Proposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Proposal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Proposal& from);
  void MergeFrom(const Proposal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proposal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2p.Proposal";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionsFieldNumber = 1,
    kInputsFieldNumber = 2,
    kOutputsFieldNumber = 3,
    kLclFieldNumber = 7,
    kStateFieldNumber = 6,
    kStageFieldNumber = 4,
    kTimeFieldNumber = 5,
  };
  // repeated string connections = 1;
  int connections_size() const;
  void clear_connections();
  const std::string& connections(int index) const;
  std::string* mutable_connections(int index);
  void set_connections(int index, const std::string& value);
  void set_connections(int index, std::string&& value);
  void set_connections(int index, const char* value);
  void set_connections(int index, const char* value, size_t size);
  std::string* add_connections();
  void add_connections(const std::string& value);
  void add_connections(std::string&& value);
  void add_connections(const char* value);
  void add_connections(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& connections() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_connections();

  // repeated string inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  const std::string& inputs(int index) const;
  std::string* mutable_inputs(int index);
  void set_inputs(int index, const std::string& value);
  void set_inputs(int index, std::string&& value);
  void set_inputs(int index, const char* value);
  void set_inputs(int index, const char* value, size_t size);
  std::string* add_inputs();
  void add_inputs(const std::string& value);
  void add_inputs(std::string&& value);
  void add_inputs(const char* value);
  void add_inputs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& inputs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_inputs();

  // repeated string outputs = 3;
  int outputs_size() const;
  void clear_outputs();
  const std::string& outputs(int index) const;
  std::string* mutable_outputs(int index);
  void set_outputs(int index, const std::string& value);
  void set_outputs(int index, std::string&& value);
  void set_outputs(int index, const char* value);
  void set_outputs(int index, const char* value, size_t size);
  std::string* add_outputs();
  void add_outputs(const std::string& value);
  void add_outputs(std::string&& value);
  void add_outputs(const char* value);
  void add_outputs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& outputs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_outputs();

  // optional bytes lcl = 7;
  bool has_lcl() const;
  void clear_lcl();
  const std::string& lcl() const;
  void set_lcl(const std::string& value);
  void set_lcl(std::string&& value);
  void set_lcl(const char* value);
  void set_lcl(const void* value, size_t size);
  std::string* mutable_lcl();
  std::string* release_lcl();
  void set_allocated_lcl(std::string* lcl);

  // optional .p2p.State state = 6;
  bool has_state() const;
  void clear_state();
  const ::p2p::State& state() const;
  ::p2p::State* release_state();
  ::p2p::State* mutable_state();
  void set_allocated_state(::p2p::State* state);

  // optional int32 stage = 4;
  bool has_stage() const;
  void clear_stage();
  ::PROTOBUF_NAMESPACE_ID::int32 stage() const;
  void set_stage(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 time = 5;
  bool has_time() const;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int32 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:p2p.Proposal)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> connections_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> inputs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> outputs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lcl_;
  ::p2p::State* state_;
  ::PROTOBUF_NAMESPACE_ID::int32 stage_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class NPL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2p.NPL) */ {
 public:
  NPL();
  virtual ~NPL();

  NPL(const NPL& from);
  NPL(NPL&& from) noexcept
    : NPL() {
    *this = ::std::move(from);
  }

  inline NPL& operator=(const NPL& from) {
    CopyFrom(from);
    return *this;
  }
  inline NPL& operator=(NPL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NPL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NPL* internal_default_instance() {
    return reinterpret_cast<const NPL*>(
               &_NPL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NPL& a, NPL& b) {
    a.Swap(&b);
  }
  inline void Swap(NPL* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NPL* New() const final {
    return CreateMaybeMessage<NPL>(nullptr);
  }

  NPL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NPL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NPL& from);
  void MergeFrom(const NPL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NPL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2p.NPL";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kLclFieldNumber = 2,
  };
  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);

  // optional bytes lcl = 2;
  bool has_lcl() const;
  void clear_lcl();
  const std::string& lcl() const;
  void set_lcl(const std::string& value);
  void set_lcl(std::string&& value);
  void set_lcl(const char* value);
  void set_lcl(const void* value, size_t size);
  std::string* mutable_lcl();
  std::string* release_lcl();
  void set_allocated_lcl(std::string* lcl);

  // @@protoc_insertion_point(class_scope:p2p.NPL)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lcl_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class StateRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2p.StateRequest) */ {
 public:
  StateRequest();
  virtual ~StateRequest();

  StateRequest(const StateRequest& from);
  StateRequest(StateRequest&& from) noexcept
    : StateRequest() {
    *this = ::std::move(from);
  }

  inline StateRequest& operator=(const StateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateRequest& operator=(StateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StateRequest* internal_default_instance() {
    return reinterpret_cast<const StateRequest*>(
               &_StateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StateRequest& a, StateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StateRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StateRequest* New() const final {
    return CreateMaybeMessage<StateRequest>(nullptr);
  }

  StateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StateRequest& from);
  void MergeFrom(const StateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2p.StateRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:p2p.StateRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class StateResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2p.StateResponse) */ {
 public:
  StateResponse();
  virtual ~StateResponse();

  StateResponse(const StateResponse& from);
  StateResponse(StateResponse&& from) noexcept
    : StateResponse() {
    *this = ::std::move(from);
  }

  inline StateResponse& operator=(const StateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateResponse& operator=(StateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StateResponse* internal_default_instance() {
    return reinterpret_cast<const StateResponse*>(
               &_StateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StateResponse& a, StateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StateResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StateResponse* New() const final {
    return CreateMaybeMessage<StateResponse>(nullptr);
  }

  StateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StateResponse& from);
  void MergeFrom(const StateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2p.StateResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:p2p.StateResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class HistoryRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2p.HistoryRequest) */ {
 public:
  HistoryRequest();
  virtual ~HistoryRequest();

  HistoryRequest(const HistoryRequest& from);
  HistoryRequest(HistoryRequest&& from) noexcept
    : HistoryRequest() {
    *this = ::std::move(from);
  }

  inline HistoryRequest& operator=(const HistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoryRequest& operator=(HistoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HistoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoryRequest* internal_default_instance() {
    return reinterpret_cast<const HistoryRequest*>(
               &_HistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(HistoryRequest& a, HistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HistoryRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HistoryRequest* New() const final {
    return CreateMaybeMessage<HistoryRequest>(nullptr);
  }

  HistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HistoryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HistoryRequest& from);
  void MergeFrom(const HistoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2p.HistoryRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:p2p.HistoryRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class HistoryResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2p.HistoryResponse) */ {
 public:
  HistoryResponse();
  virtual ~HistoryResponse();

  HistoryResponse(const HistoryResponse& from);
  HistoryResponse(HistoryResponse&& from) noexcept
    : HistoryResponse() {
    *this = ::std::move(from);
  }

  inline HistoryResponse& operator=(const HistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoryResponse& operator=(HistoryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HistoryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoryResponse* internal_default_instance() {
    return reinterpret_cast<const HistoryResponse*>(
               &_HistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(HistoryResponse& a, HistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HistoryResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HistoryResponse* New() const final {
    return CreateMaybeMessage<HistoryResponse>(nullptr);
  }

  HistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HistoryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HistoryResponse& from);
  void MergeFrom(const HistoryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2p.HistoryResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:p2p.HistoryResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Message

// optional string version = 1;
inline bool Message::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Message::version() const {
  // @@protoc_insertion_point(field_get:p2p.Message.version)
  return version_.GetNoArena();
}
inline void Message::set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Message.version)
}
inline void Message::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Message.version)
}
inline void Message::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Message.version)
}
inline void Message::set_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Message.version)
}
inline std::string* Message::mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:p2p.Message.version)
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Message::release_version() {
  // @@protoc_insertion_point(field_release:p2p.Message.version)
  if (!has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:p2p.Message.version)
}

// optional bytes publicKey = 2;
inline bool Message::has_publickey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Message::publickey() const {
  // @@protoc_insertion_point(field_get:p2p.Message.publicKey)
  return publickey_.GetNoArena();
}
inline void Message::set_publickey(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  publickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Message.publicKey)
}
inline void Message::set_publickey(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  publickey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Message.publicKey)
}
inline void Message::set_publickey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  publickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Message.publicKey)
}
inline void Message::set_publickey(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  publickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Message.publicKey)
}
inline std::string* Message::mutable_publickey() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:p2p.Message.publicKey)
  return publickey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Message::release_publickey() {
  // @@protoc_insertion_point(field_release:p2p.Message.publicKey)
  if (!has_publickey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return publickey_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  publickey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:p2p.Message.publicKey)
}

// optional int32 timestamp = 3;
inline bool Message::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::clear_timestamp() {
  timestamp_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Message::timestamp() const {
  // @@protoc_insertion_point(field_get:p2p.Message.timestamp)
  return timestamp_;
}
inline void Message::set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:p2p.Message.timestamp)
}

// optional bytes signature = 4;
inline bool Message::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::clear_signature() {
  signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Message::signature() const {
  // @@protoc_insertion_point(field_get:p2p.Message.signature)
  return signature_.GetNoArena();
}
inline void Message::set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Message.signature)
}
inline void Message::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Message.signature)
}
inline void Message::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Message.signature)
}
inline void Message::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Message.signature)
}
inline std::string* Message::mutable_signature() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:p2p.Message.signature)
  return signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Message::release_signature() {
  // @@protoc_insertion_point(field_release:p2p.Message.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:p2p.Message.signature)
}

// optional .p2p.Message.Messagetype type = 5;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::p2p::Message_Messagetype Message::type() const {
  // @@protoc_insertion_point(field_get:p2p.Message.type)
  return static_cast< ::p2p::Message_Messagetype >(type_);
}
inline void Message::set_type(::p2p::Message_Messagetype value) {
  assert(::p2p::Message_Messagetype_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
  // @@protoc_insertion_point(field_set:p2p.Message.type)
}

// optional bytes content = 6;
inline bool Message::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::clear_content() {
  content_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Message::content() const {
  // @@protoc_insertion_point(field_get:p2p.Message.content)
  return content_.GetNoArena();
}
inline void Message::set_content(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Message.content)
}
inline void Message::set_content(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  content_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Message.content)
}
inline void Message::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Message.content)
}
inline void Message::set_content(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Message.content)
}
inline std::string* Message::mutable_content() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:p2p.Message.content)
  return content_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Message::release_content() {
  // @@protoc_insertion_point(field_release:p2p.Message.content)
  if (!has_content()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return content_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  content_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:p2p.Message.content)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StateDifference

// map<string, string> created = 1;
inline int StateDifference::created_size() const {
  return created_.size();
}
inline void StateDifference::clear_created() {
  created_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StateDifference::created() const {
  // @@protoc_insertion_point(field_map:p2p.StateDifference.created)
  return created_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StateDifference::mutable_created() {
  // @@protoc_insertion_point(field_mutable_map:p2p.StateDifference.created)
  return created_.MutableMap();
}

// map<string, string> updated = 2;
inline int StateDifference::updated_size() const {
  return updated_.size();
}
inline void StateDifference::clear_updated() {
  updated_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StateDifference::updated() const {
  // @@protoc_insertion_point(field_map:p2p.StateDifference.updated)
  return updated_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StateDifference::mutable_updated() {
  // @@protoc_insertion_point(field_mutable_map:p2p.StateDifference.updated)
  return updated_.MutableMap();
}

// map<string, string> deleted = 3;
inline int StateDifference::deleted_size() const {
  return deleted_.size();
}
inline void StateDifference::clear_deleted() {
  deleted_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StateDifference::deleted() const {
  // @@protoc_insertion_point(field_map:p2p.StateDifference.deleted)
  return deleted_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StateDifference::mutable_deleted() {
  // @@protoc_insertion_point(field_mutable_map:p2p.StateDifference.deleted)
  return deleted_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// State

// optional bytes previous = 1;
inline bool State::has_previous() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::clear_previous() {
  previous_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& State::previous() const {
  // @@protoc_insertion_point(field_get:p2p.State.previous)
  return previous_.GetNoArena();
}
inline void State::set_previous(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  previous_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.State.previous)
}
inline void State::set_previous(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  previous_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.State.previous)
}
inline void State::set_previous(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  previous_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.State.previous)
}
inline void State::set_previous(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  previous_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.State.previous)
}
inline std::string* State::mutable_previous() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:p2p.State.previous)
  return previous_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* State::release_previous() {
  // @@protoc_insertion_point(field_release:p2p.State.previous)
  if (!has_previous()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return previous_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void State::set_allocated_previous(std::string* previous) {
  if (previous != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  previous_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previous);
  // @@protoc_insertion_point(field_set_allocated:p2p.State.previous)
}

// optional bytes current = 2;
inline bool State::has_current() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::clear_current() {
  current_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& State::current() const {
  // @@protoc_insertion_point(field_get:p2p.State.current)
  return current_.GetNoArena();
}
inline void State::set_current(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  current_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.State.current)
}
inline void State::set_current(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  current_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.State.current)
}
inline void State::set_current(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  current_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.State.current)
}
inline void State::set_current(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  current_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.State.current)
}
inline std::string* State::mutable_current() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:p2p.State.current)
  return current_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* State::release_current() {
  // @@protoc_insertion_point(field_release:p2p.State.current)
  if (!has_current()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return current_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void State::set_allocated_current(std::string* current) {
  if (current != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  current_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current);
  // @@protoc_insertion_point(field_set_allocated:p2p.State.current)
}

// optional .p2p.StateDifference difference = 3;
inline bool State::has_difference() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State::clear_difference() {
  if (difference_ != nullptr) difference_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::p2p::StateDifference& State::difference() const {
  const ::p2p::StateDifference* p = difference_;
  // @@protoc_insertion_point(field_get:p2p.State.difference)
  return p != nullptr ? *p : *reinterpret_cast<const ::p2p::StateDifference*>(
      &::p2p::_StateDifference_default_instance_);
}
inline ::p2p::StateDifference* State::release_difference() {
  // @@protoc_insertion_point(field_release:p2p.State.difference)
  _has_bits_[0] &= ~0x00000004u;
  ::p2p::StateDifference* temp = difference_;
  difference_ = nullptr;
  return temp;
}
inline ::p2p::StateDifference* State::mutable_difference() {
  _has_bits_[0] |= 0x00000004u;
  if (difference_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2p::StateDifference>(GetArenaNoVirtual());
    difference_ = p;
  }
  // @@protoc_insertion_point(field_mutable:p2p.State.difference)
  return difference_;
}
inline void State::set_allocated_difference(::p2p::StateDifference* difference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete difference_;
  }
  if (difference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      difference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, difference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  difference_ = difference;
  // @@protoc_insertion_point(field_set_allocated:p2p.State.difference)
}

// map<string, string> patch = 4;
inline int State::patch_size() const {
  return patch_.size();
}
inline void State::clear_patch() {
  patch_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
State::patch() const {
  // @@protoc_insertion_point(field_map:p2p.State.patch)
  return patch_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
State::mutable_patch() {
  // @@protoc_insertion_point(field_mutable_map:p2p.State.patch)
  return patch_.MutableMap();
}

// -------------------------------------------------------------------

// Proposal

// repeated string connections = 1;
inline int Proposal::connections_size() const {
  return connections_.size();
}
inline void Proposal::clear_connections() {
  connections_.Clear();
}
inline const std::string& Proposal::connections(int index) const {
  // @@protoc_insertion_point(field_get:p2p.Proposal.connections)
  return connections_.Get(index);
}
inline std::string* Proposal::mutable_connections(int index) {
  // @@protoc_insertion_point(field_mutable:p2p.Proposal.connections)
  return connections_.Mutable(index);
}
inline void Proposal::set_connections(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:p2p.Proposal.connections)
  connections_.Mutable(index)->assign(value);
}
inline void Proposal::set_connections(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:p2p.Proposal.connections)
  connections_.Mutable(index)->assign(std::move(value));
}
inline void Proposal::set_connections(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  connections_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:p2p.Proposal.connections)
}
inline void Proposal::set_connections(int index, const char* value, size_t size) {
  connections_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:p2p.Proposal.connections)
}
inline std::string* Proposal::add_connections() {
  // @@protoc_insertion_point(field_add_mutable:p2p.Proposal.connections)
  return connections_.Add();
}
inline void Proposal::add_connections(const std::string& value) {
  connections_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:p2p.Proposal.connections)
}
inline void Proposal::add_connections(std::string&& value) {
  connections_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:p2p.Proposal.connections)
}
inline void Proposal::add_connections(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  connections_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:p2p.Proposal.connections)
}
inline void Proposal::add_connections(const char* value, size_t size) {
  connections_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:p2p.Proposal.connections)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Proposal::connections() const {
  // @@protoc_insertion_point(field_list:p2p.Proposal.connections)
  return connections_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Proposal::mutable_connections() {
  // @@protoc_insertion_point(field_mutable_list:p2p.Proposal.connections)
  return &connections_;
}

// repeated string inputs = 2;
inline int Proposal::inputs_size() const {
  return inputs_.size();
}
inline void Proposal::clear_inputs() {
  inputs_.Clear();
}
inline const std::string& Proposal::inputs(int index) const {
  // @@protoc_insertion_point(field_get:p2p.Proposal.inputs)
  return inputs_.Get(index);
}
inline std::string* Proposal::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:p2p.Proposal.inputs)
  return inputs_.Mutable(index);
}
inline void Proposal::set_inputs(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:p2p.Proposal.inputs)
  inputs_.Mutable(index)->assign(value);
}
inline void Proposal::set_inputs(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:p2p.Proposal.inputs)
  inputs_.Mutable(index)->assign(std::move(value));
}
inline void Proposal::set_inputs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  inputs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:p2p.Proposal.inputs)
}
inline void Proposal::set_inputs(int index, const char* value, size_t size) {
  inputs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:p2p.Proposal.inputs)
}
inline std::string* Proposal::add_inputs() {
  // @@protoc_insertion_point(field_add_mutable:p2p.Proposal.inputs)
  return inputs_.Add();
}
inline void Proposal::add_inputs(const std::string& value) {
  inputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:p2p.Proposal.inputs)
}
inline void Proposal::add_inputs(std::string&& value) {
  inputs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:p2p.Proposal.inputs)
}
inline void Proposal::add_inputs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  inputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:p2p.Proposal.inputs)
}
inline void Proposal::add_inputs(const char* value, size_t size) {
  inputs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:p2p.Proposal.inputs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Proposal::inputs() const {
  // @@protoc_insertion_point(field_list:p2p.Proposal.inputs)
  return inputs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Proposal::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:p2p.Proposal.inputs)
  return &inputs_;
}

// repeated string outputs = 3;
inline int Proposal::outputs_size() const {
  return outputs_.size();
}
inline void Proposal::clear_outputs() {
  outputs_.Clear();
}
inline const std::string& Proposal::outputs(int index) const {
  // @@protoc_insertion_point(field_get:p2p.Proposal.outputs)
  return outputs_.Get(index);
}
inline std::string* Proposal::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:p2p.Proposal.outputs)
  return outputs_.Mutable(index);
}
inline void Proposal::set_outputs(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:p2p.Proposal.outputs)
  outputs_.Mutable(index)->assign(value);
}
inline void Proposal::set_outputs(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:p2p.Proposal.outputs)
  outputs_.Mutable(index)->assign(std::move(value));
}
inline void Proposal::set_outputs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  outputs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:p2p.Proposal.outputs)
}
inline void Proposal::set_outputs(int index, const char* value, size_t size) {
  outputs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:p2p.Proposal.outputs)
}
inline std::string* Proposal::add_outputs() {
  // @@protoc_insertion_point(field_add_mutable:p2p.Proposal.outputs)
  return outputs_.Add();
}
inline void Proposal::add_outputs(const std::string& value) {
  outputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:p2p.Proposal.outputs)
}
inline void Proposal::add_outputs(std::string&& value) {
  outputs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:p2p.Proposal.outputs)
}
inline void Proposal::add_outputs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  outputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:p2p.Proposal.outputs)
}
inline void Proposal::add_outputs(const char* value, size_t size) {
  outputs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:p2p.Proposal.outputs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Proposal::outputs() const {
  // @@protoc_insertion_point(field_list:p2p.Proposal.outputs)
  return outputs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Proposal::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:p2p.Proposal.outputs)
  return &outputs_;
}

// optional int32 stage = 4;
inline bool Proposal::has_stage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proposal::clear_stage() {
  stage_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Proposal::stage() const {
  // @@protoc_insertion_point(field_get:p2p.Proposal.stage)
  return stage_;
}
inline void Proposal::set_stage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  stage_ = value;
  // @@protoc_insertion_point(field_set:p2p.Proposal.stage)
}

// optional int32 time = 5;
inline bool Proposal::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proposal::clear_time() {
  time_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Proposal::time() const {
  // @@protoc_insertion_point(field_get:p2p.Proposal.time)
  return time_;
}
inline void Proposal::set_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  time_ = value;
  // @@protoc_insertion_point(field_set:p2p.Proposal.time)
}

// optional .p2p.State state = 6;
inline bool Proposal::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proposal::clear_state() {
  if (state_ != nullptr) state_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::p2p::State& Proposal::state() const {
  const ::p2p::State* p = state_;
  // @@protoc_insertion_point(field_get:p2p.Proposal.state)
  return p != nullptr ? *p : *reinterpret_cast<const ::p2p::State*>(
      &::p2p::_State_default_instance_);
}
inline ::p2p::State* Proposal::release_state() {
  // @@protoc_insertion_point(field_release:p2p.Proposal.state)
  _has_bits_[0] &= ~0x00000002u;
  ::p2p::State* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::p2p::State* Proposal::mutable_state() {
  _has_bits_[0] |= 0x00000002u;
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2p::State>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:p2p.Proposal.state)
  return state_;
}
inline void Proposal::set_allocated_state(::p2p::State* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:p2p.Proposal.state)
}

// optional bytes lcl = 7;
inline bool Proposal::has_lcl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proposal::clear_lcl() {
  lcl_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Proposal::lcl() const {
  // @@protoc_insertion_point(field_get:p2p.Proposal.lcl)
  return lcl_.GetNoArena();
}
inline void Proposal::set_lcl(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  lcl_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Proposal.lcl)
}
inline void Proposal::set_lcl(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  lcl_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Proposal.lcl)
}
inline void Proposal::set_lcl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  lcl_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Proposal.lcl)
}
inline void Proposal::set_lcl(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  lcl_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Proposal.lcl)
}
inline std::string* Proposal::mutable_lcl() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:p2p.Proposal.lcl)
  return lcl_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Proposal::release_lcl() {
  // @@protoc_insertion_point(field_release:p2p.Proposal.lcl)
  if (!has_lcl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return lcl_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Proposal::set_allocated_lcl(std::string* lcl) {
  if (lcl != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  lcl_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lcl);
  // @@protoc_insertion_point(field_set_allocated:p2p.Proposal.lcl)
}

// -------------------------------------------------------------------

// NPL

// optional bytes data = 1;
inline bool NPL::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NPL::clear_data() {
  data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NPL::data() const {
  // @@protoc_insertion_point(field_get:p2p.NPL.data)
  return data_.GetNoArena();
}
inline void NPL::set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.NPL.data)
}
inline void NPL::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.NPL.data)
}
inline void NPL::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.NPL.data)
}
inline void NPL::set_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.NPL.data)
}
inline std::string* NPL::mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:p2p.NPL.data)
  return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NPL::release_data() {
  // @@protoc_insertion_point(field_release:p2p.NPL.data)
  if (!has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NPL::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:p2p.NPL.data)
}

// optional bytes lcl = 2;
inline bool NPL::has_lcl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NPL::clear_lcl() {
  lcl_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NPL::lcl() const {
  // @@protoc_insertion_point(field_get:p2p.NPL.lcl)
  return lcl_.GetNoArena();
}
inline void NPL::set_lcl(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  lcl_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.NPL.lcl)
}
inline void NPL::set_lcl(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  lcl_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.NPL.lcl)
}
inline void NPL::set_lcl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  lcl_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.NPL.lcl)
}
inline void NPL::set_lcl(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  lcl_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.NPL.lcl)
}
inline std::string* NPL::mutable_lcl() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:p2p.NPL.lcl)
  return lcl_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NPL::release_lcl() {
  // @@protoc_insertion_point(field_release:p2p.NPL.lcl)
  if (!has_lcl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return lcl_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NPL::set_allocated_lcl(std::string* lcl) {
  if (lcl != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  lcl_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lcl);
  // @@protoc_insertion_point(field_set_allocated:p2p.NPL.lcl)
}

// -------------------------------------------------------------------

// StateRequest

// -------------------------------------------------------------------

// StateResponse

// -------------------------------------------------------------------

// HistoryRequest

// -------------------------------------------------------------------

// HistoryResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace p2p

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::p2p::Message_Messagetype> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::p2p::Message_Messagetype>() {
  return ::p2p::Message_Messagetype_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
