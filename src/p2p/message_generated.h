// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGE_P2P_H_
#define FLATBUFFERS_GENERATED_MESSAGE_P2P_H_

#include "flatbuffers/flatbuffers.h"

namespace p2p {

struct StringKeyValuePair;

struct ByteArray;

struct Container;

struct Content;

struct Proposal;

struct Npl;

struct StateDifference;

struct State;

enum Messase {
  Messase_NONE = 0,
  Messase_Proposal = 1,
  Messase_Npl = 2,
  Messase_MIN = Messase_NONE,
  Messase_MAX = Messase_Npl
};

inline const Messase (&EnumValuesMessase())[3] {
  static const Messase values[] = {
    Messase_NONE,
    Messase_Proposal,
    Messase_Npl
  };
  return values;
}

inline const char * const *EnumNamesMessase() {
  static const char * const names[] = {
    "NONE",
    "Proposal",
    "Npl",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessase(Messase e) {
  if (e < Messase_NONE || e > Messase_Npl) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessase()[index];
}

template<typename T> struct MessaseTraits {
  static const Messase enum_value = Messase_NONE;
};

template<> struct MessaseTraits<Proposal> {
  static const Messase enum_value = Messase_Proposal;
};

template<> struct MessaseTraits<Npl> {
  static const Messase enum_value = Messase_Npl;
};

bool VerifyMessase(flatbuffers::Verifier &verifier, const void *obj, Messase type);
bool VerifyMessaseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct StringKeyValuePair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::Vector<uint8_t> *key() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_KEY);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyVector(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringKeyValuePairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> key) {
    fbb_.AddOffset(StringKeyValuePair::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(StringKeyValuePair::VT_VALUE, value);
  }
  explicit StringKeyValuePairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringKeyValuePairBuilder &operator=(const StringKeyValuePairBuilder &);
  flatbuffers::Offset<StringKeyValuePair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringKeyValuePair>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringKeyValuePair> CreateStringKeyValuePair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringKeyValuePairBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringKeyValuePair> CreateStringKeyValuePairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateVector<uint8_t>(*key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return p2p::CreateStringKeyValuePair(
      _fbb,
      key__,
      value__);
}

struct ByteArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARRAY = 4
  };
  const flatbuffers::Vector<uint8_t> *array() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ARRAY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARRAY) &&
           verifier.VerifyVector(array()) &&
           verifier.EndTable();
  }
};

struct ByteArrayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_array(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> array) {
    fbb_.AddOffset(ByteArray::VT_ARRAY, array);
  }
  explicit ByteArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ByteArrayBuilder &operator=(const ByteArrayBuilder &);
  flatbuffers::Offset<ByteArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ByteArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<ByteArray> CreateByteArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> array = 0) {
  ByteArrayBuilder builder_(_fbb);
  builder_.add_array(array);
  return builder_.Finish();
}

inline flatbuffers::Offset<ByteArray> CreateByteArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *array = nullptr) {
  auto array__ = array ? _fbb.CreateVector<uint8_t>(*array) : 0;
  return p2p::CreateByteArray(
      _fbb,
      array__);
}

struct Container FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_SIGNATURE = 6,
    VT_CONTENT = 8
  };
  uint16_t version() const {
    return GetField<uint16_t>(VT_VERSION, 0);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  const flatbuffers::Vector<uint8_t> *content() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           verifier.EndTable();
  }
};

struct ContainerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint16_t version) {
    fbb_.AddElement<uint16_t>(Container::VT_VERSION, version, 0);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(Container::VT_SIGNATURE, signature);
  }
  void add_content(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> content) {
    fbb_.AddOffset(Container::VT_CONTENT, content);
  }
  explicit ContainerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerBuilder &operator=(const ContainerBuilder &);
  flatbuffers::Offset<Container> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Container>(end);
    return o;
  }
};

inline flatbuffers::Offset<Container> CreateContainer(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> content = 0) {
  ContainerBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_signature(signature);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Container> CreateContainerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t version = 0,
    const std::vector<uint8_t> *signature = nullptr,
    const std::vector<uint8_t> *content = nullptr) {
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  auto content__ = content ? _fbb.CreateVector<uint8_t>(*content) : 0;
  return p2p::CreateContainer(
      _fbb,
      version,
      signature__,
      content__);
}

struct Content FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  Messase message_type() const {
    return static_cast<Messase>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const Proposal *message_as_Proposal() const {
    return message_type() == Messase_Proposal ? static_cast<const Proposal *>(message()) : nullptr;
  }
  const Npl *message_as_Npl() const {
    return message_type() == Messase_Npl ? static_cast<const Npl *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessase(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Proposal *Content::message_as<Proposal>() const {
  return message_as_Proposal();
}

template<> inline const Npl *Content::message_as<Npl>() const {
  return message_as_Npl();
}

struct ContentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Messase message_type) {
    fbb_.AddElement<uint8_t>(Content::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Content::VT_MESSAGE, message);
  }
  explicit ContentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContentBuilder &operator=(const ContentBuilder &);
  flatbuffers::Offset<Content> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Content>(end);
    return o;
  }
};

inline flatbuffers::Offset<Content> CreateContent(
    flatbuffers::FlatBufferBuilder &_fbb,
    Messase message_type = Messase_NONE,
    flatbuffers::Offset<void> message = 0) {
  ContentBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct Proposal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_TIMESTAMP = 6,
    VT_STAGE = 8,
    VT_TIME = 10,
    VT_LCL = 12,
    VT_CONNECTIONS = 14,
    VT_RAW_INPUTS = 16,
    VT_HASH_INPUTS = 18,
    VT_RAW_OUTPUTS = 20,
    VT_HASH_OUTPUTS = 22,
    VT_STATE = 24
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  int8_t stage() const {
    return GetField<int8_t>(VT_STAGE, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  const flatbuffers::Vector<uint8_t> *lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ByteArray>> *connections() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ByteArray>> *>(VT_CONNECTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *raw_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *>(VT_RAW_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *hash_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HASH_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *raw_outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *>(VT_RAW_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *hash_outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HASH_OUTPUTS);
  }
  const State *state() const {
    return GetPointer<const State *>(VT_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int8_t>(verifier, VT_STAGE) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_LCL) &&
           verifier.VerifyVector(lcl()) &&
           VerifyOffset(verifier, VT_CONNECTIONS) &&
           verifier.VerifyVector(connections()) &&
           verifier.VerifyVectorOfTables(connections()) &&
           VerifyOffset(verifier, VT_RAW_INPUTS) &&
           verifier.VerifyVector(raw_inputs()) &&
           verifier.VerifyVectorOfTables(raw_inputs()) &&
           VerifyOffset(verifier, VT_HASH_INPUTS) &&
           verifier.VerifyVector(hash_inputs()) &&
           verifier.VerifyVectorOfStrings(hash_inputs()) &&
           VerifyOffset(verifier, VT_RAW_OUTPUTS) &&
           verifier.VerifyVector(raw_outputs()) &&
           verifier.VerifyVectorOfTables(raw_outputs()) &&
           VerifyOffset(verifier, VT_HASH_OUTPUTS) &&
           verifier.VerifyVector(hash_outputs()) &&
           verifier.VerifyVectorOfStrings(hash_outputs()) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyTable(state()) &&
           verifier.EndTable();
  }
};

struct ProposalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(Proposal::VT_PUBKEY, pubkey);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Proposal::VT_TIMESTAMP, timestamp, 0);
  }
  void add_stage(int8_t stage) {
    fbb_.AddElement<int8_t>(Proposal::VT_STAGE, stage, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(Proposal::VT_TIME, time, 0);
  }
  void add_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl) {
    fbb_.AddOffset(Proposal::VT_LCL, lcl);
  }
  void add_connections(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ByteArray>>> connections) {
    fbb_.AddOffset(Proposal::VT_CONNECTIONS, connections);
  }
  void add_raw_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> raw_inputs) {
    fbb_.AddOffset(Proposal::VT_RAW_INPUTS, raw_inputs);
  }
  void add_hash_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> hash_inputs) {
    fbb_.AddOffset(Proposal::VT_HASH_INPUTS, hash_inputs);
  }
  void add_raw_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> raw_outputs) {
    fbb_.AddOffset(Proposal::VT_RAW_OUTPUTS, raw_outputs);
  }
  void add_hash_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> hash_outputs) {
    fbb_.AddOffset(Proposal::VT_HASH_OUTPUTS, hash_outputs);
  }
  void add_state(flatbuffers::Offset<State> state) {
    fbb_.AddOffset(Proposal::VT_STATE, state);
  }
  explicit ProposalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProposalBuilder &operator=(const ProposalBuilder &);
  flatbuffers::Offset<Proposal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Proposal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Proposal> CreateProposal(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    uint64_t timestamp = 0,
    int8_t stage = 0,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ByteArray>>> connections = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> raw_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> hash_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> raw_outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> hash_outputs = 0,
    flatbuffers::Offset<State> state = 0) {
  ProposalBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_timestamp(timestamp);
  builder_.add_state(state);
  builder_.add_hash_outputs(hash_outputs);
  builder_.add_raw_outputs(raw_outputs);
  builder_.add_hash_inputs(hash_inputs);
  builder_.add_raw_inputs(raw_inputs);
  builder_.add_connections(connections);
  builder_.add_lcl(lcl);
  builder_.add_pubkey(pubkey);
  builder_.add_stage(stage);
  return builder_.Finish();
}

inline flatbuffers::Offset<Proposal> CreateProposalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    uint64_t timestamp = 0,
    int8_t stage = 0,
    uint64_t time = 0,
    const std::vector<uint8_t> *lcl = nullptr,
    const std::vector<flatbuffers::Offset<ByteArray>> *connections = nullptr,
    const std::vector<flatbuffers::Offset<StringKeyValuePair>> *raw_inputs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *hash_inputs = nullptr,
    const std::vector<flatbuffers::Offset<StringKeyValuePair>> *raw_outputs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *hash_outputs = nullptr,
    flatbuffers::Offset<State> state = 0) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto lcl__ = lcl ? _fbb.CreateVector<uint8_t>(*lcl) : 0;
  auto connections__ = connections ? _fbb.CreateVector<flatbuffers::Offset<ByteArray>>(*connections) : 0;
  auto raw_inputs__ = raw_inputs ? _fbb.CreateVector<flatbuffers::Offset<StringKeyValuePair>>(*raw_inputs) : 0;
  auto hash_inputs__ = hash_inputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*hash_inputs) : 0;
  auto raw_outputs__ = raw_outputs ? _fbb.CreateVector<flatbuffers::Offset<StringKeyValuePair>>(*raw_outputs) : 0;
  auto hash_outputs__ = hash_outputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*hash_outputs) : 0;
  return p2p::CreateProposal(
      _fbb,
      pubkey__,
      timestamp,
      stage,
      time,
      lcl__,
      connections__,
      raw_inputs__,
      hash_inputs__,
      raw_outputs__,
      hash_outputs__,
      state);
}

struct Npl FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_TIMESTAMP = 6,
    VT_DATA = 8,
    VT_LCL = 10
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  const flatbuffers::Vector<uint8_t> *lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_LCL) &&
           verifier.VerifyVector(lcl()) &&
           verifier.EndTable();
  }
};

struct NplBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(Npl::VT_PUBKEY, pubkey);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Npl::VT_TIMESTAMP, timestamp, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Npl::VT_DATA, data);
  }
  void add_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl) {
    fbb_.AddOffset(Npl::VT_LCL, lcl);
  }
  explicit NplBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NplBuilder &operator=(const NplBuilder &);
  flatbuffers::Offset<Npl> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Npl>(end);
    return o;
  }
};

inline flatbuffers::Offset<Npl> CreateNpl(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    uint64_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl = 0) {
  NplBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_lcl(lcl);
  builder_.add_data(data);
  builder_.add_pubkey(pubkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Npl> CreateNplDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    uint64_t timestamp = 0,
    const std::vector<uint8_t> *data = nullptr,
    const std::vector<uint8_t> *lcl = nullptr) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  auto lcl__ = lcl ? _fbb.CreateVector<uint8_t>(*lcl) : 0;
  return p2p::CreateNpl(
      _fbb,
      pubkey__,
      timestamp,
      data__,
      lcl__);
}

struct StateDifference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CREATED = 4,
    VT_UPDATED = 6,
    VT_DELETED = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *created() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *>(VT_CREATED);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *updated() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *>(VT_UPDATED);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *deleted() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *>(VT_DELETED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CREATED) &&
           verifier.VerifyVector(created()) &&
           verifier.VerifyVectorOfTables(created()) &&
           VerifyOffset(verifier, VT_UPDATED) &&
           verifier.VerifyVector(updated()) &&
           verifier.VerifyVectorOfTables(updated()) &&
           VerifyOffset(verifier, VT_DELETED) &&
           verifier.VerifyVector(deleted()) &&
           verifier.VerifyVectorOfTables(deleted()) &&
           verifier.EndTable();
  }
};

struct StateDifferenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_created(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> created) {
    fbb_.AddOffset(StateDifference::VT_CREATED, created);
  }
  void add_updated(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> updated) {
    fbb_.AddOffset(StateDifference::VT_UPDATED, updated);
  }
  void add_deleted(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> deleted) {
    fbb_.AddOffset(StateDifference::VT_DELETED, deleted);
  }
  explicit StateDifferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateDifferenceBuilder &operator=(const StateDifferenceBuilder &);
  flatbuffers::Offset<StateDifference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StateDifference>(end);
    return o;
  }
};

inline flatbuffers::Offset<StateDifference> CreateStateDifference(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> created = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> updated = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> deleted = 0) {
  StateDifferenceBuilder builder_(_fbb);
  builder_.add_deleted(deleted);
  builder_.add_updated(updated);
  builder_.add_created(created);
  return builder_.Finish();
}

inline flatbuffers::Offset<StateDifference> CreateStateDifferenceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<StringKeyValuePair>> *created = nullptr,
    const std::vector<flatbuffers::Offset<StringKeyValuePair>> *updated = nullptr,
    const std::vector<flatbuffers::Offset<StringKeyValuePair>> *deleted = nullptr) {
  auto created__ = created ? _fbb.CreateVector<flatbuffers::Offset<StringKeyValuePair>>(*created) : 0;
  auto updated__ = updated ? _fbb.CreateVector<flatbuffers::Offset<StringKeyValuePair>>(*updated) : 0;
  auto deleted__ = deleted ? _fbb.CreateVector<flatbuffers::Offset<StringKeyValuePair>>(*deleted) : 0;
  return p2p::CreateStateDifference(
      _fbb,
      created__,
      updated__,
      deleted__);
}

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PREVIOUS = 4,
    VT_CURRENT = 6,
    VT_DIFFERENCE = 8,
    VT_PATCH = 10
  };
  const flatbuffers::Vector<uint8_t> *previous() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PREVIOUS);
  }
  const flatbuffers::Vector<uint8_t> *current() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CURRENT);
  }
  const StateDifference *difference() const {
    return GetPointer<const StateDifference *>(VT_DIFFERENCE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *patch() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>> *>(VT_PATCH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PREVIOUS) &&
           verifier.VerifyVector(previous()) &&
           VerifyOffset(verifier, VT_CURRENT) &&
           verifier.VerifyVector(current()) &&
           VerifyOffset(verifier, VT_DIFFERENCE) &&
           verifier.VerifyTable(difference()) &&
           VerifyOffset(verifier, VT_PATCH) &&
           verifier.VerifyVector(patch()) &&
           verifier.VerifyVectorOfTables(patch()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_previous(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> previous) {
    fbb_.AddOffset(State::VT_PREVIOUS, previous);
  }
  void add_current(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> current) {
    fbb_.AddOffset(State::VT_CURRENT, current);
  }
  void add_difference(flatbuffers::Offset<StateDifference> difference) {
    fbb_.AddOffset(State::VT_DIFFERENCE, difference);
  }
  void add_patch(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> patch) {
    fbb_.AddOffset(State::VT_PATCH, patch);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> previous = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> current = 0,
    flatbuffers::Offset<StateDifference> difference = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringKeyValuePair>>> patch = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_patch(patch);
  builder_.add_difference(difference);
  builder_.add_current(current);
  builder_.add_previous(previous);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *previous = nullptr,
    const std::vector<uint8_t> *current = nullptr,
    flatbuffers::Offset<StateDifference> difference = 0,
    const std::vector<flatbuffers::Offset<StringKeyValuePair>> *patch = nullptr) {
  auto previous__ = previous ? _fbb.CreateVector<uint8_t>(*previous) : 0;
  auto current__ = current ? _fbb.CreateVector<uint8_t>(*current) : 0;
  auto patch__ = patch ? _fbb.CreateVector<flatbuffers::Offset<StringKeyValuePair>>(*patch) : 0;
  return p2p::CreateState(
      _fbb,
      previous__,
      current__,
      difference,
      patch__);
}

inline bool VerifyMessase(flatbuffers::Verifier &verifier, const void *obj, Messase type) {
  switch (type) {
    case Messase_NONE: {
      return true;
    }
    case Messase_Proposal: {
      auto ptr = reinterpret_cast<const Proposal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Messase_Npl: {
      auto ptr = reinterpret_cast<const Npl *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessaseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessase(
        verifier,  values->Get(i), types->GetEnum<Messase>(i))) {
      return false;
    }
  }
  return true;
}

inline const p2p::Container *GetContainer(const void *buf) {
  return flatbuffers::GetRoot<p2p::Container>(buf);
}

inline const p2p::Container *GetSizePrefixedContainer(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<p2p::Container>(buf);
}

inline bool VerifyContainerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<p2p::Container>(nullptr);
}

inline bool VerifySizePrefixedContainerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<p2p::Container>(nullptr);
}

inline void FinishContainerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<p2p::Container> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedContainerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<p2p::Container> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace p2p

#endif  // FLATBUFFERS_GENERATED_MESSAGE_P2P_H_
