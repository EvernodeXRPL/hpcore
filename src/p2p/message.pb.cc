// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#include "message.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_message_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_State_message_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_message_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_State_PatchEntry_DoNotUse_message_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_message_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_StateDifference_message_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_message_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StateDifference_CreatedEntry_DoNotUse_message_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_message_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StateDifference_DeletedEntry_DoNotUse_message_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_message_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StateDifference_UpdatedEntry_DoNotUse_message_2eproto;
namespace p2p {
class MessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Message> _instance;
} _Message_default_instance_;
class StateDifference_CreatedEntry_DoNotUseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StateDifference_CreatedEntry_DoNotUse> _instance;
} _StateDifference_CreatedEntry_DoNotUse_default_instance_;
class StateDifference_UpdatedEntry_DoNotUseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StateDifference_UpdatedEntry_DoNotUse> _instance;
} _StateDifference_UpdatedEntry_DoNotUse_default_instance_;
class StateDifference_DeletedEntry_DoNotUseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StateDifference_DeletedEntry_DoNotUse> _instance;
} _StateDifference_DeletedEntry_DoNotUse_default_instance_;
class StateDifferenceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StateDifference> _instance;
} _StateDifference_default_instance_;
class State_PatchEntry_DoNotUseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<State_PatchEntry_DoNotUse> _instance;
} _State_PatchEntry_DoNotUse_default_instance_;
class StateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<State> _instance;
} _State_default_instance_;
class ProposalDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Proposal> _instance;
} _Proposal_default_instance_;
class NPLDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NPL> _instance;
} _NPL_default_instance_;
class StateRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StateRequest> _instance;
} _StateRequest_default_instance_;
class StateResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StateResponse> _instance;
} _StateResponse_default_instance_;
class HistoryRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HistoryRequest> _instance;
} _HistoryRequest_default_instance_;
class HistoryResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HistoryResponse> _instance;
} _HistoryResponse_default_instance_;
}  // namespace p2p
static void InitDefaultsscc_info_HistoryRequest_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_HistoryRequest_default_instance_;
    new (ptr) ::p2p::HistoryRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::p2p::HistoryRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HistoryRequest_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_HistoryRequest_message_2eproto}, {}};

static void InitDefaultsscc_info_HistoryResponse_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_HistoryResponse_default_instance_;
    new (ptr) ::p2p::HistoryResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::p2p::HistoryResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HistoryResponse_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_HistoryResponse_message_2eproto}, {}};

static void InitDefaultsscc_info_Message_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_Message_default_instance_;
    new (ptr) ::p2p::Message();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::p2p::Message::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Message_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Message_message_2eproto}, {}};

static void InitDefaultsscc_info_NPL_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_NPL_default_instance_;
    new (ptr) ::p2p::NPL();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::p2p::NPL::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_NPL_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_NPL_message_2eproto}, {}};

static void InitDefaultsscc_info_Proposal_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_Proposal_default_instance_;
    new (ptr) ::p2p::Proposal();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::p2p::Proposal::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Proposal_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Proposal_message_2eproto}, {
      &scc_info_State_message_2eproto.base,}};

static void InitDefaultsscc_info_State_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_State_default_instance_;
    new (ptr) ::p2p::State();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::p2p::State::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_State_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_State_message_2eproto}, {
      &scc_info_StateDifference_message_2eproto.base,
      &scc_info_State_PatchEntry_DoNotUse_message_2eproto.base,}};

static void InitDefaultsscc_info_State_PatchEntry_DoNotUse_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_State_PatchEntry_DoNotUse_default_instance_;
    new (ptr) ::p2p::State_PatchEntry_DoNotUse();
  }
  ::p2p::State_PatchEntry_DoNotUse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_State_PatchEntry_DoNotUse_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_State_PatchEntry_DoNotUse_message_2eproto}, {}};

static void InitDefaultsscc_info_StateDifference_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_StateDifference_default_instance_;
    new (ptr) ::p2p::StateDifference();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::p2p::StateDifference::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_StateDifference_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_StateDifference_message_2eproto}, {
      &scc_info_StateDifference_CreatedEntry_DoNotUse_message_2eproto.base,
      &scc_info_StateDifference_UpdatedEntry_DoNotUse_message_2eproto.base,
      &scc_info_StateDifference_DeletedEntry_DoNotUse_message_2eproto.base,}};

static void InitDefaultsscc_info_StateDifference_CreatedEntry_DoNotUse_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_StateDifference_CreatedEntry_DoNotUse_default_instance_;
    new (ptr) ::p2p::StateDifference_CreatedEntry_DoNotUse();
  }
  ::p2p::StateDifference_CreatedEntry_DoNotUse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StateDifference_CreatedEntry_DoNotUse_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StateDifference_CreatedEntry_DoNotUse_message_2eproto}, {}};

static void InitDefaultsscc_info_StateDifference_DeletedEntry_DoNotUse_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_StateDifference_DeletedEntry_DoNotUse_default_instance_;
    new (ptr) ::p2p::StateDifference_DeletedEntry_DoNotUse();
  }
  ::p2p::StateDifference_DeletedEntry_DoNotUse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StateDifference_DeletedEntry_DoNotUse_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StateDifference_DeletedEntry_DoNotUse_message_2eproto}, {}};

static void InitDefaultsscc_info_StateDifference_UpdatedEntry_DoNotUse_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_StateDifference_UpdatedEntry_DoNotUse_default_instance_;
    new (ptr) ::p2p::StateDifference_UpdatedEntry_DoNotUse();
  }
  ::p2p::StateDifference_UpdatedEntry_DoNotUse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StateDifference_UpdatedEntry_DoNotUse_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StateDifference_UpdatedEntry_DoNotUse_message_2eproto}, {}};

static void InitDefaultsscc_info_StateRequest_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_StateRequest_default_instance_;
    new (ptr) ::p2p::StateRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::p2p::StateRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StateRequest_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StateRequest_message_2eproto}, {}};

static void InitDefaultsscc_info_StateResponse_message_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::p2p::_StateResponse_default_instance_;
    new (ptr) ::p2p::StateResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::p2p::StateResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StateResponse_message_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StateResponse_message_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_message_2eproto[13];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_message_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_message_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_message_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::p2p::Message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::Message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::Message, version_),
  PROTOBUF_FIELD_OFFSET(::p2p::Message, publickey_),
  PROTOBUF_FIELD_OFFSET(::p2p::Message, timestamp_),
  PROTOBUF_FIELD_OFFSET(::p2p::Message, signature_),
  PROTOBUF_FIELD_OFFSET(::p2p::Message, type_),
  PROTOBUF_FIELD_OFFSET(::p2p::Message, content_),
  0,
  1,
  4,
  2,
  5,
  3,
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_CreatedEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_CreatedEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_CreatedEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_CreatedEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_UpdatedEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_UpdatedEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_UpdatedEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_UpdatedEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_DeletedEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_DeletedEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_DeletedEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference_DeletedEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference, created_),
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference, updated_),
  PROTOBUF_FIELD_OFFSET(::p2p::StateDifference, deleted_),
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::p2p::State_PatchEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::State_PatchEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::State_PatchEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::p2p::State_PatchEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2p::State, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::State, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::State, previous_),
  PROTOBUF_FIELD_OFFSET(::p2p::State, current_),
  PROTOBUF_FIELD_OFFSET(::p2p::State, difference_),
  PROTOBUF_FIELD_OFFSET(::p2p::State, patch_),
  0,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::p2p::Proposal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::Proposal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::Proposal, connections_),
  PROTOBUF_FIELD_OFFSET(::p2p::Proposal, inputs_),
  PROTOBUF_FIELD_OFFSET(::p2p::Proposal, outputs_),
  PROTOBUF_FIELD_OFFSET(::p2p::Proposal, stage_),
  PROTOBUF_FIELD_OFFSET(::p2p::Proposal, time_),
  PROTOBUF_FIELD_OFFSET(::p2p::Proposal, state_),
  PROTOBUF_FIELD_OFFSET(::p2p::Proposal, lcl_),
  ~0u,
  ~0u,
  ~0u,
  2,
  3,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::p2p::NPL, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::NPL, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::NPL, data_),
  PROTOBUF_FIELD_OFFSET(::p2p::NPL, lcl_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2p::StateRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::StateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::StateResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::StateResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::HistoryRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::HistoryRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::p2p::HistoryResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2p::HistoryResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, sizeof(::p2p::Message)},
  { 17, 24, sizeof(::p2p::StateDifference_CreatedEntry_DoNotUse)},
  { 26, 33, sizeof(::p2p::StateDifference_UpdatedEntry_DoNotUse)},
  { 35, 42, sizeof(::p2p::StateDifference_DeletedEntry_DoNotUse)},
  { 44, 52, sizeof(::p2p::StateDifference)},
  { 55, 62, sizeof(::p2p::State_PatchEntry_DoNotUse)},
  { 64, 73, sizeof(::p2p::State)},
  { 77, 89, sizeof(::p2p::Proposal)},
  { 96, 103, sizeof(::p2p::NPL)},
  { 105, 110, sizeof(::p2p::StateRequest)},
  { 110, 115, sizeof(::p2p::StateResponse)},
  { 115, 120, sizeof(::p2p::HistoryRequest)},
  { 120, 125, sizeof(::p2p::HistoryResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_Message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_StateDifference_CreatedEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_StateDifference_UpdatedEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_StateDifference_DeletedEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_StateDifference_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_State_PatchEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_State_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_Proposal_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_NPL_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_StateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_StateResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_HistoryRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::p2p::_HistoryResponse_default_instance_),
};

const char descriptor_table_protodef_message_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rmessage.proto\022\003p2p\"\204\002\n\007Message\022\017\n\007vers"
  "ion\030\001 \001(\t\022\021\n\tpublicKey\030\002 \001(\014\022\021\n\ttimestam"
  "p\030\003 \001(\005\022\021\n\tsignature\030\004 \001(\014\022&\n\004type\030\005 \001(\016"
  "2\030.p2p.Message.Messagetype\022\017\n\007content\030\006 "
  "\001(\014\"v\n\013Messagetype\022\014\n\010PROPOSAL\020\000\022\007\n\003NPL\020"
  "\001\022\021\n\rSTATE_REQUEST\020\002\022\022\n\016STATE_RESPONSE\020\003"
  "\022\023\n\017HISTORY_REQUEST\020\004\022\024\n\020HISTORY_RESPONS"
  "E\020\005\"\275\002\n\017StateDifference\0222\n\007created\030\001 \003(\013"
  "2!.p2p.StateDifference.CreatedEntry\0222\n\007u"
  "pdated\030\002 \003(\0132!.p2p.StateDifference.Updat"
  "edEntry\0222\n\007deleted\030\003 \003(\0132!.p2p.StateDiff"
  "erence.DeletedEntry\032.\n\014CreatedEntry\022\013\n\003k"
  "ey\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\032.\n\014UpdatedEn"
  "try\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\032.\n\014D"
  "eletedEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:"
  "\0028\001\"\250\001\n\005State\022\020\n\010previous\030\001 \001(\014\022\017\n\007curre"
  "nt\030\002 \001(\014\022(\n\ndifference\030\003 \001(\0132\024.p2p.State"
  "Difference\022$\n\005patch\030\004 \003(\0132\025.p2p.State.Pa"
  "tchEntry\032,\n\nPatchEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005v"
  "alue\030\002 \001(\t:\0028\001\"\205\001\n\010Proposal\022\023\n\013connectio"
  "ns\030\001 \003(\t\022\016\n\006inputs\030\002 \003(\t\022\017\n\007outputs\030\003 \003("
  "\t\022\r\n\005stage\030\004 \001(\005\022\014\n\004time\030\005 \001(\005\022\031\n\005state\030"
  "\006 \001(\0132\n.p2p.State\022\013\n\003lcl\030\007 \001(\014\" \n\003NPL\022\014\n"
  "\004data\030\001 \001(\014\022\013\n\003lcl\030\002 \001(\014\"\016\n\014StateRequest"
  "\"\017\n\rStateResponse\"\020\n\016HistoryRequest\"\021\n\017H"
  "istoryResponse"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_message_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_message_2eproto_sccs[13] = {
  &scc_info_HistoryRequest_message_2eproto.base,
  &scc_info_HistoryResponse_message_2eproto.base,
  &scc_info_Message_message_2eproto.base,
  &scc_info_NPL_message_2eproto.base,
  &scc_info_Proposal_message_2eproto.base,
  &scc_info_State_message_2eproto.base,
  &scc_info_State_PatchEntry_DoNotUse_message_2eproto.base,
  &scc_info_StateDifference_message_2eproto.base,
  &scc_info_StateDifference_CreatedEntry_DoNotUse_message_2eproto.base,
  &scc_info_StateDifference_DeletedEntry_DoNotUse_message_2eproto.base,
  &scc_info_StateDifference_UpdatedEntry_DoNotUse_message_2eproto.base,
  &scc_info_StateRequest_message_2eproto.base,
  &scc_info_StateResponse_message_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_message_2eproto_once;
static bool descriptor_table_message_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto = {
  &descriptor_table_message_2eproto_initialized, descriptor_table_protodef_message_2eproto, "message.proto", 1014,
  &descriptor_table_message_2eproto_once, descriptor_table_message_2eproto_sccs, descriptor_table_message_2eproto_deps, 13, 0,
  schemas, file_default_instances, TableStruct_message_2eproto::offsets,
  file_level_metadata_message_2eproto, 13, file_level_enum_descriptors_message_2eproto, file_level_service_descriptors_message_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_message_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_message_2eproto), true);
namespace p2p {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Message_Messagetype_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_message_2eproto);
  return file_level_enum_descriptors_message_2eproto[0];
}
bool Message_Messagetype_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Message_Messagetype Message::PROPOSAL;
constexpr Message_Messagetype Message::NPL;
constexpr Message_Messagetype Message::STATE_REQUEST;
constexpr Message_Messagetype Message::STATE_RESPONSE;
constexpr Message_Messagetype Message::HISTORY_REQUEST;
constexpr Message_Messagetype Message::HISTORY_RESPONSE;
constexpr Message_Messagetype Message::Messagetype_MIN;
constexpr Message_Messagetype Message::Messagetype_MAX;
constexpr int Message::Messagetype_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void Message::InitAsDefaultInstance() {
}
class Message::_Internal {
 public:
  using HasBits = decltype(std::declval<Message>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_content(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Message::Message()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Message)
}
Message::Message(const Message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_version()) {
    version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_publickey()) {
    publickey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.publickey_);
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_signature()) {
    signature_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_content()) {
    content_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.content_);
  }
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:p2p.Message)
}

void Message::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Message_message_2eproto.base);
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&timestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&timestamp_)) + sizeof(type_));
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:p2p.Message)
  SharedDtor();
}

void Message::SharedDtor() {
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  publickey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  content_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Message& Message::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Message_message_2eproto.base);
  return *internal_default_instance();
}


void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Message)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      version_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      publickey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      content_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(_internal_mutable_version(), ptr, ctx, "p2p.Message.version");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes publicKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_publickey(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes signature = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_signature(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .p2p.Message.Messagetype type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::p2p::Message_Messagetype_IsValid(val))) {
            _internal_set_type(static_cast<::p2p::Message_Messagetype>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bytes content = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_content(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Message::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Message)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2p.Message.version");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_version(), target);
  }

  // optional bytes publicKey = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_publickey(), target);
  }

  // optional int32 timestamp = 3;
  if (cached_has_bits & 0x00000010u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_timestamp(), target);
  }

  // optional bytes signature = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_signature(), target);
  }

  // optional .p2p.Message.Messagetype type = 5;
  if (cached_has_bits & 0x00000020u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_type(), target);
  }

  // optional bytes content = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_content(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Message)
  return target;
}

size_t Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Message)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional bytes publicKey = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_publickey());
    }

    // optional bytes signature = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional bytes content = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_content());
    }

    // optional int32 timestamp = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_timestamp());
    }

    // optional .p2p.Message.Messagetype type = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Message::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Message)
  GOOGLE_DCHECK_NE(&from, this);
  const Message* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Message>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Message)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Message)
    MergeFrom(*source);
  }
}

void Message::MergeFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Message)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      publickey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.publickey_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      signature_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      content_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.content_);
    }
    if (cached_has_bits & 0x00000010u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000020u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Message::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  return true;
}

void Message::InternalSwap(Message* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  version_.Swap(&other->version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  publickey_.Swap(&other->publickey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  signature_.Swap(&other->signature_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  content_.Swap(&other->content_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(timestamp_, other->timestamp_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Message::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

StateDifference_CreatedEntry_DoNotUse::StateDifference_CreatedEntry_DoNotUse() {}
StateDifference_CreatedEntry_DoNotUse::StateDifference_CreatedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void StateDifference_CreatedEntry_DoNotUse::MergeFrom(const StateDifference_CreatedEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata StateDifference_CreatedEntry_DoNotUse::GetMetadata() const {
  return GetMetadataStatic();
}
void StateDifference_CreatedEntry_DoNotUse::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& other) {
  ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom(other);
}


// ===================================================================

StateDifference_UpdatedEntry_DoNotUse::StateDifference_UpdatedEntry_DoNotUse() {}
StateDifference_UpdatedEntry_DoNotUse::StateDifference_UpdatedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void StateDifference_UpdatedEntry_DoNotUse::MergeFrom(const StateDifference_UpdatedEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata StateDifference_UpdatedEntry_DoNotUse::GetMetadata() const {
  return GetMetadataStatic();
}
void StateDifference_UpdatedEntry_DoNotUse::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& other) {
  ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom(other);
}


// ===================================================================

StateDifference_DeletedEntry_DoNotUse::StateDifference_DeletedEntry_DoNotUse() {}
StateDifference_DeletedEntry_DoNotUse::StateDifference_DeletedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void StateDifference_DeletedEntry_DoNotUse::MergeFrom(const StateDifference_DeletedEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata StateDifference_DeletedEntry_DoNotUse::GetMetadata() const {
  return GetMetadataStatic();
}
void StateDifference_DeletedEntry_DoNotUse::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& other) {
  ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom(other);
}


// ===================================================================

void StateDifference::InitAsDefaultInstance() {
}
class StateDifference::_Internal {
 public:
  using HasBits = decltype(std::declval<StateDifference>()._has_bits_);
};

StateDifference::StateDifference()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.StateDifference)
}
StateDifference::StateDifference(const StateDifference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  created_.MergeFrom(from.created_);
  updated_.MergeFrom(from.updated_);
  deleted_.MergeFrom(from.deleted_);
  // @@protoc_insertion_point(copy_constructor:p2p.StateDifference)
}

void StateDifference::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StateDifference_message_2eproto.base);
}

StateDifference::~StateDifference() {
  // @@protoc_insertion_point(destructor:p2p.StateDifference)
  SharedDtor();
}

void StateDifference::SharedDtor() {
}

void StateDifference::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StateDifference& StateDifference::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StateDifference_message_2eproto.base);
  return *internal_default_instance();
}


void StateDifference::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.StateDifference)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  created_.Clear();
  updated_.Clear();
  deleted_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* StateDifference::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // map<string, string> created = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&created_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // map<string, string> updated = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&updated_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // map<string, string> deleted = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&deleted_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StateDifference::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.StateDifference)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, string> created = 1;
  if (!this->_internal_created().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
          "p2p.StateDifference.CreatedEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
          "p2p.StateDifference.CreatedEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_created().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_created().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_created().begin();
          it != this->_internal_created().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = StateDifference_CreatedEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_created().begin();
          it != this->_internal_created().end(); ++it) {
        target = StateDifference_CreatedEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // map<string, string> updated = 2;
  if (!this->_internal_updated().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
          "p2p.StateDifference.UpdatedEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
          "p2p.StateDifference.UpdatedEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_updated().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_updated().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_updated().begin();
          it != this->_internal_updated().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = StateDifference_UpdatedEntry_DoNotUse::Funcs::InternalSerialize(2, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_updated().begin();
          it != this->_internal_updated().end(); ++it) {
        target = StateDifference_UpdatedEntry_DoNotUse::Funcs::InternalSerialize(2, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // map<string, string> deleted = 3;
  if (!this->_internal_deleted().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
          "p2p.StateDifference.DeletedEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
          "p2p.StateDifference.DeletedEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_deleted().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_deleted().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_deleted().begin();
          it != this->_internal_deleted().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = StateDifference_DeletedEntry_DoNotUse::Funcs::InternalSerialize(3, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_deleted().begin();
          it != this->_internal_deleted().end(); ++it) {
        target = StateDifference_DeletedEntry_DoNotUse::Funcs::InternalSerialize(3, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.StateDifference)
  return target;
}

size_t StateDifference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.StateDifference)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> created = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_created_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_created().begin();
      it != this->_internal_created().end(); ++it) {
    total_size += StateDifference_CreatedEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> updated = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_updated_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_updated().begin();
      it != this->_internal_updated().end(); ++it) {
    total_size += StateDifference_UpdatedEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> deleted = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_deleted_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_deleted().begin();
      it != this->_internal_deleted().end(); ++it) {
    total_size += StateDifference_DeletedEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StateDifference::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.StateDifference)
  GOOGLE_DCHECK_NE(&from, this);
  const StateDifference* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StateDifference>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.StateDifference)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.StateDifference)
    MergeFrom(*source);
  }
}

void StateDifference::MergeFrom(const StateDifference& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.StateDifference)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  created_.MergeFrom(from.created_);
  updated_.MergeFrom(from.updated_);
  deleted_.MergeFrom(from.deleted_);
}

void StateDifference::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.StateDifference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StateDifference::CopyFrom(const StateDifference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.StateDifference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StateDifference::IsInitialized() const {
  return true;
}

void StateDifference::InternalSwap(StateDifference* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  created_.Swap(&other->created_);
  updated_.Swap(&other->updated_);
  deleted_.Swap(&other->deleted_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StateDifference::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

State_PatchEntry_DoNotUse::State_PatchEntry_DoNotUse() {}
State_PatchEntry_DoNotUse::State_PatchEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void State_PatchEntry_DoNotUse::MergeFrom(const State_PatchEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata State_PatchEntry_DoNotUse::GetMetadata() const {
  return GetMetadataStatic();
}
void State_PatchEntry_DoNotUse::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& other) {
  ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom(other);
}


// ===================================================================

void State::InitAsDefaultInstance() {
  ::p2p::_State_default_instance_._instance.get_mutable()->difference_ = const_cast< ::p2p::StateDifference*>(
      ::p2p::StateDifference::internal_default_instance());
}
class State::_Internal {
 public:
  using HasBits = decltype(std::declval<State>()._has_bits_);
  static void set_has_previous(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_current(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::p2p::StateDifference& difference(const State* msg);
  static void set_has_difference(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::p2p::StateDifference&
State::_Internal::difference(const State* msg) {
  return *msg->difference_;
}
State::State()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.State)
}
State::State(const State& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  patch_.MergeFrom(from.patch_);
  previous_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_previous()) {
    previous_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.previous_);
  }
  current_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_current()) {
    current_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.current_);
  }
  if (from._internal_has_difference()) {
    difference_ = new ::p2p::StateDifference(*from.difference_);
  } else {
    difference_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:p2p.State)
}

void State::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_State_message_2eproto.base);
  previous_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  current_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  difference_ = nullptr;
}

State::~State() {
  // @@protoc_insertion_point(destructor:p2p.State)
  SharedDtor();
}

void State::SharedDtor() {
  previous_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  current_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete difference_;
}

void State::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const State& State::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_State_message_2eproto.base);
  return *internal_default_instance();
}


void State::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.State)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  patch_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      previous_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      current_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(difference_ != nullptr);
      difference_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* State::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes previous = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_previous(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes current = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_current(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .p2p.StateDifference difference = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_difference(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // map<string, string> patch = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&patch_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* State::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.State)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes previous = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_previous(), target);
  }

  // optional bytes current = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_current(), target);
  }

  // optional .p2p.StateDifference difference = 3;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::difference(this), target, stream);
  }

  // map<string, string> patch = 4;
  if (!this->_internal_patch().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
          "p2p.State.PatchEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
          "p2p.State.PatchEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_patch().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_patch().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_patch().begin();
          it != this->_internal_patch().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = State_PatchEntry_DoNotUse::Funcs::InternalSerialize(4, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_patch().begin();
          it != this->_internal_patch().end(); ++it) {
        target = State_PatchEntry_DoNotUse::Funcs::InternalSerialize(4, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.State)
  return target;
}

size_t State::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.State)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> patch = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_patch_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_patch().begin();
      it != this->_internal_patch().end(); ++it) {
    total_size += State_PatchEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes previous = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_previous());
    }

    // optional bytes current = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_current());
    }

    // optional .p2p.StateDifference difference = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *difference_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void State::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.State)
  GOOGLE_DCHECK_NE(&from, this);
  const State* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<State>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.State)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.State)
    MergeFrom(*source);
  }
}

void State::MergeFrom(const State& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.State)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  patch_.MergeFrom(from.patch_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      previous_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.previous_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      current_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.current_);
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_difference()->::p2p::StateDifference::MergeFrom(from._internal_difference());
    }
  }
}

void State::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void State::CopyFrom(const State& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool State::IsInitialized() const {
  return true;
}

void State::InternalSwap(State* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  patch_.Swap(&other->patch_);
  previous_.Swap(&other->previous_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  current_.Swap(&other->current_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(difference_, other->difference_);
}

::PROTOBUF_NAMESPACE_ID::Metadata State::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Proposal::InitAsDefaultInstance() {
  ::p2p::_Proposal_default_instance_._instance.get_mutable()->state_ = const_cast< ::p2p::State*>(
      ::p2p::State::internal_default_instance());
}
class Proposal::_Internal {
 public:
  using HasBits = decltype(std::declval<Proposal>()._has_bits_);
  static void set_has_stage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::p2p::State& state(const Proposal* msg);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lcl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::p2p::State&
Proposal::_Internal::state(const Proposal* msg) {
  return *msg->state_;
}
Proposal::Proposal()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Proposal)
}
Proposal::Proposal(const Proposal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      connections_(from.connections_),
      inputs_(from.inputs_),
      outputs_(from.outputs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  lcl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_lcl()) {
    lcl_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.lcl_);
  }
  if (from._internal_has_state()) {
    state_ = new ::p2p::State(*from.state_);
  } else {
    state_ = nullptr;
  }
  ::memcpy(&stage_, &from.stage_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_) -
    reinterpret_cast<char*>(&stage_)) + sizeof(time_));
  // @@protoc_insertion_point(copy_constructor:p2p.Proposal)
}

void Proposal::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Proposal_message_2eproto.base);
  lcl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_) -
      reinterpret_cast<char*>(&state_)) + sizeof(time_));
}

Proposal::~Proposal() {
  // @@protoc_insertion_point(destructor:p2p.Proposal)
  SharedDtor();
}

void Proposal::SharedDtor() {
  lcl_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete state_;
}

void Proposal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Proposal& Proposal::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Proposal_message_2eproto.base);
  return *internal_default_instance();
}


void Proposal::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Proposal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  connections_.Clear();
  inputs_.Clear();
  outputs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      lcl_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(state_ != nullptr);
      state_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&stage_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_) -
        reinterpret_cast<char*>(&stage_)) + sizeof(time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Proposal::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string connections = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(_internal_add_connections(), ptr, ctx, "p2p.Proposal.connections");
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string inputs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(_internal_add_inputs(), ptr, ctx, "p2p.Proposal.inputs");
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string outputs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(_internal_add_outputs(), ptr, ctx, "p2p.Proposal.outputs");
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional int32 stage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_stage(&has_bits);
          stage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_time(&has_bits);
          time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .p2p.State state = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes lcl = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_lcl(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Proposal::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Proposal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string connections = 1;
  for (int i = 0, n = this->_internal_connections_size(); i < n; i++) {
    const auto& s = this->_internal_connections(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2p.Proposal.connections");
    target = stream->WriteString(1, s, target);
  }

  // repeated string inputs = 2;
  for (int i = 0, n = this->_internal_inputs_size(); i < n; i++) {
    const auto& s = this->_internal_inputs(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2p.Proposal.inputs");
    target = stream->WriteString(2, s, target);
  }

  // repeated string outputs = 3;
  for (int i = 0, n = this->_internal_outputs_size(); i < n; i++) {
    const auto& s = this->_internal_outputs(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2p.Proposal.outputs");
    target = stream->WriteString(3, s, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 stage = 4;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_stage(), target);
  }

  // optional int32 time = 5;
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_time(), target);
  }

  // optional .p2p.State state = 6;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::state(this), target, stream);
  }

  // optional bytes lcl = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_lcl(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Proposal)
  return target;
}

size_t Proposal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Proposal)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string connections = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(connections_.size());
  for (int i = 0, n = connections_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      connections_.Get(i));
  }

  // repeated string inputs = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(inputs_.size());
  for (int i = 0, n = inputs_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      inputs_.Get(i));
  }

  // repeated string outputs = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(outputs_.size());
  for (int i = 0, n = outputs_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      outputs_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes lcl = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_lcl());
    }

    // optional .p2p.State state = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *state_);
    }

    // optional int32 stage = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_stage());
    }

    // optional int32 time = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_time());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Proposal::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Proposal)
  GOOGLE_DCHECK_NE(&from, this);
  const Proposal* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Proposal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Proposal)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Proposal)
    MergeFrom(*source);
  }
}

void Proposal::MergeFrom(const Proposal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Proposal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  connections_.MergeFrom(from.connections_);
  inputs_.MergeFrom(from.inputs_);
  outputs_.MergeFrom(from.outputs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      lcl_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.lcl_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_state()->::p2p::State::MergeFrom(from._internal_state());
    }
    if (cached_has_bits & 0x00000004u) {
      stage_ = from.stage_;
    }
    if (cached_has_bits & 0x00000008u) {
      time_ = from.time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Proposal::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Proposal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Proposal::CopyFrom(const Proposal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Proposal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proposal::IsInitialized() const {
  return true;
}

void Proposal::InternalSwap(Proposal* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  connections_.InternalSwap(&other->connections_);
  inputs_.InternalSwap(&other->inputs_);
  outputs_.InternalSwap(&other->outputs_);
  lcl_.Swap(&other->lcl_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(state_, other->state_);
  swap(stage_, other->stage_);
  swap(time_, other->time_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Proposal::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void NPL::InitAsDefaultInstance() {
}
class NPL::_Internal {
 public:
  using HasBits = decltype(std::declval<NPL>()._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lcl(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NPL::NPL()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.NPL)
}
NPL::NPL(const NPL& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data()) {
    data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
  lcl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_lcl()) {
    lcl_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.lcl_);
  }
  // @@protoc_insertion_point(copy_constructor:p2p.NPL)
}

void NPL::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_NPL_message_2eproto.base);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  lcl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

NPL::~NPL() {
  // @@protoc_insertion_point(destructor:p2p.NPL)
  SharedDtor();
}

void NPL::SharedDtor() {
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  lcl_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NPL::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NPL& NPL::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_NPL_message_2eproto.base);
  return *internal_default_instance();
}


void NPL::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.NPL)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      data_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      lcl_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* NPL::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes lcl = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_lcl(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* NPL::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.NPL)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  // optional bytes lcl = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_lcl(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.NPL)
  return target;
}

size_t NPL::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.NPL)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional bytes lcl = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_lcl());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NPL::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.NPL)
  GOOGLE_DCHECK_NE(&from, this);
  const NPL* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<NPL>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.NPL)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.NPL)
    MergeFrom(*source);
  }
}

void NPL::MergeFrom(const NPL& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.NPL)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      lcl_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.lcl_);
    }
  }
}

void NPL::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.NPL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NPL::CopyFrom(const NPL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.NPL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NPL::IsInitialized() const {
  return true;
}

void NPL::InternalSwap(NPL* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  lcl_.Swap(&other->lcl_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata NPL::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StateRequest::InitAsDefaultInstance() {
}
class StateRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<StateRequest>()._has_bits_);
};

StateRequest::StateRequest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.StateRequest)
}
StateRequest::StateRequest(const StateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2p.StateRequest)
}

void StateRequest::SharedCtor() {
}

StateRequest::~StateRequest() {
  // @@protoc_insertion_point(destructor:p2p.StateRequest)
  SharedDtor();
}

void StateRequest::SharedDtor() {
}

void StateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StateRequest& StateRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StateRequest_message_2eproto.base);
  return *internal_default_instance();
}


void StateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.StateRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* StateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StateRequest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.StateRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.StateRequest)
  return target;
}

size_t StateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.StateRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StateRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.StateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const StateRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StateRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.StateRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.StateRequest)
    MergeFrom(*source);
  }
}

void StateRequest::MergeFrom(const StateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.StateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void StateRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.StateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StateRequest::CopyFrom(const StateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.StateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StateRequest::IsInitialized() const {
  return true;
}

void StateRequest::InternalSwap(StateRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StateRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StateResponse::InitAsDefaultInstance() {
}
class StateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<StateResponse>()._has_bits_);
};

StateResponse::StateResponse()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.StateResponse)
}
StateResponse::StateResponse(const StateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2p.StateResponse)
}

void StateResponse::SharedCtor() {
}

StateResponse::~StateResponse() {
  // @@protoc_insertion_point(destructor:p2p.StateResponse)
  SharedDtor();
}

void StateResponse::SharedDtor() {
}

void StateResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StateResponse& StateResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StateResponse_message_2eproto.base);
  return *internal_default_instance();
}


void StateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.StateResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* StateResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StateResponse::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.StateResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.StateResponse)
  return target;
}

size_t StateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.StateResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StateResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.StateResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const StateResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StateResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.StateResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.StateResponse)
    MergeFrom(*source);
  }
}

void StateResponse::MergeFrom(const StateResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.StateResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void StateResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.StateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StateResponse::CopyFrom(const StateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.StateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StateResponse::IsInitialized() const {
  return true;
}

void StateResponse::InternalSwap(StateResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StateResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void HistoryRequest::InitAsDefaultInstance() {
}
class HistoryRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<HistoryRequest>()._has_bits_);
};

HistoryRequest::HistoryRequest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.HistoryRequest)
}
HistoryRequest::HistoryRequest(const HistoryRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2p.HistoryRequest)
}

void HistoryRequest::SharedCtor() {
}

HistoryRequest::~HistoryRequest() {
  // @@protoc_insertion_point(destructor:p2p.HistoryRequest)
  SharedDtor();
}

void HistoryRequest::SharedDtor() {
}

void HistoryRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HistoryRequest& HistoryRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_HistoryRequest_message_2eproto.base);
  return *internal_default_instance();
}


void HistoryRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.HistoryRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* HistoryRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* HistoryRequest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.HistoryRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.HistoryRequest)
  return target;
}

size_t HistoryRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.HistoryRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HistoryRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.HistoryRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const HistoryRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<HistoryRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.HistoryRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.HistoryRequest)
    MergeFrom(*source);
  }
}

void HistoryRequest::MergeFrom(const HistoryRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.HistoryRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void HistoryRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.HistoryRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HistoryRequest::CopyFrom(const HistoryRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.HistoryRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HistoryRequest::IsInitialized() const {
  return true;
}

void HistoryRequest::InternalSwap(HistoryRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata HistoryRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void HistoryResponse::InitAsDefaultInstance() {
}
class HistoryResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<HistoryResponse>()._has_bits_);
};

HistoryResponse::HistoryResponse()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.HistoryResponse)
}
HistoryResponse::HistoryResponse(const HistoryResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2p.HistoryResponse)
}

void HistoryResponse::SharedCtor() {
}

HistoryResponse::~HistoryResponse() {
  // @@protoc_insertion_point(destructor:p2p.HistoryResponse)
  SharedDtor();
}

void HistoryResponse::SharedDtor() {
}

void HistoryResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HistoryResponse& HistoryResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_HistoryResponse_message_2eproto.base);
  return *internal_default_instance();
}


void HistoryResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.HistoryResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* HistoryResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* HistoryResponse::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.HistoryResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.HistoryResponse)
  return target;
}

size_t HistoryResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.HistoryResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HistoryResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.HistoryResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const HistoryResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<HistoryResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.HistoryResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.HistoryResponse)
    MergeFrom(*source);
  }
}

void HistoryResponse::MergeFrom(const HistoryResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.HistoryResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void HistoryResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.HistoryResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HistoryResponse::CopyFrom(const HistoryResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.HistoryResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HistoryResponse::IsInitialized() const {
  return true;
}

void HistoryResponse::InternalSwap(HistoryResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata HistoryResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace p2p
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::p2p::Message* Arena::CreateMaybeMessage< ::p2p::Message >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::Message >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::StateDifference_CreatedEntry_DoNotUse* Arena::CreateMaybeMessage< ::p2p::StateDifference_CreatedEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::StateDifference_CreatedEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::StateDifference_UpdatedEntry_DoNotUse* Arena::CreateMaybeMessage< ::p2p::StateDifference_UpdatedEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::StateDifference_UpdatedEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::StateDifference_DeletedEntry_DoNotUse* Arena::CreateMaybeMessage< ::p2p::StateDifference_DeletedEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::StateDifference_DeletedEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::StateDifference* Arena::CreateMaybeMessage< ::p2p::StateDifference >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::StateDifference >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::State_PatchEntry_DoNotUse* Arena::CreateMaybeMessage< ::p2p::State_PatchEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::State_PatchEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::State* Arena::CreateMaybeMessage< ::p2p::State >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::State >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::Proposal* Arena::CreateMaybeMessage< ::p2p::Proposal >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::Proposal >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::NPL* Arena::CreateMaybeMessage< ::p2p::NPL >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::NPL >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::StateRequest* Arena::CreateMaybeMessage< ::p2p::StateRequest >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::StateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::StateResponse* Arena::CreateMaybeMessage< ::p2p::StateResponse >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::StateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::HistoryRequest* Arena::CreateMaybeMessage< ::p2p::HistoryRequest >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::HistoryRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2p::HistoryResponse* Arena::CreateMaybeMessage< ::p2p::HistoryResponse >(Arena* arena) {
  return Arena::CreateInternal< ::p2p::HistoryResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
