// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FULLHISTORYSCHEMA_MSG_FBUF_LEDGER_H_
#define FLATBUFFERS_GENERATED_FULLHISTORYSCHEMA_MSG_FBUF_LEDGER_H_

#include "flatbuffers/flatbuffers.h"

namespace msg {
namespace fbuf {
namespace ledger {

struct FullHistoryBlock;
struct FullHistoryBlockBuilder;

struct RawInput;
struct RawInputBuilder;

struct FullHistoryBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FullHistoryBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RAW_INPUTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>> *raw_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>> *>(VT_RAW_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>> *mutable_raw_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>> *>(VT_RAW_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RAW_INPUTS) &&
           verifier.VerifyVector(raw_inputs()) &&
           verifier.VerifyVectorOfTables(raw_inputs()) &&
           verifier.EndTable();
  }
};

struct FullHistoryBlockBuilder {
  typedef FullHistoryBlock Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_raw_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>>> raw_inputs) {
    fbb_.AddOffset(FullHistoryBlock::VT_RAW_INPUTS, raw_inputs);
  }
  explicit FullHistoryBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FullHistoryBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullHistoryBlock>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullHistoryBlock> CreateFullHistoryBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>>> raw_inputs = 0) {
  FullHistoryBlockBuilder builder_(_fbb);
  builder_.add_raw_inputs(raw_inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<FullHistoryBlock> CreateFullHistoryBlockDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>> *raw_inputs = nullptr) {
  auto raw_inputs__ = raw_inputs ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>>(*raw_inputs) : 0;
  return msg::fbuf::ledger::CreateFullHistoryBlock(
      _fbb,
      raw_inputs__);
}

struct RawInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RawInputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH = 4,
    VT_PUBKEY = 6,
    VT_INPUT_CONTAINER = 8,
    VT_SIG = 10,
    VT_PROTOCOL = 12
  };
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const flatbuffers::Vector<uint8_t> *input_container() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INPUT_CONTAINER);
  }
  flatbuffers::Vector<uint8_t> *mutable_input_container() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_INPUT_CONTAINER);
  }
  const flatbuffers::Vector<uint8_t> *sig() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  flatbuffers::Vector<uint8_t> *mutable_sig() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  uint8_t protocol() const {
    return GetField<uint8_t>(VT_PROTOCOL, 0);
  }
  bool mutate_protocol(uint8_t _protocol) {
    return SetField<uint8_t>(VT_PROTOCOL, _protocol, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyVector(hash()) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_INPUT_CONTAINER) &&
           verifier.VerifyVector(input_container()) &&
           VerifyOffset(verifier, VT_SIG) &&
           verifier.VerifyVector(sig()) &&
           VerifyField<uint8_t>(verifier, VT_PROTOCOL) &&
           verifier.EndTable();
  }
};

struct RawInputBuilder {
  typedef RawInput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(RawInput::VT_HASH, hash);
  }
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(RawInput::VT_PUBKEY, pubkey);
  }
  void add_input_container(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_container) {
    fbb_.AddOffset(RawInput::VT_INPUT_CONTAINER, input_container);
  }
  void add_sig(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig) {
    fbb_.AddOffset(RawInput::VT_SIG, sig);
  }
  void add_protocol(uint8_t protocol) {
    fbb_.AddElement<uint8_t>(RawInput::VT_PROTOCOL, protocol, 0);
  }
  explicit RawInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RawInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RawInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<RawInput> CreateRawInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_container = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig = 0,
    uint8_t protocol = 0) {
  RawInputBuilder builder_(_fbb);
  builder_.add_sig(sig);
  builder_.add_input_container(input_container);
  builder_.add_pubkey(pubkey);
  builder_.add_hash(hash);
  builder_.add_protocol(protocol);
  return builder_.Finish();
}

inline flatbuffers::Offset<RawInput> CreateRawInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *hash = nullptr,
    const std::vector<uint8_t> *pubkey = nullptr,
    const std::vector<uint8_t> *input_container = nullptr,
    const std::vector<uint8_t> *sig = nullptr,
    uint8_t protocol = 0) {
  auto hash__ = hash ? _fbb.CreateVector<uint8_t>(*hash) : 0;
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto input_container__ = input_container ? _fbb.CreateVector<uint8_t>(*input_container) : 0;
  auto sig__ = sig ? _fbb.CreateVector<uint8_t>(*sig) : 0;
  return msg::fbuf::ledger::CreateRawInput(
      _fbb,
      hash__,
      pubkey__,
      input_container__,
      sig__,
      protocol);
}

inline const msg::fbuf::ledger::FullHistoryBlock *GetFullHistoryBlock(const void *buf) {
  return flatbuffers::GetRoot<msg::fbuf::ledger::FullHistoryBlock>(buf);
}

inline const msg::fbuf::ledger::FullHistoryBlock *GetSizePrefixedFullHistoryBlock(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<msg::fbuf::ledger::FullHistoryBlock>(buf);
}

inline FullHistoryBlock *GetMutableFullHistoryBlock(void *buf) {
  return flatbuffers::GetMutableRoot<FullHistoryBlock>(buf);
}

inline bool VerifyFullHistoryBlockBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<msg::fbuf::ledger::FullHistoryBlock>(nullptr);
}

inline bool VerifySizePrefixedFullHistoryBlockBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<msg::fbuf::ledger::FullHistoryBlock>(nullptr);
}

inline void FinishFullHistoryBlockBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<msg::fbuf::ledger::FullHistoryBlock> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFullHistoryBlockBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<msg::fbuf::ledger::FullHistoryBlock> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace ledger
}  // namespace fbuf
}  // namespace msg

#endif  // FLATBUFFERS_GENERATED_FULLHISTORYSCHEMA_MSG_FBUF_LEDGER_H_
