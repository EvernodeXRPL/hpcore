// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_P2PMSG_MSG_FBUF_P2PMSG_H_
#define FLATBUFFERS_GENERATED_P2PMSG_MSG_FBUF_P2PMSG_H_

#include "flatbuffers/flatbuffers.h"

namespace msg {
namespace fbuf {
namespace p2pmsg {

struct P2PMsg;
struct P2PMsgBuilder;

struct PeerChallengeMsg;
struct PeerChallengeMsgBuilder;

struct PeerChallengeResponseMsg;
struct PeerChallengeResponseMsgBuilder;

struct UserInput;
struct UserInputBuilder;

struct UserInputGroup;
struct UserInputGroupBuilder;

struct NonUnlProposalMsg;
struct NonUnlProposalMsgBuilder;

struct ProposalMsg;
struct ProposalMsgBuilder;

struct NplMsg;
struct NplMsgBuilder;

struct HpfsRequestMsg;
struct HpfsRequestMsgBuilder;

struct HpfsResponseMsg;
struct HpfsResponseMsgBuilder;

struct HpfsFsEntryResponse;
struct HpfsFsEntryResponseBuilder;

struct HpfsFileHashMapResponse;
struct HpfsFileHashMapResponseBuilder;

struct HpfsBlockResponse;
struct HpfsBlockResponseBuilder;

struct HpfsFSHashEntry;
struct HpfsFSHashEntryBuilder;

struct HpfsLogRequest;
struct HpfsLogRequestBuilder;

struct HpfsLogResponse;
struct HpfsLogResponseBuilder;

struct PeerRequirementAnnouncementMsg;
struct PeerRequirementAnnouncementMsgBuilder;

struct PeerCapacityAnnouncementMsg;
struct PeerCapacityAnnouncementMsgBuilder;

struct PeerListRequestMsg;
struct PeerListRequestMsgBuilder;

struct PeerListResponseMsg;
struct PeerListResponseMsgBuilder;

struct PeerProperties;
struct PeerPropertiesBuilder;

struct SequenceHash;
struct SequenceHashBuilder;

struct ByteArray;
struct ByteArrayBuilder;

enum P2PMsgContent {
  P2PMsgContent_NONE = 0,
  P2PMsgContent_PeerChallengeMsg = 1,
  P2PMsgContent_PeerChallengeResponseMsg = 2,
  P2PMsgContent_NonUnlProposalMsg = 3,
  P2PMsgContent_ProposalMsg = 4,
  P2PMsgContent_NplMsg = 5,
  P2PMsgContent_HpfsRequestMsg = 6,
  P2PMsgContent_HpfsResponseMsg = 7,
  P2PMsgContent_PeerRequirementAnnouncementMsg = 8,
  P2PMsgContent_PeerCapacityAnnouncementMsg = 9,
  P2PMsgContent_PeerListRequestMsg = 10,
  P2PMsgContent_PeerListResponseMsg = 11,
  P2PMsgContent_HpfsLogRequest = 12,
  P2PMsgContent_HpfsLogResponse = 13,
  P2PMsgContent_MIN = P2PMsgContent_NONE,
  P2PMsgContent_MAX = P2PMsgContent_HpfsLogResponse
};

inline const P2PMsgContent (&EnumValuesP2PMsgContent())[14] {
  static const P2PMsgContent values[] = {
    P2PMsgContent_NONE,
    P2PMsgContent_PeerChallengeMsg,
    P2PMsgContent_PeerChallengeResponseMsg,
    P2PMsgContent_NonUnlProposalMsg,
    P2PMsgContent_ProposalMsg,
    P2PMsgContent_NplMsg,
    P2PMsgContent_HpfsRequestMsg,
    P2PMsgContent_HpfsResponseMsg,
    P2PMsgContent_PeerRequirementAnnouncementMsg,
    P2PMsgContent_PeerCapacityAnnouncementMsg,
    P2PMsgContent_PeerListRequestMsg,
    P2PMsgContent_PeerListResponseMsg,
    P2PMsgContent_HpfsLogRequest,
    P2PMsgContent_HpfsLogResponse
  };
  return values;
}

inline const char * const *EnumNamesP2PMsgContent() {
  static const char * const names[15] = {
    "NONE",
    "PeerChallengeMsg",
    "PeerChallengeResponseMsg",
    "NonUnlProposalMsg",
    "ProposalMsg",
    "NplMsg",
    "HpfsRequestMsg",
    "HpfsResponseMsg",
    "PeerRequirementAnnouncementMsg",
    "PeerCapacityAnnouncementMsg",
    "PeerListRequestMsg",
    "PeerListResponseMsg",
    "HpfsLogRequest",
    "HpfsLogResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameP2PMsgContent(P2PMsgContent e) {
  if (flatbuffers::IsOutRange(e, P2PMsgContent_NONE, P2PMsgContent_HpfsLogResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesP2PMsgContent()[index];
}

template<typename T> struct P2PMsgContentTraits {
  static const P2PMsgContent enum_value = P2PMsgContent_NONE;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::PeerChallengeMsg> {
  static const P2PMsgContent enum_value = P2PMsgContent_PeerChallengeMsg;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::PeerChallengeResponseMsg> {
  static const P2PMsgContent enum_value = P2PMsgContent_PeerChallengeResponseMsg;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::NonUnlProposalMsg> {
  static const P2PMsgContent enum_value = P2PMsgContent_NonUnlProposalMsg;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::ProposalMsg> {
  static const P2PMsgContent enum_value = P2PMsgContent_ProposalMsg;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::NplMsg> {
  static const P2PMsgContent enum_value = P2PMsgContent_NplMsg;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::HpfsRequestMsg> {
  static const P2PMsgContent enum_value = P2PMsgContent_HpfsRequestMsg;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::HpfsResponseMsg> {
  static const P2PMsgContent enum_value = P2PMsgContent_HpfsResponseMsg;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::PeerRequirementAnnouncementMsg> {
  static const P2PMsgContent enum_value = P2PMsgContent_PeerRequirementAnnouncementMsg;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::PeerCapacityAnnouncementMsg> {
  static const P2PMsgContent enum_value = P2PMsgContent_PeerCapacityAnnouncementMsg;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::PeerListRequestMsg> {
  static const P2PMsgContent enum_value = P2PMsgContent_PeerListRequestMsg;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::PeerListResponseMsg> {
  static const P2PMsgContent enum_value = P2PMsgContent_PeerListResponseMsg;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::HpfsLogRequest> {
  static const P2PMsgContent enum_value = P2PMsgContent_HpfsLogRequest;
};

template<> struct P2PMsgContentTraits<msg::fbuf::p2pmsg::HpfsLogResponse> {
  static const P2PMsgContent enum_value = P2PMsgContent_HpfsLogResponse;
};

bool VerifyP2PMsgContent(flatbuffers::Verifier &verifier, const void *obj, P2PMsgContent type);
bool VerifyP2PMsgContentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum HpfsResponse {
  HpfsResponse_NONE = 0,
  HpfsResponse_HpfsFileHashMapResponse = 1,
  HpfsResponse_HpfsBlockResponse = 2,
  HpfsResponse_HpfsFsEntryResponse = 3,
  HpfsResponse_MIN = HpfsResponse_NONE,
  HpfsResponse_MAX = HpfsResponse_HpfsFsEntryResponse
};

inline const HpfsResponse (&EnumValuesHpfsResponse())[4] {
  static const HpfsResponse values[] = {
    HpfsResponse_NONE,
    HpfsResponse_HpfsFileHashMapResponse,
    HpfsResponse_HpfsBlockResponse,
    HpfsResponse_HpfsFsEntryResponse
  };
  return values;
}

inline const char * const *EnumNamesHpfsResponse() {
  static const char * const names[5] = {
    "NONE",
    "HpfsFileHashMapResponse",
    "HpfsBlockResponse",
    "HpfsFsEntryResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameHpfsResponse(HpfsResponse e) {
  if (flatbuffers::IsOutRange(e, HpfsResponse_NONE, HpfsResponse_HpfsFsEntryResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHpfsResponse()[index];
}

template<typename T> struct HpfsResponseTraits {
  static const HpfsResponse enum_value = HpfsResponse_NONE;
};

template<> struct HpfsResponseTraits<msg::fbuf::p2pmsg::HpfsFileHashMapResponse> {
  static const HpfsResponse enum_value = HpfsResponse_HpfsFileHashMapResponse;
};

template<> struct HpfsResponseTraits<msg::fbuf::p2pmsg::HpfsBlockResponse> {
  static const HpfsResponse enum_value = HpfsResponse_HpfsBlockResponse;
};

template<> struct HpfsResponseTraits<msg::fbuf::p2pmsg::HpfsFsEntryResponse> {
  static const HpfsResponse enum_value = HpfsResponse_HpfsFsEntryResponse;
};

bool VerifyHpfsResponse(flatbuffers::Verifier &verifier, const void *obj, HpfsResponse type);
bool VerifyHpfsResponseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct P2PMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef P2PMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HP_VERSION = 4,
    VT_CREATED_ON = 6,
    VT_CONTENT_TYPE = 8,
    VT_CONTENT = 10
  };
  const flatbuffers::Vector<uint8_t> *hp_version() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HP_VERSION);
  }
  flatbuffers::Vector<uint8_t> *mutable_hp_version() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HP_VERSION);
  }
  uint64_t created_on() const {
    return GetField<uint64_t>(VT_CREATED_ON, 0);
  }
  bool mutate_created_on(uint64_t _created_on) {
    return SetField<uint64_t>(VT_CREATED_ON, _created_on, 0);
  }
  msg::fbuf::p2pmsg::P2PMsgContent content_type() const {
    return static_cast<msg::fbuf::p2pmsg::P2PMsgContent>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const msg::fbuf::p2pmsg::PeerChallengeMsg *content_as_PeerChallengeMsg() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_PeerChallengeMsg ? static_cast<const msg::fbuf::p2pmsg::PeerChallengeMsg *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::PeerChallengeResponseMsg *content_as_PeerChallengeResponseMsg() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_PeerChallengeResponseMsg ? static_cast<const msg::fbuf::p2pmsg::PeerChallengeResponseMsg *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::NonUnlProposalMsg *content_as_NonUnlProposalMsg() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_NonUnlProposalMsg ? static_cast<const msg::fbuf::p2pmsg::NonUnlProposalMsg *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::ProposalMsg *content_as_ProposalMsg() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_ProposalMsg ? static_cast<const msg::fbuf::p2pmsg::ProposalMsg *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::NplMsg *content_as_NplMsg() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_NplMsg ? static_cast<const msg::fbuf::p2pmsg::NplMsg *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::HpfsRequestMsg *content_as_HpfsRequestMsg() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_HpfsRequestMsg ? static_cast<const msg::fbuf::p2pmsg::HpfsRequestMsg *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::HpfsResponseMsg *content_as_HpfsResponseMsg() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_HpfsResponseMsg ? static_cast<const msg::fbuf::p2pmsg::HpfsResponseMsg *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::PeerRequirementAnnouncementMsg *content_as_PeerRequirementAnnouncementMsg() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_PeerRequirementAnnouncementMsg ? static_cast<const msg::fbuf::p2pmsg::PeerRequirementAnnouncementMsg *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::PeerCapacityAnnouncementMsg *content_as_PeerCapacityAnnouncementMsg() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_PeerCapacityAnnouncementMsg ? static_cast<const msg::fbuf::p2pmsg::PeerCapacityAnnouncementMsg *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::PeerListRequestMsg *content_as_PeerListRequestMsg() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_PeerListRequestMsg ? static_cast<const msg::fbuf::p2pmsg::PeerListRequestMsg *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::PeerListResponseMsg *content_as_PeerListResponseMsg() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_PeerListResponseMsg ? static_cast<const msg::fbuf::p2pmsg::PeerListResponseMsg *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::HpfsLogRequest *content_as_HpfsLogRequest() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_HpfsLogRequest ? static_cast<const msg::fbuf::p2pmsg::HpfsLogRequest *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::HpfsLogResponse *content_as_HpfsLogResponse() const {
    return content_type() == msg::fbuf::p2pmsg::P2PMsgContent_HpfsLogResponse ? static_cast<const msg::fbuf::p2pmsg::HpfsLogResponse *>(content()) : nullptr;
  }
  void *mutable_content() {
    return GetPointer<void *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HP_VERSION) &&
           verifier.VerifyVector(hp_version()) &&
           VerifyField<uint64_t>(verifier, VT_CREATED_ON) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyP2PMsgContent(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const msg::fbuf::p2pmsg::PeerChallengeMsg *P2PMsg::content_as<msg::fbuf::p2pmsg::PeerChallengeMsg>() const {
  return content_as_PeerChallengeMsg();
}

template<> inline const msg::fbuf::p2pmsg::PeerChallengeResponseMsg *P2PMsg::content_as<msg::fbuf::p2pmsg::PeerChallengeResponseMsg>() const {
  return content_as_PeerChallengeResponseMsg();
}

template<> inline const msg::fbuf::p2pmsg::NonUnlProposalMsg *P2PMsg::content_as<msg::fbuf::p2pmsg::NonUnlProposalMsg>() const {
  return content_as_NonUnlProposalMsg();
}

template<> inline const msg::fbuf::p2pmsg::ProposalMsg *P2PMsg::content_as<msg::fbuf::p2pmsg::ProposalMsg>() const {
  return content_as_ProposalMsg();
}

template<> inline const msg::fbuf::p2pmsg::NplMsg *P2PMsg::content_as<msg::fbuf::p2pmsg::NplMsg>() const {
  return content_as_NplMsg();
}

template<> inline const msg::fbuf::p2pmsg::HpfsRequestMsg *P2PMsg::content_as<msg::fbuf::p2pmsg::HpfsRequestMsg>() const {
  return content_as_HpfsRequestMsg();
}

template<> inline const msg::fbuf::p2pmsg::HpfsResponseMsg *P2PMsg::content_as<msg::fbuf::p2pmsg::HpfsResponseMsg>() const {
  return content_as_HpfsResponseMsg();
}

template<> inline const msg::fbuf::p2pmsg::PeerRequirementAnnouncementMsg *P2PMsg::content_as<msg::fbuf::p2pmsg::PeerRequirementAnnouncementMsg>() const {
  return content_as_PeerRequirementAnnouncementMsg();
}

template<> inline const msg::fbuf::p2pmsg::PeerCapacityAnnouncementMsg *P2PMsg::content_as<msg::fbuf::p2pmsg::PeerCapacityAnnouncementMsg>() const {
  return content_as_PeerCapacityAnnouncementMsg();
}

template<> inline const msg::fbuf::p2pmsg::PeerListRequestMsg *P2PMsg::content_as<msg::fbuf::p2pmsg::PeerListRequestMsg>() const {
  return content_as_PeerListRequestMsg();
}

template<> inline const msg::fbuf::p2pmsg::PeerListResponseMsg *P2PMsg::content_as<msg::fbuf::p2pmsg::PeerListResponseMsg>() const {
  return content_as_PeerListResponseMsg();
}

template<> inline const msg::fbuf::p2pmsg::HpfsLogRequest *P2PMsg::content_as<msg::fbuf::p2pmsg::HpfsLogRequest>() const {
  return content_as_HpfsLogRequest();
}

template<> inline const msg::fbuf::p2pmsg::HpfsLogResponse *P2PMsg::content_as<msg::fbuf::p2pmsg::HpfsLogResponse>() const {
  return content_as_HpfsLogResponse();
}

struct P2PMsgBuilder {
  typedef P2PMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hp_version(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hp_version) {
    fbb_.AddOffset(P2PMsg::VT_HP_VERSION, hp_version);
  }
  void add_created_on(uint64_t created_on) {
    fbb_.AddElement<uint64_t>(P2PMsg::VT_CREATED_ON, created_on, 0);
  }
  void add_content_type(msg::fbuf::p2pmsg::P2PMsgContent content_type) {
    fbb_.AddElement<uint8_t>(P2PMsg::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(flatbuffers::Offset<void> content) {
    fbb_.AddOffset(P2PMsg::VT_CONTENT, content);
  }
  explicit P2PMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  P2PMsgBuilder &operator=(const P2PMsgBuilder &);
  flatbuffers::Offset<P2PMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<P2PMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<P2PMsg> CreateP2PMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hp_version = 0,
    uint64_t created_on = 0,
    msg::fbuf::p2pmsg::P2PMsgContent content_type = msg::fbuf::p2pmsg::P2PMsgContent_NONE,
    flatbuffers::Offset<void> content = 0) {
  P2PMsgBuilder builder_(_fbb);
  builder_.add_created_on(created_on);
  builder_.add_content(content);
  builder_.add_hp_version(hp_version);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<P2PMsg> CreateP2PMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *hp_version = nullptr,
    uint64_t created_on = 0,
    msg::fbuf::p2pmsg::P2PMsgContent content_type = msg::fbuf::p2pmsg::P2PMsgContent_NONE,
    flatbuffers::Offset<void> content = 0) {
  auto hp_version__ = hp_version ? _fbb.CreateVector<uint8_t>(*hp_version) : 0;
  return msg::fbuf::p2pmsg::CreateP2PMsg(
      _fbb,
      hp_version__,
      created_on,
      content_type,
      content);
}

struct PeerChallengeMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PeerChallengeMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTRACT_ID = 4,
    VT_ROUNDTIME = 6,
    VT_IS_FULL_HISTORY = 8,
    VT_CHALLENGE = 10
  };
  const flatbuffers::String *contract_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTRACT_ID);
  }
  flatbuffers::String *mutable_contract_id() {
    return GetPointer<flatbuffers::String *>(VT_CONTRACT_ID);
  }
  uint32_t roundtime() const {
    return GetField<uint32_t>(VT_ROUNDTIME, 0);
  }
  bool mutate_roundtime(uint32_t _roundtime) {
    return SetField<uint32_t>(VT_ROUNDTIME, _roundtime, 0);
  }
  bool is_full_history() const {
    return GetField<uint8_t>(VT_IS_FULL_HISTORY, 0) != 0;
  }
  bool mutate_is_full_history(bool _is_full_history) {
    return SetField<uint8_t>(VT_IS_FULL_HISTORY, static_cast<uint8_t>(_is_full_history), 0);
  }
  const flatbuffers::Vector<uint8_t> *challenge() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CHALLENGE);
  }
  flatbuffers::Vector<uint8_t> *mutable_challenge() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CHALLENGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTRACT_ID) &&
           verifier.VerifyString(contract_id()) &&
           VerifyField<uint32_t>(verifier, VT_ROUNDTIME) &&
           VerifyField<uint8_t>(verifier, VT_IS_FULL_HISTORY) &&
           VerifyOffset(verifier, VT_CHALLENGE) &&
           verifier.VerifyVector(challenge()) &&
           verifier.EndTable();
  }
};

struct PeerChallengeMsgBuilder {
  typedef PeerChallengeMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contract_id(flatbuffers::Offset<flatbuffers::String> contract_id) {
    fbb_.AddOffset(PeerChallengeMsg::VT_CONTRACT_ID, contract_id);
  }
  void add_roundtime(uint32_t roundtime) {
    fbb_.AddElement<uint32_t>(PeerChallengeMsg::VT_ROUNDTIME, roundtime, 0);
  }
  void add_is_full_history(bool is_full_history) {
    fbb_.AddElement<uint8_t>(PeerChallengeMsg::VT_IS_FULL_HISTORY, static_cast<uint8_t>(is_full_history), 0);
  }
  void add_challenge(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> challenge) {
    fbb_.AddOffset(PeerChallengeMsg::VT_CHALLENGE, challenge);
  }
  explicit PeerChallengeMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerChallengeMsgBuilder &operator=(const PeerChallengeMsgBuilder &);
  flatbuffers::Offset<PeerChallengeMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PeerChallengeMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<PeerChallengeMsg> CreatePeerChallengeMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> contract_id = 0,
    uint32_t roundtime = 0,
    bool is_full_history = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> challenge = 0) {
  PeerChallengeMsgBuilder builder_(_fbb);
  builder_.add_challenge(challenge);
  builder_.add_roundtime(roundtime);
  builder_.add_contract_id(contract_id);
  builder_.add_is_full_history(is_full_history);
  return builder_.Finish();
}

inline flatbuffers::Offset<PeerChallengeMsg> CreatePeerChallengeMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *contract_id = nullptr,
    uint32_t roundtime = 0,
    bool is_full_history = false,
    const std::vector<uint8_t> *challenge = nullptr) {
  auto contract_id__ = contract_id ? _fbb.CreateString(contract_id) : 0;
  auto challenge__ = challenge ? _fbb.CreateVector<uint8_t>(*challenge) : 0;
  return msg::fbuf::p2pmsg::CreatePeerChallengeMsg(
      _fbb,
      contract_id__,
      roundtime,
      is_full_history,
      challenge__);
}

struct PeerChallengeResponseMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PeerChallengeResponseMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHALLENGE = 4,
    VT_PUBKEY = 6,
    VT_SIG = 8
  };
  const flatbuffers::Vector<uint8_t> *challenge() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CHALLENGE);
  }
  flatbuffers::Vector<uint8_t> *mutable_challenge() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CHALLENGE);
  }
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const flatbuffers::Vector<uint8_t> *sig() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  flatbuffers::Vector<uint8_t> *mutable_sig() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHALLENGE) &&
           verifier.VerifyVector(challenge()) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_SIG) &&
           verifier.VerifyVector(sig()) &&
           verifier.EndTable();
  }
};

struct PeerChallengeResponseMsgBuilder {
  typedef PeerChallengeResponseMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_challenge(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> challenge) {
    fbb_.AddOffset(PeerChallengeResponseMsg::VT_CHALLENGE, challenge);
  }
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(PeerChallengeResponseMsg::VT_PUBKEY, pubkey);
  }
  void add_sig(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig) {
    fbb_.AddOffset(PeerChallengeResponseMsg::VT_SIG, sig);
  }
  explicit PeerChallengeResponseMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerChallengeResponseMsgBuilder &operator=(const PeerChallengeResponseMsgBuilder &);
  flatbuffers::Offset<PeerChallengeResponseMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PeerChallengeResponseMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<PeerChallengeResponseMsg> CreatePeerChallengeResponseMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> challenge = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig = 0) {
  PeerChallengeResponseMsgBuilder builder_(_fbb);
  builder_.add_sig(sig);
  builder_.add_pubkey(pubkey);
  builder_.add_challenge(challenge);
  return builder_.Finish();
}

inline flatbuffers::Offset<PeerChallengeResponseMsg> CreatePeerChallengeResponseMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *challenge = nullptr,
    const std::vector<uint8_t> *pubkey = nullptr,
    const std::vector<uint8_t> *sig = nullptr) {
  auto challenge__ = challenge ? _fbb.CreateVector<uint8_t>(*challenge) : 0;
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto sig__ = sig ? _fbb.CreateVector<uint8_t>(*sig) : 0;
  return msg::fbuf::p2pmsg::CreatePeerChallengeResponseMsg(
      _fbb,
      challenge__,
      pubkey__,
      sig__);
}

struct UserInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserInputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_CONTAINER = 4,
    VT_SIG = 6,
    VT_PROTOCOL = 8
  };
  const flatbuffers::Vector<uint8_t> *input_container() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INPUT_CONTAINER);
  }
  flatbuffers::Vector<uint8_t> *mutable_input_container() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_INPUT_CONTAINER);
  }
  const flatbuffers::Vector<uint8_t> *sig() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  flatbuffers::Vector<uint8_t> *mutable_sig() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  uint8_t protocol() const {
    return GetField<uint8_t>(VT_PROTOCOL, 0);
  }
  bool mutate_protocol(uint8_t _protocol) {
    return SetField<uint8_t>(VT_PROTOCOL, _protocol, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT_CONTAINER) &&
           verifier.VerifyVector(input_container()) &&
           VerifyOffset(verifier, VT_SIG) &&
           verifier.VerifyVector(sig()) &&
           VerifyField<uint8_t>(verifier, VT_PROTOCOL) &&
           verifier.EndTable();
  }
};

struct UserInputBuilder {
  typedef UserInput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input_container(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_container) {
    fbb_.AddOffset(UserInput::VT_INPUT_CONTAINER, input_container);
  }
  void add_sig(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig) {
    fbb_.AddOffset(UserInput::VT_SIG, sig);
  }
  void add_protocol(uint8_t protocol) {
    fbb_.AddElement<uint8_t>(UserInput::VT_PROTOCOL, protocol, 0);
  }
  explicit UserInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserInputBuilder &operator=(const UserInputBuilder &);
  flatbuffers::Offset<UserInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserInput> CreateUserInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_container = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig = 0,
    uint8_t protocol = 0) {
  UserInputBuilder builder_(_fbb);
  builder_.add_sig(sig);
  builder_.add_input_container(input_container);
  builder_.add_protocol(protocol);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserInput> CreateUserInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *input_container = nullptr,
    const std::vector<uint8_t> *sig = nullptr,
    uint8_t protocol = 0) {
  auto input_container__ = input_container ? _fbb.CreateVector<uint8_t>(*input_container) : 0;
  auto sig__ = sig ? _fbb.CreateVector<uint8_t>(*sig) : 0;
  return msg::fbuf::p2pmsg::CreateUserInput(
      _fbb,
      input_container__,
      sig__,
      protocol);
}

struct UserInputGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserInputGroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_MESSAGES = 6
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>> *>(VT_MESSAGES);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>> *mutable_messages() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>> *>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct UserInputGroupBuilder {
  typedef UserInputGroup Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(UserInputGroup::VT_PUBKEY, pubkey);
  }
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>>> messages) {
    fbb_.AddOffset(UserInputGroup::VT_MESSAGES, messages);
  }
  explicit UserInputGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserInputGroupBuilder &operator=(const UserInputGroupBuilder &);
  flatbuffers::Offset<UserInputGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserInputGroup>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserInputGroup> CreateUserInputGroup(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>>> messages = 0) {
  UserInputGroupBuilder builder_(_fbb);
  builder_.add_messages(messages);
  builder_.add_pubkey(pubkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserInputGroup> CreateUserInputGroupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>> *messages = nullptr) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>>(*messages) : 0;
  return msg::fbuf::p2pmsg::CreateUserInputGroup(
      _fbb,
      pubkey__,
      messages__);
}

struct NonUnlProposalMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonUnlProposalMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_INPUTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>> *user_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>> *>(VT_USER_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>> *mutable_user_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>> *>(VT_USER_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_INPUTS) &&
           verifier.VerifyVector(user_inputs()) &&
           verifier.VerifyVectorOfTables(user_inputs()) &&
           verifier.EndTable();
  }
};

struct NonUnlProposalMsgBuilder {
  typedef NonUnlProposalMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>>> user_inputs) {
    fbb_.AddOffset(NonUnlProposalMsg::VT_USER_INPUTS, user_inputs);
  }
  explicit NonUnlProposalMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonUnlProposalMsgBuilder &operator=(const NonUnlProposalMsgBuilder &);
  flatbuffers::Offset<NonUnlProposalMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonUnlProposalMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonUnlProposalMsg> CreateNonUnlProposalMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>>> user_inputs = 0) {
  NonUnlProposalMsgBuilder builder_(_fbb);
  builder_.add_user_inputs(user_inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonUnlProposalMsg> CreateNonUnlProposalMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>> *user_inputs = nullptr) {
  auto user_inputs__ = user_inputs ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>>(*user_inputs) : 0;
  return msg::fbuf::p2pmsg::CreateNonUnlProposalMsg(
      _fbb,
      user_inputs__);
}

struct ProposalMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProposalMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_SIG = 6,
    VT_STAGE = 8,
    VT_TIME = 10,
    VT_ROUNDTIME = 12,
    VT_NONCE = 14,
    VT_USERS = 16,
    VT_INPUT_HASHES = 18,
    VT_OUTPUT_HASH = 20,
    VT_OUTPUT_SIG = 22,
    VT_STATE_HASH = 24,
    VT_PATCH_HASH = 26,
    VT_LAST_PRIMARY_SHARD_ID = 28,
    VT_LAST_RAW_SHARD_ID = 30
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const flatbuffers::Vector<uint8_t> *sig() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  flatbuffers::Vector<uint8_t> *mutable_sig() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  uint8_t stage() const {
    return GetField<uint8_t>(VT_STAGE, 0);
  }
  bool mutate_stage(uint8_t _stage) {
    return SetField<uint8_t>(VT_STAGE, _stage, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  uint32_t roundtime() const {
    return GetField<uint32_t>(VT_ROUNDTIME, 0);
  }
  bool mutate_roundtime(uint32_t _roundtime) {
    return SetField<uint32_t>(VT_ROUNDTIME, _roundtime, 0);
  }
  const flatbuffers::Vector<uint8_t> *nonce() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_NONCE);
  }
  flatbuffers::Vector<uint8_t> *mutable_nonce() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_NONCE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>> *users() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>> *>(VT_USERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>> *mutable_users() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>> *>(VT_USERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>> *input_hashes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>> *>(VT_INPUT_HASHES);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>> *mutable_input_hashes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>> *>(VT_INPUT_HASHES);
  }
  const flatbuffers::Vector<uint8_t> *output_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OUTPUT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_output_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_OUTPUT_HASH);
  }
  const flatbuffers::Vector<uint8_t> *output_sig() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OUTPUT_SIG);
  }
  flatbuffers::Vector<uint8_t> *mutable_output_sig() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_OUTPUT_SIG);
  }
  const flatbuffers::Vector<uint8_t> *state_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_STATE_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_state_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_STATE_HASH);
  }
  const flatbuffers::Vector<uint8_t> *patch_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PATCH_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_patch_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PATCH_HASH);
  }
  const msg::fbuf::p2pmsg::SequenceHash *last_primary_shard_id() const {
    return GetPointer<const msg::fbuf::p2pmsg::SequenceHash *>(VT_LAST_PRIMARY_SHARD_ID);
  }
  msg::fbuf::p2pmsg::SequenceHash *mutable_last_primary_shard_id() {
    return GetPointer<msg::fbuf::p2pmsg::SequenceHash *>(VT_LAST_PRIMARY_SHARD_ID);
  }
  const msg::fbuf::p2pmsg::SequenceHash *last_raw_shard_id() const {
    return GetPointer<const msg::fbuf::p2pmsg::SequenceHash *>(VT_LAST_RAW_SHARD_ID);
  }
  msg::fbuf::p2pmsg::SequenceHash *mutable_last_raw_shard_id() {
    return GetPointer<msg::fbuf::p2pmsg::SequenceHash *>(VT_LAST_RAW_SHARD_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_SIG) &&
           verifier.VerifyVector(sig()) &&
           VerifyField<uint8_t>(verifier, VT_STAGE) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyField<uint32_t>(verifier, VT_ROUNDTIME) &&
           VerifyOffset(verifier, VT_NONCE) &&
           verifier.VerifyVector(nonce()) &&
           VerifyOffset(verifier, VT_USERS) &&
           verifier.VerifyVector(users()) &&
           verifier.VerifyVectorOfTables(users()) &&
           VerifyOffset(verifier, VT_INPUT_HASHES) &&
           verifier.VerifyVector(input_hashes()) &&
           verifier.VerifyVectorOfTables(input_hashes()) &&
           VerifyOffset(verifier, VT_OUTPUT_HASH) &&
           verifier.VerifyVector(output_hash()) &&
           VerifyOffset(verifier, VT_OUTPUT_SIG) &&
           verifier.VerifyVector(output_sig()) &&
           VerifyOffset(verifier, VT_STATE_HASH) &&
           verifier.VerifyVector(state_hash()) &&
           VerifyOffset(verifier, VT_PATCH_HASH) &&
           verifier.VerifyVector(patch_hash()) &&
           VerifyOffset(verifier, VT_LAST_PRIMARY_SHARD_ID) &&
           verifier.VerifyTable(last_primary_shard_id()) &&
           VerifyOffset(verifier, VT_LAST_RAW_SHARD_ID) &&
           verifier.VerifyTable(last_raw_shard_id()) &&
           verifier.EndTable();
  }
};

struct ProposalMsgBuilder {
  typedef ProposalMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(ProposalMsg::VT_PUBKEY, pubkey);
  }
  void add_sig(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig) {
    fbb_.AddOffset(ProposalMsg::VT_SIG, sig);
  }
  void add_stage(uint8_t stage) {
    fbb_.AddElement<uint8_t>(ProposalMsg::VT_STAGE, stage, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(ProposalMsg::VT_TIME, time, 0);
  }
  void add_roundtime(uint32_t roundtime) {
    fbb_.AddElement<uint32_t>(ProposalMsg::VT_ROUNDTIME, roundtime, 0);
  }
  void add_nonce(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> nonce) {
    fbb_.AddOffset(ProposalMsg::VT_NONCE, nonce);
  }
  void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>>> users) {
    fbb_.AddOffset(ProposalMsg::VT_USERS, users);
  }
  void add_input_hashes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>>> input_hashes) {
    fbb_.AddOffset(ProposalMsg::VT_INPUT_HASHES, input_hashes);
  }
  void add_output_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output_hash) {
    fbb_.AddOffset(ProposalMsg::VT_OUTPUT_HASH, output_hash);
  }
  void add_output_sig(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output_sig) {
    fbb_.AddOffset(ProposalMsg::VT_OUTPUT_SIG, output_sig);
  }
  void add_state_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> state_hash) {
    fbb_.AddOffset(ProposalMsg::VT_STATE_HASH, state_hash);
  }
  void add_patch_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> patch_hash) {
    fbb_.AddOffset(ProposalMsg::VT_PATCH_HASH, patch_hash);
  }
  void add_last_primary_shard_id(flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> last_primary_shard_id) {
    fbb_.AddOffset(ProposalMsg::VT_LAST_PRIMARY_SHARD_ID, last_primary_shard_id);
  }
  void add_last_raw_shard_id(flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> last_raw_shard_id) {
    fbb_.AddOffset(ProposalMsg::VT_LAST_RAW_SHARD_ID, last_raw_shard_id);
  }
  explicit ProposalMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProposalMsgBuilder &operator=(const ProposalMsgBuilder &);
  flatbuffers::Offset<ProposalMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProposalMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProposalMsg> CreateProposalMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig = 0,
    uint8_t stage = 0,
    uint64_t time = 0,
    uint32_t roundtime = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> nonce = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>>> users = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>>> input_hashes = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output_hash = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output_sig = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> state_hash = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> patch_hash = 0,
    flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> last_primary_shard_id = 0,
    flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> last_raw_shard_id = 0) {
  ProposalMsgBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_last_raw_shard_id(last_raw_shard_id);
  builder_.add_last_primary_shard_id(last_primary_shard_id);
  builder_.add_patch_hash(patch_hash);
  builder_.add_state_hash(state_hash);
  builder_.add_output_sig(output_sig);
  builder_.add_output_hash(output_hash);
  builder_.add_input_hashes(input_hashes);
  builder_.add_users(users);
  builder_.add_nonce(nonce);
  builder_.add_roundtime(roundtime);
  builder_.add_sig(sig);
  builder_.add_pubkey(pubkey);
  builder_.add_stage(stage);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProposalMsg> CreateProposalMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    const std::vector<uint8_t> *sig = nullptr,
    uint8_t stage = 0,
    uint64_t time = 0,
    uint32_t roundtime = 0,
    const std::vector<uint8_t> *nonce = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>> *users = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>> *input_hashes = nullptr,
    const std::vector<uint8_t> *output_hash = nullptr,
    const std::vector<uint8_t> *output_sig = nullptr,
    const std::vector<uint8_t> *state_hash = nullptr,
    const std::vector<uint8_t> *patch_hash = nullptr,
    flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> last_primary_shard_id = 0,
    flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> last_raw_shard_id = 0) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto sig__ = sig ? _fbb.CreateVector<uint8_t>(*sig) : 0;
  auto nonce__ = nonce ? _fbb.CreateVector<uint8_t>(*nonce) : 0;
  auto users__ = users ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>>(*users) : 0;
  auto input_hashes__ = input_hashes ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::p2pmsg::ByteArray>>(*input_hashes) : 0;
  auto output_hash__ = output_hash ? _fbb.CreateVector<uint8_t>(*output_hash) : 0;
  auto output_sig__ = output_sig ? _fbb.CreateVector<uint8_t>(*output_sig) : 0;
  auto state_hash__ = state_hash ? _fbb.CreateVector<uint8_t>(*state_hash) : 0;
  auto patch_hash__ = patch_hash ? _fbb.CreateVector<uint8_t>(*patch_hash) : 0;
  return msg::fbuf::p2pmsg::CreateProposalMsg(
      _fbb,
      pubkey__,
      sig__,
      stage,
      time,
      roundtime,
      nonce__,
      users__,
      input_hashes__,
      output_hash__,
      output_sig__,
      state_hash__,
      patch_hash__,
      last_primary_shard_id,
      last_raw_shard_id);
}

struct NplMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NplMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_SIG = 6,
    VT_DATA = 8,
    VT_LCL_ID = 10
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const flatbuffers::Vector<uint8_t> *sig() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  flatbuffers::Vector<uint8_t> *mutable_sig() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  const msg::fbuf::p2pmsg::SequenceHash *lcl_id() const {
    return GetPointer<const msg::fbuf::p2pmsg::SequenceHash *>(VT_LCL_ID);
  }
  msg::fbuf::p2pmsg::SequenceHash *mutable_lcl_id() {
    return GetPointer<msg::fbuf::p2pmsg::SequenceHash *>(VT_LCL_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_SIG) &&
           verifier.VerifyVector(sig()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_LCL_ID) &&
           verifier.VerifyTable(lcl_id()) &&
           verifier.EndTable();
  }
};

struct NplMsgBuilder {
  typedef NplMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(NplMsg::VT_PUBKEY, pubkey);
  }
  void add_sig(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig) {
    fbb_.AddOffset(NplMsg::VT_SIG, sig);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(NplMsg::VT_DATA, data);
  }
  void add_lcl_id(flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> lcl_id) {
    fbb_.AddOffset(NplMsg::VT_LCL_ID, lcl_id);
  }
  explicit NplMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NplMsgBuilder &operator=(const NplMsgBuilder &);
  flatbuffers::Offset<NplMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NplMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<NplMsg> CreateNplMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> lcl_id = 0) {
  NplMsgBuilder builder_(_fbb);
  builder_.add_lcl_id(lcl_id);
  builder_.add_data(data);
  builder_.add_sig(sig);
  builder_.add_pubkey(pubkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<NplMsg> CreateNplMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    const std::vector<uint8_t> *sig = nullptr,
    const std::vector<uint8_t> *data = nullptr,
    flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> lcl_id = 0) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto sig__ = sig ? _fbb.CreateVector<uint8_t>(*sig) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return msg::fbuf::p2pmsg::CreateNplMsg(
      _fbb,
      pubkey__,
      sig__,
      data__,
      lcl_id);
}

struct HpfsRequestMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HpfsRequestMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOUNT_ID = 4,
    VT_PARENT_PATH = 6,
    VT_IS_FILE = 8,
    VT_BLOCK_ID = 10,
    VT_EXPECTED_HASH = 12
  };
  uint32_t mount_id() const {
    return GetField<uint32_t>(VT_MOUNT_ID, 0);
  }
  bool mutate_mount_id(uint32_t _mount_id) {
    return SetField<uint32_t>(VT_MOUNT_ID, _mount_id, 0);
  }
  const flatbuffers::String *parent_path() const {
    return GetPointer<const flatbuffers::String *>(VT_PARENT_PATH);
  }
  flatbuffers::String *mutable_parent_path() {
    return GetPointer<flatbuffers::String *>(VT_PARENT_PATH);
  }
  bool is_file() const {
    return GetField<uint8_t>(VT_IS_FILE, 0) != 0;
  }
  bool mutate_is_file(bool _is_file) {
    return SetField<uint8_t>(VT_IS_FILE, static_cast<uint8_t>(_is_file), 0);
  }
  int32_t block_id() const {
    return GetField<int32_t>(VT_BLOCK_ID, 0);
  }
  bool mutate_block_id(int32_t _block_id) {
    return SetField<int32_t>(VT_BLOCK_ID, _block_id, 0);
  }
  const flatbuffers::Vector<uint8_t> *expected_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_EXPECTED_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_expected_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_EXPECTED_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MOUNT_ID) &&
           VerifyOffset(verifier, VT_PARENT_PATH) &&
           verifier.VerifyString(parent_path()) &&
           VerifyField<uint8_t>(verifier, VT_IS_FILE) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_ID) &&
           VerifyOffset(verifier, VT_EXPECTED_HASH) &&
           verifier.VerifyVector(expected_hash()) &&
           verifier.EndTable();
  }
};

struct HpfsRequestMsgBuilder {
  typedef HpfsRequestMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mount_id(uint32_t mount_id) {
    fbb_.AddElement<uint32_t>(HpfsRequestMsg::VT_MOUNT_ID, mount_id, 0);
  }
  void add_parent_path(flatbuffers::Offset<flatbuffers::String> parent_path) {
    fbb_.AddOffset(HpfsRequestMsg::VT_PARENT_PATH, parent_path);
  }
  void add_is_file(bool is_file) {
    fbb_.AddElement<uint8_t>(HpfsRequestMsg::VT_IS_FILE, static_cast<uint8_t>(is_file), 0);
  }
  void add_block_id(int32_t block_id) {
    fbb_.AddElement<int32_t>(HpfsRequestMsg::VT_BLOCK_ID, block_id, 0);
  }
  void add_expected_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> expected_hash) {
    fbb_.AddOffset(HpfsRequestMsg::VT_EXPECTED_HASH, expected_hash);
  }
  explicit HpfsRequestMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HpfsRequestMsgBuilder &operator=(const HpfsRequestMsgBuilder &);
  flatbuffers::Offset<HpfsRequestMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HpfsRequestMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<HpfsRequestMsg> CreateHpfsRequestMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t mount_id = 0,
    flatbuffers::Offset<flatbuffers::String> parent_path = 0,
    bool is_file = false,
    int32_t block_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> expected_hash = 0) {
  HpfsRequestMsgBuilder builder_(_fbb);
  builder_.add_expected_hash(expected_hash);
  builder_.add_block_id(block_id);
  builder_.add_parent_path(parent_path);
  builder_.add_mount_id(mount_id);
  builder_.add_is_file(is_file);
  return builder_.Finish();
}

inline flatbuffers::Offset<HpfsRequestMsg> CreateHpfsRequestMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t mount_id = 0,
    const char *parent_path = nullptr,
    bool is_file = false,
    int32_t block_id = 0,
    const std::vector<uint8_t> *expected_hash = nullptr) {
  auto parent_path__ = parent_path ? _fbb.CreateString(parent_path) : 0;
  auto expected_hash__ = expected_hash ? _fbb.CreateVector<uint8_t>(*expected_hash) : 0;
  return msg::fbuf::p2pmsg::CreateHpfsRequestMsg(
      _fbb,
      mount_id,
      parent_path__,
      is_file,
      block_id,
      expected_hash__);
}

struct HpfsResponseMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HpfsResponseMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH = 4,
    VT_PATH = 6,
    VT_MOUNT_ID = 8,
    VT_CONTENT_TYPE = 10,
    VT_CONTENT = 12
  };
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  flatbuffers::String *mutable_path() {
    return GetPointer<flatbuffers::String *>(VT_PATH);
  }
  uint32_t mount_id() const {
    return GetField<uint32_t>(VT_MOUNT_ID, 0);
  }
  bool mutate_mount_id(uint32_t _mount_id) {
    return SetField<uint32_t>(VT_MOUNT_ID, _mount_id, 0);
  }
  msg::fbuf::p2pmsg::HpfsResponse content_type() const {
    return static_cast<msg::fbuf::p2pmsg::HpfsResponse>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const msg::fbuf::p2pmsg::HpfsFileHashMapResponse *content_as_HpfsFileHashMapResponse() const {
    return content_type() == msg::fbuf::p2pmsg::HpfsResponse_HpfsFileHashMapResponse ? static_cast<const msg::fbuf::p2pmsg::HpfsFileHashMapResponse *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::HpfsBlockResponse *content_as_HpfsBlockResponse() const {
    return content_type() == msg::fbuf::p2pmsg::HpfsResponse_HpfsBlockResponse ? static_cast<const msg::fbuf::p2pmsg::HpfsBlockResponse *>(content()) : nullptr;
  }
  const msg::fbuf::p2pmsg::HpfsFsEntryResponse *content_as_HpfsFsEntryResponse() const {
    return content_type() == msg::fbuf::p2pmsg::HpfsResponse_HpfsFsEntryResponse ? static_cast<const msg::fbuf::p2pmsg::HpfsFsEntryResponse *>(content()) : nullptr;
  }
  void *mutable_content() {
    return GetPointer<void *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyVector(hash()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyField<uint32_t>(verifier, VT_MOUNT_ID) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyHpfsResponse(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const msg::fbuf::p2pmsg::HpfsFileHashMapResponse *HpfsResponseMsg::content_as<msg::fbuf::p2pmsg::HpfsFileHashMapResponse>() const {
  return content_as_HpfsFileHashMapResponse();
}

template<> inline const msg::fbuf::p2pmsg::HpfsBlockResponse *HpfsResponseMsg::content_as<msg::fbuf::p2pmsg::HpfsBlockResponse>() const {
  return content_as_HpfsBlockResponse();
}

template<> inline const msg::fbuf::p2pmsg::HpfsFsEntryResponse *HpfsResponseMsg::content_as<msg::fbuf::p2pmsg::HpfsFsEntryResponse>() const {
  return content_as_HpfsFsEntryResponse();
}

struct HpfsResponseMsgBuilder {
  typedef HpfsResponseMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(HpfsResponseMsg::VT_HASH, hash);
  }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(HpfsResponseMsg::VT_PATH, path);
  }
  void add_mount_id(uint32_t mount_id) {
    fbb_.AddElement<uint32_t>(HpfsResponseMsg::VT_MOUNT_ID, mount_id, 0);
  }
  void add_content_type(msg::fbuf::p2pmsg::HpfsResponse content_type) {
    fbb_.AddElement<uint8_t>(HpfsResponseMsg::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(flatbuffers::Offset<void> content) {
    fbb_.AddOffset(HpfsResponseMsg::VT_CONTENT, content);
  }
  explicit HpfsResponseMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HpfsResponseMsgBuilder &operator=(const HpfsResponseMsgBuilder &);
  flatbuffers::Offset<HpfsResponseMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HpfsResponseMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<HpfsResponseMsg> CreateHpfsResponseMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    uint32_t mount_id = 0,
    msg::fbuf::p2pmsg::HpfsResponse content_type = msg::fbuf::p2pmsg::HpfsResponse_NONE,
    flatbuffers::Offset<void> content = 0) {
  HpfsResponseMsgBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_mount_id(mount_id);
  builder_.add_path(path);
  builder_.add_hash(hash);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<HpfsResponseMsg> CreateHpfsResponseMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *hash = nullptr,
    const char *path = nullptr,
    uint32_t mount_id = 0,
    msg::fbuf::p2pmsg::HpfsResponse content_type = msg::fbuf::p2pmsg::HpfsResponse_NONE,
    flatbuffers::Offset<void> content = 0) {
  auto hash__ = hash ? _fbb.CreateVector<uint8_t>(*hash) : 0;
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return msg::fbuf::p2pmsg::CreateHpfsResponseMsg(
      _fbb,
      hash__,
      path__,
      mount_id,
      content_type,
      content);
}

struct HpfsFsEntryResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HpfsFsEntryResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIR_MODE = 4,
    VT_ENTRIES = 6
  };
  uint32_t dir_mode() const {
    return GetField<uint32_t>(VT_DIR_MODE, 0);
  }
  bool mutate_dir_mode(uint32_t _dir_mode) {
    return SetField<uint32_t>(VT_DIR_MODE, _dir_mode, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HpfsFSHashEntry>> *entries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HpfsFSHashEntry>> *>(VT_ENTRIES);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HpfsFSHashEntry>> *mutable_entries() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HpfsFSHashEntry>> *>(VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DIR_MODE) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfTables(entries()) &&
           verifier.EndTable();
  }
};

struct HpfsFsEntryResponseBuilder {
  typedef HpfsFsEntryResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dir_mode(uint32_t dir_mode) {
    fbb_.AddElement<uint32_t>(HpfsFsEntryResponse::VT_DIR_MODE, dir_mode, 0);
  }
  void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HpfsFSHashEntry>>> entries) {
    fbb_.AddOffset(HpfsFsEntryResponse::VT_ENTRIES, entries);
  }
  explicit HpfsFsEntryResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HpfsFsEntryResponseBuilder &operator=(const HpfsFsEntryResponseBuilder &);
  flatbuffers::Offset<HpfsFsEntryResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HpfsFsEntryResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HpfsFsEntryResponse> CreateHpfsFsEntryResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dir_mode = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HpfsFSHashEntry>>> entries = 0) {
  HpfsFsEntryResponseBuilder builder_(_fbb);
  builder_.add_entries(entries);
  builder_.add_dir_mode(dir_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<HpfsFsEntryResponse> CreateHpfsFsEntryResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dir_mode = 0,
    const std::vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HpfsFSHashEntry>> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::p2pmsg::HpfsFSHashEntry>>(*entries) : 0;
  return msg::fbuf::p2pmsg::CreateHpfsFsEntryResponse(
      _fbb,
      dir_mode,
      entries__);
}

struct HpfsFileHashMapResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HpfsFileHashMapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_LENGTH = 4,
    VT_FILE_MODE = 6,
    VT_HASH_MAP = 8
  };
  uint64_t file_length() const {
    return GetField<uint64_t>(VT_FILE_LENGTH, 0);
  }
  bool mutate_file_length(uint64_t _file_length) {
    return SetField<uint64_t>(VT_FILE_LENGTH, _file_length, 0);
  }
  uint32_t file_mode() const {
    return GetField<uint32_t>(VT_FILE_MODE, 0);
  }
  bool mutate_file_mode(uint32_t _file_mode) {
    return SetField<uint32_t>(VT_FILE_MODE, _file_mode, 0);
  }
  const flatbuffers::Vector<uint8_t> *hash_map() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH_MAP);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash_map() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FILE_LENGTH) &&
           VerifyField<uint32_t>(verifier, VT_FILE_MODE) &&
           VerifyOffset(verifier, VT_HASH_MAP) &&
           verifier.VerifyVector(hash_map()) &&
           verifier.EndTable();
  }
};

struct HpfsFileHashMapResponseBuilder {
  typedef HpfsFileHashMapResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file_length(uint64_t file_length) {
    fbb_.AddElement<uint64_t>(HpfsFileHashMapResponse::VT_FILE_LENGTH, file_length, 0);
  }
  void add_file_mode(uint32_t file_mode) {
    fbb_.AddElement<uint32_t>(HpfsFileHashMapResponse::VT_FILE_MODE, file_mode, 0);
  }
  void add_hash_map(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash_map) {
    fbb_.AddOffset(HpfsFileHashMapResponse::VT_HASH_MAP, hash_map);
  }
  explicit HpfsFileHashMapResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HpfsFileHashMapResponseBuilder &operator=(const HpfsFileHashMapResponseBuilder &);
  flatbuffers::Offset<HpfsFileHashMapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HpfsFileHashMapResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HpfsFileHashMapResponse> CreateHpfsFileHashMapResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t file_length = 0,
    uint32_t file_mode = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash_map = 0) {
  HpfsFileHashMapResponseBuilder builder_(_fbb);
  builder_.add_file_length(file_length);
  builder_.add_hash_map(hash_map);
  builder_.add_file_mode(file_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<HpfsFileHashMapResponse> CreateHpfsFileHashMapResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t file_length = 0,
    uint32_t file_mode = 0,
    const std::vector<uint8_t> *hash_map = nullptr) {
  auto hash_map__ = hash_map ? _fbb.CreateVector<uint8_t>(*hash_map) : 0;
  return msg::fbuf::p2pmsg::CreateHpfsFileHashMapResponse(
      _fbb,
      file_length,
      file_mode,
      hash_map__);
}

struct HpfsBlockResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HpfsBlockResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_ID = 4,
    VT_DATA = 6
  };
  uint32_t block_id() const {
    return GetField<uint32_t>(VT_BLOCK_ID, 0);
  }
  bool mutate_block_id(uint32_t _block_id) {
    return SetField<uint32_t>(VT_BLOCK_ID, _block_id, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BLOCK_ID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct HpfsBlockResponseBuilder {
  typedef HpfsBlockResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_id(uint32_t block_id) {
    fbb_.AddElement<uint32_t>(HpfsBlockResponse::VT_BLOCK_ID, block_id, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(HpfsBlockResponse::VT_DATA, data);
  }
  explicit HpfsBlockResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HpfsBlockResponseBuilder &operator=(const HpfsBlockResponseBuilder &);
  flatbuffers::Offset<HpfsBlockResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HpfsBlockResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HpfsBlockResponse> CreateHpfsBlockResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t block_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  HpfsBlockResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_block_id(block_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<HpfsBlockResponse> CreateHpfsBlockResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t block_id = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return msg::fbuf::p2pmsg::CreateHpfsBlockResponse(
      _fbb,
      block_id,
      data__);
}

struct HpfsFSHashEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HpfsFSHashEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_IS_FILE = 6,
    VT_HASH = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool is_file() const {
    return GetField<uint8_t>(VT_IS_FILE, 0) != 0;
  }
  bool mutate_is_file(bool _is_file) {
    return SetField<uint8_t>(VT_IS_FILE, static_cast<uint8_t>(_is_file), 0);
  }
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_IS_FILE) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyVector(hash()) &&
           verifier.EndTable();
  }
};

struct HpfsFSHashEntryBuilder {
  typedef HpfsFSHashEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(HpfsFSHashEntry::VT_NAME, name);
  }
  void add_is_file(bool is_file) {
    fbb_.AddElement<uint8_t>(HpfsFSHashEntry::VT_IS_FILE, static_cast<uint8_t>(is_file), 0);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(HpfsFSHashEntry::VT_HASH, hash);
  }
  explicit HpfsFSHashEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HpfsFSHashEntryBuilder &operator=(const HpfsFSHashEntryBuilder &);
  flatbuffers::Offset<HpfsFSHashEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HpfsFSHashEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<HpfsFSHashEntry> CreateHpfsFSHashEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool is_file = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0) {
  HpfsFSHashEntryBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_name(name);
  builder_.add_is_file(is_file);
  return builder_.Finish();
}

inline flatbuffers::Offset<HpfsFSHashEntry> CreateHpfsFSHashEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool is_file = false,
    const std::vector<uint8_t> *hash = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto hash__ = hash ? _fbb.CreateVector<uint8_t>(*hash) : 0;
  return msg::fbuf::p2pmsg::CreateHpfsFSHashEntry(
      _fbb,
      name__,
      is_file,
      hash__);
}

struct HpfsLogRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HpfsLogRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_RECORD_ID = 4,
    VT_MIN_RECORD_ID = 6
  };
  const msg::fbuf::p2pmsg::SequenceHash *target_record_id() const {
    return GetPointer<const msg::fbuf::p2pmsg::SequenceHash *>(VT_TARGET_RECORD_ID);
  }
  msg::fbuf::p2pmsg::SequenceHash *mutable_target_record_id() {
    return GetPointer<msg::fbuf::p2pmsg::SequenceHash *>(VT_TARGET_RECORD_ID);
  }
  const msg::fbuf::p2pmsg::SequenceHash *min_record_id() const {
    return GetPointer<const msg::fbuf::p2pmsg::SequenceHash *>(VT_MIN_RECORD_ID);
  }
  msg::fbuf::p2pmsg::SequenceHash *mutable_min_record_id() {
    return GetPointer<msg::fbuf::p2pmsg::SequenceHash *>(VT_MIN_RECORD_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET_RECORD_ID) &&
           verifier.VerifyTable(target_record_id()) &&
           VerifyOffset(verifier, VT_MIN_RECORD_ID) &&
           verifier.VerifyTable(min_record_id()) &&
           verifier.EndTable();
  }
};

struct HpfsLogRequestBuilder {
  typedef HpfsLogRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target_record_id(flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> target_record_id) {
    fbb_.AddOffset(HpfsLogRequest::VT_TARGET_RECORD_ID, target_record_id);
  }
  void add_min_record_id(flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> min_record_id) {
    fbb_.AddOffset(HpfsLogRequest::VT_MIN_RECORD_ID, min_record_id);
  }
  explicit HpfsLogRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HpfsLogRequestBuilder &operator=(const HpfsLogRequestBuilder &);
  flatbuffers::Offset<HpfsLogRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HpfsLogRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HpfsLogRequest> CreateHpfsLogRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> target_record_id = 0,
    flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> min_record_id = 0) {
  HpfsLogRequestBuilder builder_(_fbb);
  builder_.add_min_record_id(min_record_id);
  builder_.add_target_record_id(target_record_id);
  return builder_.Finish();
}

struct HpfsLogResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HpfsLogResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_RECORD_ID = 4,
    VT_LOG_RECORD_BYTES = 6
  };
  const msg::fbuf::p2pmsg::SequenceHash *min_record_id() const {
    return GetPointer<const msg::fbuf::p2pmsg::SequenceHash *>(VT_MIN_RECORD_ID);
  }
  msg::fbuf::p2pmsg::SequenceHash *mutable_min_record_id() {
    return GetPointer<msg::fbuf::p2pmsg::SequenceHash *>(VT_MIN_RECORD_ID);
  }
  const flatbuffers::Vector<uint8_t> *log_record_bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LOG_RECORD_BYTES);
  }
  flatbuffers::Vector<uint8_t> *mutable_log_record_bytes() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_LOG_RECORD_BYTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN_RECORD_ID) &&
           verifier.VerifyTable(min_record_id()) &&
           VerifyOffset(verifier, VT_LOG_RECORD_BYTES) &&
           verifier.VerifyVector(log_record_bytes()) &&
           verifier.EndTable();
  }
};

struct HpfsLogResponseBuilder {
  typedef HpfsLogResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_record_id(flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> min_record_id) {
    fbb_.AddOffset(HpfsLogResponse::VT_MIN_RECORD_ID, min_record_id);
  }
  void add_log_record_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> log_record_bytes) {
    fbb_.AddOffset(HpfsLogResponse::VT_LOG_RECORD_BYTES, log_record_bytes);
  }
  explicit HpfsLogResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HpfsLogResponseBuilder &operator=(const HpfsLogResponseBuilder &);
  flatbuffers::Offset<HpfsLogResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HpfsLogResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HpfsLogResponse> CreateHpfsLogResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> min_record_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> log_record_bytes = 0) {
  HpfsLogResponseBuilder builder_(_fbb);
  builder_.add_log_record_bytes(log_record_bytes);
  builder_.add_min_record_id(min_record_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<HpfsLogResponse> CreateHpfsLogResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<msg::fbuf::p2pmsg::SequenceHash> min_record_id = 0,
    const std::vector<uint8_t> *log_record_bytes = nullptr) {
  auto log_record_bytes__ = log_record_bytes ? _fbb.CreateVector<uint8_t>(*log_record_bytes) : 0;
  return msg::fbuf::p2pmsg::CreateHpfsLogResponse(
      _fbb,
      min_record_id,
      log_record_bytes__);
}

struct PeerRequirementAnnouncementMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PeerRequirementAnnouncementMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEED_CONSENSUS_MSG_FORWARDING = 4
  };
  bool need_consensus_msg_forwarding() const {
    return GetField<uint8_t>(VT_NEED_CONSENSUS_MSG_FORWARDING, 0) != 0;
  }
  bool mutate_need_consensus_msg_forwarding(bool _need_consensus_msg_forwarding) {
    return SetField<uint8_t>(VT_NEED_CONSENSUS_MSG_FORWARDING, static_cast<uint8_t>(_need_consensus_msg_forwarding), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NEED_CONSENSUS_MSG_FORWARDING) &&
           verifier.EndTable();
  }
};

struct PeerRequirementAnnouncementMsgBuilder {
  typedef PeerRequirementAnnouncementMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_need_consensus_msg_forwarding(bool need_consensus_msg_forwarding) {
    fbb_.AddElement<uint8_t>(PeerRequirementAnnouncementMsg::VT_NEED_CONSENSUS_MSG_FORWARDING, static_cast<uint8_t>(need_consensus_msg_forwarding), 0);
  }
  explicit PeerRequirementAnnouncementMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerRequirementAnnouncementMsgBuilder &operator=(const PeerRequirementAnnouncementMsgBuilder &);
  flatbuffers::Offset<PeerRequirementAnnouncementMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PeerRequirementAnnouncementMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<PeerRequirementAnnouncementMsg> CreatePeerRequirementAnnouncementMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool need_consensus_msg_forwarding = false) {
  PeerRequirementAnnouncementMsgBuilder builder_(_fbb);
  builder_.add_need_consensus_msg_forwarding(need_consensus_msg_forwarding);
  return builder_.Finish();
}

struct PeerCapacityAnnouncementMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PeerCapacityAnnouncementMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AVAILABLE_CAPACITY = 4,
    VT_TIMESTAMP = 6
  };
  int16_t available_capacity() const {
    return GetField<int16_t>(VT_AVAILABLE_CAPACITY, 0);
  }
  bool mutate_available_capacity(int16_t _available_capacity) {
    return SetField<int16_t>(VT_AVAILABLE_CAPACITY, _available_capacity, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_AVAILABLE_CAPACITY) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct PeerCapacityAnnouncementMsgBuilder {
  typedef PeerCapacityAnnouncementMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_available_capacity(int16_t available_capacity) {
    fbb_.AddElement<int16_t>(PeerCapacityAnnouncementMsg::VT_AVAILABLE_CAPACITY, available_capacity, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(PeerCapacityAnnouncementMsg::VT_TIMESTAMP, timestamp, 0);
  }
  explicit PeerCapacityAnnouncementMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerCapacityAnnouncementMsgBuilder &operator=(const PeerCapacityAnnouncementMsgBuilder &);
  flatbuffers::Offset<PeerCapacityAnnouncementMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PeerCapacityAnnouncementMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<PeerCapacityAnnouncementMsg> CreatePeerCapacityAnnouncementMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t available_capacity = 0,
    uint64_t timestamp = 0) {
  PeerCapacityAnnouncementMsgBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_available_capacity(available_capacity);
  return builder_.Finish();
}

struct PeerListRequestMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PeerListRequestMsgBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PeerListRequestMsgBuilder {
  typedef PeerListRequestMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PeerListRequestMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerListRequestMsgBuilder &operator=(const PeerListRequestMsgBuilder &);
  flatbuffers::Offset<PeerListRequestMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PeerListRequestMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<PeerListRequestMsg> CreatePeerListRequestMsg(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PeerListRequestMsgBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PeerListResponseMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PeerListResponseMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEER_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::PeerProperties>> *peer_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::PeerProperties>> *>(VT_PEER_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::PeerProperties>> *mutable_peer_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::PeerProperties>> *>(VT_PEER_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PEER_LIST) &&
           verifier.VerifyVector(peer_list()) &&
           verifier.VerifyVectorOfTables(peer_list()) &&
           verifier.EndTable();
  }
};

struct PeerListResponseMsgBuilder {
  typedef PeerListResponseMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peer_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::PeerProperties>>> peer_list) {
    fbb_.AddOffset(PeerListResponseMsg::VT_PEER_LIST, peer_list);
  }
  explicit PeerListResponseMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerListResponseMsgBuilder &operator=(const PeerListResponseMsgBuilder &);
  flatbuffers::Offset<PeerListResponseMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PeerListResponseMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<PeerListResponseMsg> CreatePeerListResponseMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::PeerProperties>>> peer_list = 0) {
  PeerListResponseMsgBuilder builder_(_fbb);
  builder_.add_peer_list(peer_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<PeerListResponseMsg> CreatePeerListResponseMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<msg::fbuf::p2pmsg::PeerProperties>> *peer_list = nullptr) {
  auto peer_list__ = peer_list ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::p2pmsg::PeerProperties>>(*peer_list) : 0;
  return msg::fbuf::p2pmsg::CreatePeerListResponseMsg(
      _fbb,
      peer_list__);
}

struct PeerProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PeerPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOST_ADDRESS = 4,
    VT_PORT = 6,
    VT_AVAILABLE_CAPACITY = 8,
    VT_TIMESTAMP = 10
  };
  const flatbuffers::String *host_address() const {
    return GetPointer<const flatbuffers::String *>(VT_HOST_ADDRESS);
  }
  flatbuffers::String *mutable_host_address() {
    return GetPointer<flatbuffers::String *>(VT_HOST_ADDRESS);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool mutate_port(uint16_t _port) {
    return SetField<uint16_t>(VT_PORT, _port, 0);
  }
  int16_t available_capacity() const {
    return GetField<int16_t>(VT_AVAILABLE_CAPACITY, 0);
  }
  bool mutate_available_capacity(int16_t _available_capacity) {
    return SetField<int16_t>(VT_AVAILABLE_CAPACITY, _available_capacity, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HOST_ADDRESS) &&
           verifier.VerifyString(host_address()) &&
           VerifyField<uint16_t>(verifier, VT_PORT) &&
           VerifyField<int16_t>(verifier, VT_AVAILABLE_CAPACITY) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct PeerPropertiesBuilder {
  typedef PeerProperties Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_host_address(flatbuffers::Offset<flatbuffers::String> host_address) {
    fbb_.AddOffset(PeerProperties::VT_HOST_ADDRESS, host_address);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(PeerProperties::VT_PORT, port, 0);
  }
  void add_available_capacity(int16_t available_capacity) {
    fbb_.AddElement<int16_t>(PeerProperties::VT_AVAILABLE_CAPACITY, available_capacity, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(PeerProperties::VT_TIMESTAMP, timestamp, 0);
  }
  explicit PeerPropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerPropertiesBuilder &operator=(const PeerPropertiesBuilder &);
  flatbuffers::Offset<PeerProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PeerProperties>(end);
    return o;
  }
};

inline flatbuffers::Offset<PeerProperties> CreatePeerProperties(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> host_address = 0,
    uint16_t port = 0,
    int16_t available_capacity = 0,
    uint64_t timestamp = 0) {
  PeerPropertiesBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_host_address(host_address);
  builder_.add_available_capacity(available_capacity);
  builder_.add_port(port);
  return builder_.Finish();
}

inline flatbuffers::Offset<PeerProperties> CreatePeerPropertiesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *host_address = nullptr,
    uint16_t port = 0,
    int16_t available_capacity = 0,
    uint64_t timestamp = 0) {
  auto host_address__ = host_address ? _fbb.CreateString(host_address) : 0;
  return msg::fbuf::p2pmsg::CreatePeerProperties(
      _fbb,
      host_address__,
      port,
      available_capacity,
      timestamp);
}

struct SequenceHash FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SequenceHashBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ_NO = 4,
    VT_HASH = 6
  };
  uint64_t seq_no() const {
    return GetField<uint64_t>(VT_SEQ_NO, 0);
  }
  bool mutate_seq_no(uint64_t _seq_no) {
    return SetField<uint64_t>(VT_SEQ_NO, _seq_no, 0);
  }
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SEQ_NO) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyVector(hash()) &&
           verifier.EndTable();
  }
};

struct SequenceHashBuilder {
  typedef SequenceHash Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_no(uint64_t seq_no) {
    fbb_.AddElement<uint64_t>(SequenceHash::VT_SEQ_NO, seq_no, 0);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(SequenceHash::VT_HASH, hash);
  }
  explicit SequenceHashBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequenceHashBuilder &operator=(const SequenceHashBuilder &);
  flatbuffers::Offset<SequenceHash> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceHash>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceHash> CreateSequenceHash(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq_no = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0) {
  SequenceHashBuilder builder_(_fbb);
  builder_.add_seq_no(seq_no);
  builder_.add_hash(hash);
  return builder_.Finish();
}

inline flatbuffers::Offset<SequenceHash> CreateSequenceHashDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq_no = 0,
    const std::vector<uint8_t> *hash = nullptr) {
  auto hash__ = hash ? _fbb.CreateVector<uint8_t>(*hash) : 0;
  return msg::fbuf::p2pmsg::CreateSequenceHash(
      _fbb,
      seq_no,
      hash__);
}

struct ByteArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ByteArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARRAY = 4
  };
  const flatbuffers::Vector<uint8_t> *array() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ARRAY);
  }
  flatbuffers::Vector<uint8_t> *mutable_array() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_ARRAY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARRAY) &&
           verifier.VerifyVector(array()) &&
           verifier.EndTable();
  }
};

struct ByteArrayBuilder {
  typedef ByteArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_array(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> array) {
    fbb_.AddOffset(ByteArray::VT_ARRAY, array);
  }
  explicit ByteArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ByteArrayBuilder &operator=(const ByteArrayBuilder &);
  flatbuffers::Offset<ByteArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ByteArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<ByteArray> CreateByteArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> array = 0) {
  ByteArrayBuilder builder_(_fbb);
  builder_.add_array(array);
  return builder_.Finish();
}

inline flatbuffers::Offset<ByteArray> CreateByteArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *array = nullptr) {
  auto array__ = array ? _fbb.CreateVector<uint8_t>(*array) : 0;
  return msg::fbuf::p2pmsg::CreateByteArray(
      _fbb,
      array__);
}

inline bool VerifyP2PMsgContent(flatbuffers::Verifier &verifier, const void *obj, P2PMsgContent type) {
  switch (type) {
    case P2PMsgContent_NONE: {
      return true;
    }
    case P2PMsgContent_PeerChallengeMsg: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::PeerChallengeMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_PeerChallengeResponseMsg: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::PeerChallengeResponseMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_NonUnlProposalMsg: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::NonUnlProposalMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_ProposalMsg: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::ProposalMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_NplMsg: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::NplMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_HpfsRequestMsg: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::HpfsRequestMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_HpfsResponseMsg: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::HpfsResponseMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_PeerRequirementAnnouncementMsg: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::PeerRequirementAnnouncementMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_PeerCapacityAnnouncementMsg: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::PeerCapacityAnnouncementMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_PeerListRequestMsg: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::PeerListRequestMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_PeerListResponseMsg: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::PeerListResponseMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_HpfsLogRequest: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::HpfsLogRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case P2PMsgContent_HpfsLogResponse: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::HpfsLogResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyP2PMsgContentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyP2PMsgContent(
        verifier,  values->Get(i), types->GetEnum<P2PMsgContent>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyHpfsResponse(flatbuffers::Verifier &verifier, const void *obj, HpfsResponse type) {
  switch (type) {
    case HpfsResponse_NONE: {
      return true;
    }
    case HpfsResponse_HpfsFileHashMapResponse: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::HpfsFileHashMapResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HpfsResponse_HpfsBlockResponse: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::HpfsBlockResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HpfsResponse_HpfsFsEntryResponse: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::HpfsFsEntryResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyHpfsResponseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyHpfsResponse(
        verifier,  values->Get(i), types->GetEnum<HpfsResponse>(i))) {
      return false;
    }
  }
  return true;
}

inline const msg::fbuf::p2pmsg::P2PMsg *GetP2PMsg(const void *buf) {
  return flatbuffers::GetRoot<msg::fbuf::p2pmsg::P2PMsg>(buf);
}

inline const msg::fbuf::p2pmsg::P2PMsg *GetSizePrefixedP2PMsg(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<msg::fbuf::p2pmsg::P2PMsg>(buf);
}

inline P2PMsg *GetMutableP2PMsg(void *buf) {
  return flatbuffers::GetMutableRoot<P2PMsg>(buf);
}

inline bool VerifyP2PMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<msg::fbuf::p2pmsg::P2PMsg>(nullptr);
}

inline bool VerifySizePrefixedP2PMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<msg::fbuf::p2pmsg::P2PMsg>(nullptr);
}

inline void FinishP2PMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<msg::fbuf::p2pmsg::P2PMsg> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedP2PMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<msg::fbuf::p2pmsg::P2PMsg> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace p2pmsg
}  // namespace fbuf
}  // namespace msg

#endif  // FLATBUFFERS_GENERATED_P2PMSG_MSG_FBUF_P2PMSG_H_
