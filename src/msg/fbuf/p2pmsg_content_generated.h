// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_P2PMSGCONTENT_MSG_FBUF_P2PMSG_H_
#define FLATBUFFERS_GENERATED_P2PMSGCONTENT_MSG_FBUF_P2PMSG_H_

#include "flatbuffers/flatbuffers.h"

#include "common_schema_generated.h"

namespace msg {
namespace fbuf {
namespace p2pmsg {

struct Peer_Challenge_Message;
struct Peer_Challenge_MessageBuilder;

struct Peer_Challenge_Response_Message;
struct Peer_Challenge_Response_MessageBuilder;

struct UserInput;
struct UserInputBuilder;

struct UserInputGroup;
struct UserInputGroupBuilder;

struct Content;
struct ContentBuilder;

struct NonUnl_Proposal_Message;
struct NonUnl_Proposal_MessageBuilder;

struct Proposal_Message;
struct Proposal_MessageBuilder;

struct Npl_Message;
struct Npl_MessageBuilder;

struct History_Request_Message;
struct History_Request_MessageBuilder;

struct History_Response_Message;
struct History_Response_MessageBuilder;

struct HistoryLedgerBlockPair;
struct HistoryLedgerBlockPairBuilder;

struct HistoryLedgerBlock;
struct HistoryLedgerBlockBuilder;

struct Hpfs_Request_Message;
struct Hpfs_Request_MessageBuilder;

struct Hpfs_Response_Message;
struct Hpfs_Response_MessageBuilder;

struct Fs_Entry_Response;
struct Fs_Entry_ResponseBuilder;

struct File_HashMap_Response;
struct File_HashMap_ResponseBuilder;

struct Block_Response;
struct Block_ResponseBuilder;

struct Hpfs_FS_Hash_Entry;
struct Hpfs_FS_Hash_EntryBuilder;

struct Peer_Requirement_Announcement_Message;
struct Peer_Requirement_Announcement_MessageBuilder;

struct Available_Capacity_Announcement_Message;
struct Available_Capacity_Announcement_MessageBuilder;

struct Peer_List_Request_Message;
struct Peer_List_Request_MessageBuilder;

struct Peer_List_Response_Message;
struct Peer_List_Response_MessageBuilder;

struct Peer_Properties;
struct Peer_PropertiesBuilder;

enum Message {
  Message_NONE = 0,
  Message_Peer_Challenge_Response_Message = 1,
  Message_Peer_Challenge_Message = 2,
  Message_NonUnl_Proposal_Message = 3,
  Message_Proposal_Message = 4,
  Message_Npl_Message = 5,
  Message_Hpfs_Request_Message = 6,
  Message_Hpfs_Response_Message = 7,
  Message_History_Request_Message = 8,
  Message_History_Response_Message = 9,
  Message_Peer_Requirement_Announcement_Message = 10,
  Message_Peer_List_Request_Message = 11,
  Message_Peer_List_Response_Message = 12,
  Message_Available_Capacity_Announcement_Message = 13,
  Message_MIN = Message_NONE,
  Message_MAX = Message_Available_Capacity_Announcement_Message
};

inline const Message (&EnumValuesMessage())[14] {
  static const Message values[] = {
    Message_NONE,
    Message_Peer_Challenge_Response_Message,
    Message_Peer_Challenge_Message,
    Message_NonUnl_Proposal_Message,
    Message_Proposal_Message,
    Message_Npl_Message,
    Message_Hpfs_Request_Message,
    Message_Hpfs_Response_Message,
    Message_History_Request_Message,
    Message_History_Response_Message,
    Message_Peer_Requirement_Announcement_Message,
    Message_Peer_List_Request_Message,
    Message_Peer_List_Response_Message,
    Message_Available_Capacity_Announcement_Message
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[15] = {
    "NONE",
    "Peer_Challenge_Response_Message",
    "Peer_Challenge_Message",
    "NonUnl_Proposal_Message",
    "Proposal_Message",
    "Npl_Message",
    "Hpfs_Request_Message",
    "Hpfs_Response_Message",
    "History_Request_Message",
    "History_Response_Message",
    "Peer_Requirement_Announcement_Message",
    "Peer_List_Request_Message",
    "Peer_List_Response_Message",
    "Available_Capacity_Announcement_Message",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (flatbuffers::IsOutRange(e, Message_NONE, Message_Available_Capacity_Announcement_Message)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::Peer_Challenge_Response_Message> {
  static const Message enum_value = Message_Peer_Challenge_Response_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::Peer_Challenge_Message> {
  static const Message enum_value = Message_Peer_Challenge_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::NonUnl_Proposal_Message> {
  static const Message enum_value = Message_NonUnl_Proposal_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::Proposal_Message> {
  static const Message enum_value = Message_Proposal_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::Npl_Message> {
  static const Message enum_value = Message_Npl_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::Hpfs_Request_Message> {
  static const Message enum_value = Message_Hpfs_Request_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::Hpfs_Response_Message> {
  static const Message enum_value = Message_Hpfs_Response_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::History_Request_Message> {
  static const Message enum_value = Message_History_Request_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::History_Response_Message> {
  static const Message enum_value = Message_History_Response_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::Peer_Requirement_Announcement_Message> {
  static const Message enum_value = Message_Peer_Requirement_Announcement_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::Peer_List_Request_Message> {
  static const Message enum_value = Message_Peer_List_Request_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::Peer_List_Response_Message> {
  static const Message enum_value = Message_Peer_List_Response_Message;
};

template<> struct MessageTraits<msg::fbuf::p2pmsg::Available_Capacity_Announcement_Message> {
  static const Message enum_value = Message_Available_Capacity_Announcement_Message;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Ledger_Response_Error {
  Ledger_Response_Error_None = 0,
  Ledger_Response_Error_Invalid_Min_Ledger = 1,
  Ledger_Response_Error_Req_Ledger_Not_Found = 2,
  Ledger_Response_Error_MIN = Ledger_Response_Error_None,
  Ledger_Response_Error_MAX = Ledger_Response_Error_Req_Ledger_Not_Found
};

inline const Ledger_Response_Error (&EnumValuesLedger_Response_Error())[3] {
  static const Ledger_Response_Error values[] = {
    Ledger_Response_Error_None,
    Ledger_Response_Error_Invalid_Min_Ledger,
    Ledger_Response_Error_Req_Ledger_Not_Found
  };
  return values;
}

inline const char * const *EnumNamesLedger_Response_Error() {
  static const char * const names[4] = {
    "None",
    "Invalid_Min_Ledger",
    "Req_Ledger_Not_Found",
    nullptr
  };
  return names;
}

inline const char *EnumNameLedger_Response_Error(Ledger_Response_Error e) {
  if (flatbuffers::IsOutRange(e, Ledger_Response_Error_None, Ledger_Response_Error_Req_Ledger_Not_Found)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLedger_Response_Error()[index];
}

enum Hpfs_Response {
  Hpfs_Response_NONE = 0,
  Hpfs_Response_File_HashMap_Response = 1,
  Hpfs_Response_Block_Response = 2,
  Hpfs_Response_Fs_Entry_Response = 3,
  Hpfs_Response_MIN = Hpfs_Response_NONE,
  Hpfs_Response_MAX = Hpfs_Response_Fs_Entry_Response
};

inline const Hpfs_Response (&EnumValuesHpfs_Response())[4] {
  static const Hpfs_Response values[] = {
    Hpfs_Response_NONE,
    Hpfs_Response_File_HashMap_Response,
    Hpfs_Response_Block_Response,
    Hpfs_Response_Fs_Entry_Response
  };
  return values;
}

inline const char * const *EnumNamesHpfs_Response() {
  static const char * const names[5] = {
    "NONE",
    "File_HashMap_Response",
    "Block_Response",
    "Fs_Entry_Response",
    nullptr
  };
  return names;
}

inline const char *EnumNameHpfs_Response(Hpfs_Response e) {
  if (flatbuffers::IsOutRange(e, Hpfs_Response_NONE, Hpfs_Response_Fs_Entry_Response)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHpfs_Response()[index];
}

template<typename T> struct Hpfs_ResponseTraits {
  static const Hpfs_Response enum_value = Hpfs_Response_NONE;
};

template<> struct Hpfs_ResponseTraits<msg::fbuf::p2pmsg::File_HashMap_Response> {
  static const Hpfs_Response enum_value = Hpfs_Response_File_HashMap_Response;
};

template<> struct Hpfs_ResponseTraits<msg::fbuf::p2pmsg::Block_Response> {
  static const Hpfs_Response enum_value = Hpfs_Response_Block_Response;
};

template<> struct Hpfs_ResponseTraits<msg::fbuf::p2pmsg::Fs_Entry_Response> {
  static const Hpfs_Response enum_value = Hpfs_Response_Fs_Entry_Response;
};

bool VerifyHpfs_Response(flatbuffers::Verifier &verifier, const void *obj, Hpfs_Response type);
bool VerifyHpfs_ResponseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Peer_Challenge_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Peer_Challenge_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTRACT_ID = 4,
    VT_ROUNDTIME = 6,
    VT_CHALLENGE = 8
  };
  const flatbuffers::String *contract_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTRACT_ID);
  }
  flatbuffers::String *mutable_contract_id() {
    return GetPointer<flatbuffers::String *>(VT_CONTRACT_ID);
  }
  uint32_t roundtime() const {
    return GetField<uint32_t>(VT_ROUNDTIME, 0);
  }
  bool mutate_roundtime(uint32_t _roundtime) {
    return SetField<uint32_t>(VT_ROUNDTIME, _roundtime, 0);
  }
  const flatbuffers::String *challenge() const {
    return GetPointer<const flatbuffers::String *>(VT_CHALLENGE);
  }
  flatbuffers::String *mutable_challenge() {
    return GetPointer<flatbuffers::String *>(VT_CHALLENGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTRACT_ID) &&
           verifier.VerifyString(contract_id()) &&
           VerifyField<uint32_t>(verifier, VT_ROUNDTIME) &&
           VerifyOffset(verifier, VT_CHALLENGE) &&
           verifier.VerifyString(challenge()) &&
           verifier.EndTable();
  }
};

struct Peer_Challenge_MessageBuilder {
  typedef Peer_Challenge_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contract_id(flatbuffers::Offset<flatbuffers::String> contract_id) {
    fbb_.AddOffset(Peer_Challenge_Message::VT_CONTRACT_ID, contract_id);
  }
  void add_roundtime(uint32_t roundtime) {
    fbb_.AddElement<uint32_t>(Peer_Challenge_Message::VT_ROUNDTIME, roundtime, 0);
  }
  void add_challenge(flatbuffers::Offset<flatbuffers::String> challenge) {
    fbb_.AddOffset(Peer_Challenge_Message::VT_CHALLENGE, challenge);
  }
  explicit Peer_Challenge_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Peer_Challenge_MessageBuilder &operator=(const Peer_Challenge_MessageBuilder &);
  flatbuffers::Offset<Peer_Challenge_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Peer_Challenge_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Peer_Challenge_Message> CreatePeer_Challenge_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> contract_id = 0,
    uint32_t roundtime = 0,
    flatbuffers::Offset<flatbuffers::String> challenge = 0) {
  Peer_Challenge_MessageBuilder builder_(_fbb);
  builder_.add_challenge(challenge);
  builder_.add_roundtime(roundtime);
  builder_.add_contract_id(contract_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Peer_Challenge_Message> CreatePeer_Challenge_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *contract_id = nullptr,
    uint32_t roundtime = 0,
    const char *challenge = nullptr) {
  auto contract_id__ = contract_id ? _fbb.CreateString(contract_id) : 0;
  auto challenge__ = challenge ? _fbb.CreateString(challenge) : 0;
  return msg::fbuf::p2pmsg::CreatePeer_Challenge_Message(
      _fbb,
      contract_id__,
      roundtime,
      challenge__);
}

struct Peer_Challenge_Response_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Peer_Challenge_Response_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHALLENGE = 4,
    VT_SIG = 6
  };
  const flatbuffers::String *challenge() const {
    return GetPointer<const flatbuffers::String *>(VT_CHALLENGE);
  }
  flatbuffers::String *mutable_challenge() {
    return GetPointer<flatbuffers::String *>(VT_CHALLENGE);
  }
  const flatbuffers::Vector<uint8_t> *sig() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  flatbuffers::Vector<uint8_t> *mutable_sig() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHALLENGE) &&
           verifier.VerifyString(challenge()) &&
           VerifyOffset(verifier, VT_SIG) &&
           verifier.VerifyVector(sig()) &&
           verifier.EndTable();
  }
};

struct Peer_Challenge_Response_MessageBuilder {
  typedef Peer_Challenge_Response_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_challenge(flatbuffers::Offset<flatbuffers::String> challenge) {
    fbb_.AddOffset(Peer_Challenge_Response_Message::VT_CHALLENGE, challenge);
  }
  void add_sig(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig) {
    fbb_.AddOffset(Peer_Challenge_Response_Message::VT_SIG, sig);
  }
  explicit Peer_Challenge_Response_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Peer_Challenge_Response_MessageBuilder &operator=(const Peer_Challenge_Response_MessageBuilder &);
  flatbuffers::Offset<Peer_Challenge_Response_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Peer_Challenge_Response_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Peer_Challenge_Response_Message> CreatePeer_Challenge_Response_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> challenge = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig = 0) {
  Peer_Challenge_Response_MessageBuilder builder_(_fbb);
  builder_.add_sig(sig);
  builder_.add_challenge(challenge);
  return builder_.Finish();
}

inline flatbuffers::Offset<Peer_Challenge_Response_Message> CreatePeer_Challenge_Response_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *challenge = nullptr,
    const std::vector<uint8_t> *sig = nullptr) {
  auto challenge__ = challenge ? _fbb.CreateString(challenge) : 0;
  auto sig__ = sig ? _fbb.CreateVector<uint8_t>(*sig) : 0;
  return msg::fbuf::p2pmsg::CreatePeer_Challenge_Response_Message(
      _fbb,
      challenge__,
      sig__);
}

struct UserInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserInputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_CONTAINER = 4,
    VT_SIGNATURE = 6,
    VT_PROTOCOL = 8
  };
  const flatbuffers::Vector<uint8_t> *input_container() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INPUT_CONTAINER);
  }
  flatbuffers::Vector<uint8_t> *mutable_input_container() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_INPUT_CONTAINER);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  flatbuffers::Vector<uint8_t> *mutable_signature() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  uint8_t protocol() const {
    return GetField<uint8_t>(VT_PROTOCOL, 0);
  }
  bool mutate_protocol(uint8_t _protocol) {
    return SetField<uint8_t>(VT_PROTOCOL, _protocol, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT_CONTAINER) &&
           verifier.VerifyVector(input_container()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           VerifyField<uint8_t>(verifier, VT_PROTOCOL) &&
           verifier.EndTable();
  }
};

struct UserInputBuilder {
  typedef UserInput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input_container(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_container) {
    fbb_.AddOffset(UserInput::VT_INPUT_CONTAINER, input_container);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(UserInput::VT_SIGNATURE, signature);
  }
  void add_protocol(uint8_t protocol) {
    fbb_.AddElement<uint8_t>(UserInput::VT_PROTOCOL, protocol, 0);
  }
  explicit UserInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserInputBuilder &operator=(const UserInputBuilder &);
  flatbuffers::Offset<UserInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserInput> CreateUserInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_container = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0,
    uint8_t protocol = 0) {
  UserInputBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_input_container(input_container);
  builder_.add_protocol(protocol);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserInput> CreateUserInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *input_container = nullptr,
    const std::vector<uint8_t> *signature = nullptr,
    uint8_t protocol = 0) {
  auto input_container__ = input_container ? _fbb.CreateVector<uint8_t>(*input_container) : 0;
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  return msg::fbuf::p2pmsg::CreateUserInput(
      _fbb,
      input_container__,
      signature__,
      protocol);
}

struct UserInputGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserInputGroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_MESSAGES = 6
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>> *>(VT_MESSAGES);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>> *mutable_messages() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>> *>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct UserInputGroupBuilder {
  typedef UserInputGroup Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(UserInputGroup::VT_PUBKEY, pubkey);
  }
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>>> messages) {
    fbb_.AddOffset(UserInputGroup::VT_MESSAGES, messages);
  }
  explicit UserInputGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserInputGroupBuilder &operator=(const UserInputGroupBuilder &);
  flatbuffers::Offset<UserInputGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserInputGroup>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserInputGroup> CreateUserInputGroup(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>>> messages = 0) {
  UserInputGroupBuilder builder_(_fbb);
  builder_.add_messages(messages);
  builder_.add_pubkey(pubkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserInputGroup> CreateUserInputGroupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>> *messages = nullptr) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInput>>(*messages) : 0;
  return msg::fbuf::p2pmsg::CreateUserInputGroup(
      _fbb,
      pubkey__,
      messages__);
}

struct Content FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ContentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  msg::fbuf::p2pmsg::Message message_type() const {
    return static_cast<msg::fbuf::p2pmsg::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const msg::fbuf::p2pmsg::Peer_Challenge_Response_Message *message_as_Peer_Challenge_Response_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_Peer_Challenge_Response_Message ? static_cast<const msg::fbuf::p2pmsg::Peer_Challenge_Response_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::Peer_Challenge_Message *message_as_Peer_Challenge_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_Peer_Challenge_Message ? static_cast<const msg::fbuf::p2pmsg::Peer_Challenge_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::NonUnl_Proposal_Message *message_as_NonUnl_Proposal_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_NonUnl_Proposal_Message ? static_cast<const msg::fbuf::p2pmsg::NonUnl_Proposal_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::Proposal_Message *message_as_Proposal_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_Proposal_Message ? static_cast<const msg::fbuf::p2pmsg::Proposal_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::Npl_Message *message_as_Npl_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_Npl_Message ? static_cast<const msg::fbuf::p2pmsg::Npl_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::Hpfs_Request_Message *message_as_Hpfs_Request_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_Hpfs_Request_Message ? static_cast<const msg::fbuf::p2pmsg::Hpfs_Request_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::Hpfs_Response_Message *message_as_Hpfs_Response_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_Hpfs_Response_Message ? static_cast<const msg::fbuf::p2pmsg::Hpfs_Response_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::History_Request_Message *message_as_History_Request_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_History_Request_Message ? static_cast<const msg::fbuf::p2pmsg::History_Request_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::History_Response_Message *message_as_History_Response_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_History_Response_Message ? static_cast<const msg::fbuf::p2pmsg::History_Response_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::Peer_Requirement_Announcement_Message *message_as_Peer_Requirement_Announcement_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_Peer_Requirement_Announcement_Message ? static_cast<const msg::fbuf::p2pmsg::Peer_Requirement_Announcement_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::Peer_List_Request_Message *message_as_Peer_List_Request_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_Peer_List_Request_Message ? static_cast<const msg::fbuf::p2pmsg::Peer_List_Request_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::Peer_List_Response_Message *message_as_Peer_List_Response_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_Peer_List_Response_Message ? static_cast<const msg::fbuf::p2pmsg::Peer_List_Response_Message *>(message()) : nullptr;
  }
  const msg::fbuf::p2pmsg::Available_Capacity_Announcement_Message *message_as_Available_Capacity_Announcement_Message() const {
    return message_type() == msg::fbuf::p2pmsg::Message_Available_Capacity_Announcement_Message ? static_cast<const msg::fbuf::p2pmsg::Available_Capacity_Announcement_Message *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const msg::fbuf::p2pmsg::Peer_Challenge_Response_Message *Content::message_as<msg::fbuf::p2pmsg::Peer_Challenge_Response_Message>() const {
  return message_as_Peer_Challenge_Response_Message();
}

template<> inline const msg::fbuf::p2pmsg::Peer_Challenge_Message *Content::message_as<msg::fbuf::p2pmsg::Peer_Challenge_Message>() const {
  return message_as_Peer_Challenge_Message();
}

template<> inline const msg::fbuf::p2pmsg::NonUnl_Proposal_Message *Content::message_as<msg::fbuf::p2pmsg::NonUnl_Proposal_Message>() const {
  return message_as_NonUnl_Proposal_Message();
}

template<> inline const msg::fbuf::p2pmsg::Proposal_Message *Content::message_as<msg::fbuf::p2pmsg::Proposal_Message>() const {
  return message_as_Proposal_Message();
}

template<> inline const msg::fbuf::p2pmsg::Npl_Message *Content::message_as<msg::fbuf::p2pmsg::Npl_Message>() const {
  return message_as_Npl_Message();
}

template<> inline const msg::fbuf::p2pmsg::Hpfs_Request_Message *Content::message_as<msg::fbuf::p2pmsg::Hpfs_Request_Message>() const {
  return message_as_Hpfs_Request_Message();
}

template<> inline const msg::fbuf::p2pmsg::Hpfs_Response_Message *Content::message_as<msg::fbuf::p2pmsg::Hpfs_Response_Message>() const {
  return message_as_Hpfs_Response_Message();
}

template<> inline const msg::fbuf::p2pmsg::History_Request_Message *Content::message_as<msg::fbuf::p2pmsg::History_Request_Message>() const {
  return message_as_History_Request_Message();
}

template<> inline const msg::fbuf::p2pmsg::History_Response_Message *Content::message_as<msg::fbuf::p2pmsg::History_Response_Message>() const {
  return message_as_History_Response_Message();
}

template<> inline const msg::fbuf::p2pmsg::Peer_Requirement_Announcement_Message *Content::message_as<msg::fbuf::p2pmsg::Peer_Requirement_Announcement_Message>() const {
  return message_as_Peer_Requirement_Announcement_Message();
}

template<> inline const msg::fbuf::p2pmsg::Peer_List_Request_Message *Content::message_as<msg::fbuf::p2pmsg::Peer_List_Request_Message>() const {
  return message_as_Peer_List_Request_Message();
}

template<> inline const msg::fbuf::p2pmsg::Peer_List_Response_Message *Content::message_as<msg::fbuf::p2pmsg::Peer_List_Response_Message>() const {
  return message_as_Peer_List_Response_Message();
}

template<> inline const msg::fbuf::p2pmsg::Available_Capacity_Announcement_Message *Content::message_as<msg::fbuf::p2pmsg::Available_Capacity_Announcement_Message>() const {
  return message_as_Available_Capacity_Announcement_Message();
}

struct ContentBuilder {
  typedef Content Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(msg::fbuf::p2pmsg::Message message_type) {
    fbb_.AddElement<uint8_t>(Content::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Content::VT_MESSAGE, message);
  }
  explicit ContentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContentBuilder &operator=(const ContentBuilder &);
  flatbuffers::Offset<Content> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Content>(end);
    return o;
  }
};

inline flatbuffers::Offset<Content> CreateContent(
    flatbuffers::FlatBufferBuilder &_fbb,
    msg::fbuf::p2pmsg::Message message_type = msg::fbuf::p2pmsg::Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  ContentBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct NonUnl_Proposal_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonUnl_Proposal_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_INPUTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>> *user_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>> *>(VT_USER_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>> *mutable_user_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>> *>(VT_USER_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_INPUTS) &&
           verifier.VerifyVector(user_inputs()) &&
           verifier.VerifyVectorOfTables(user_inputs()) &&
           verifier.EndTable();
  }
};

struct NonUnl_Proposal_MessageBuilder {
  typedef NonUnl_Proposal_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>>> user_inputs) {
    fbb_.AddOffset(NonUnl_Proposal_Message::VT_USER_INPUTS, user_inputs);
  }
  explicit NonUnl_Proposal_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonUnl_Proposal_MessageBuilder &operator=(const NonUnl_Proposal_MessageBuilder &);
  flatbuffers::Offset<NonUnl_Proposal_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonUnl_Proposal_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonUnl_Proposal_Message> CreateNonUnl_Proposal_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>>> user_inputs = 0) {
  NonUnl_Proposal_MessageBuilder builder_(_fbb);
  builder_.add_user_inputs(user_inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonUnl_Proposal_Message> CreateNonUnl_Proposal_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>> *user_inputs = nullptr) {
  auto user_inputs__ = user_inputs ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::p2pmsg::UserInputGroup>>(*user_inputs) : 0;
  return msg::fbuf::p2pmsg::CreateNonUnl_Proposal_Message(
      _fbb,
      user_inputs__);
}

struct Proposal_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Proposal_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STAGE = 4,
    VT_TIME = 6,
    VT_ROUNDTIME = 8,
    VT_NONCE = 10,
    VT_USERS = 12,
    VT_INPUT_HASHES = 14,
    VT_OUTPUT_HASH = 16,
    VT_OUTPUT_SIG = 18,
    VT_STATE_HASH = 20,
    VT_PATCH_HASH = 22
  };
  uint8_t stage() const {
    return GetField<uint8_t>(VT_STAGE, 0);
  }
  bool mutate_stage(uint8_t _stage) {
    return SetField<uint8_t>(VT_STAGE, _stage, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  uint32_t roundtime() const {
    return GetField<uint32_t>(VT_ROUNDTIME, 0);
  }
  bool mutate_roundtime(uint32_t _roundtime) {
    return SetField<uint32_t>(VT_ROUNDTIME, _roundtime, 0);
  }
  const flatbuffers::Vector<uint8_t> *nonce() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_NONCE);
  }
  flatbuffers::Vector<uint8_t> *mutable_nonce() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_NONCE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *users() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *>(VT_USERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *mutable_users() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *>(VT_USERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *input_hashes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *>(VT_INPUT_HASHES);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *mutable_input_hashes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *>(VT_INPUT_HASHES);
  }
  const flatbuffers::Vector<uint8_t> *output_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OUTPUT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_output_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_OUTPUT_HASH);
  }
  const flatbuffers::Vector<uint8_t> *output_sig() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OUTPUT_SIG);
  }
  flatbuffers::Vector<uint8_t> *mutable_output_sig() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_OUTPUT_SIG);
  }
  const flatbuffers::Vector<uint8_t> *state_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_STATE_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_state_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_STATE_HASH);
  }
  const flatbuffers::Vector<uint8_t> *patch_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PATCH_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_patch_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PATCH_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STAGE) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyField<uint32_t>(verifier, VT_ROUNDTIME) &&
           VerifyOffset(verifier, VT_NONCE) &&
           verifier.VerifyVector(nonce()) &&
           VerifyOffset(verifier, VT_USERS) &&
           verifier.VerifyVector(users()) &&
           verifier.VerifyVectorOfTables(users()) &&
           VerifyOffset(verifier, VT_INPUT_HASHES) &&
           verifier.VerifyVector(input_hashes()) &&
           verifier.VerifyVectorOfTables(input_hashes()) &&
           VerifyOffset(verifier, VT_OUTPUT_HASH) &&
           verifier.VerifyVector(output_hash()) &&
           VerifyOffset(verifier, VT_OUTPUT_SIG) &&
           verifier.VerifyVector(output_sig()) &&
           VerifyOffset(verifier, VT_STATE_HASH) &&
           verifier.VerifyVector(state_hash()) &&
           VerifyOffset(verifier, VT_PATCH_HASH) &&
           verifier.VerifyVector(patch_hash()) &&
           verifier.EndTable();
  }
};

struct Proposal_MessageBuilder {
  typedef Proposal_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stage(uint8_t stage) {
    fbb_.AddElement<uint8_t>(Proposal_Message::VT_STAGE, stage, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(Proposal_Message::VT_TIME, time, 0);
  }
  void add_roundtime(uint32_t roundtime) {
    fbb_.AddElement<uint32_t>(Proposal_Message::VT_ROUNDTIME, roundtime, 0);
  }
  void add_nonce(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> nonce) {
    fbb_.AddOffset(Proposal_Message::VT_NONCE, nonce);
  }
  void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>>> users) {
    fbb_.AddOffset(Proposal_Message::VT_USERS, users);
  }
  void add_input_hashes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>>> input_hashes) {
    fbb_.AddOffset(Proposal_Message::VT_INPUT_HASHES, input_hashes);
  }
  void add_output_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output_hash) {
    fbb_.AddOffset(Proposal_Message::VT_OUTPUT_HASH, output_hash);
  }
  void add_output_sig(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output_sig) {
    fbb_.AddOffset(Proposal_Message::VT_OUTPUT_SIG, output_sig);
  }
  void add_state_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> state_hash) {
    fbb_.AddOffset(Proposal_Message::VT_STATE_HASH, state_hash);
  }
  void add_patch_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> patch_hash) {
    fbb_.AddOffset(Proposal_Message::VT_PATCH_HASH, patch_hash);
  }
  explicit Proposal_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Proposal_MessageBuilder &operator=(const Proposal_MessageBuilder &);
  flatbuffers::Offset<Proposal_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Proposal_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Proposal_Message> CreateProposal_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t stage = 0,
    uint64_t time = 0,
    uint32_t roundtime = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> nonce = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>>> users = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>>> input_hashes = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output_hash = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output_sig = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> state_hash = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> patch_hash = 0) {
  Proposal_MessageBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_patch_hash(patch_hash);
  builder_.add_state_hash(state_hash);
  builder_.add_output_sig(output_sig);
  builder_.add_output_hash(output_hash);
  builder_.add_input_hashes(input_hashes);
  builder_.add_users(users);
  builder_.add_nonce(nonce);
  builder_.add_roundtime(roundtime);
  builder_.add_stage(stage);
  return builder_.Finish();
}

inline flatbuffers::Offset<Proposal_Message> CreateProposal_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t stage = 0,
    uint64_t time = 0,
    uint32_t roundtime = 0,
    const std::vector<uint8_t> *nonce = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *users = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *input_hashes = nullptr,
    const std::vector<uint8_t> *output_hash = nullptr,
    const std::vector<uint8_t> *output_sig = nullptr,
    const std::vector<uint8_t> *state_hash = nullptr,
    const std::vector<uint8_t> *patch_hash = nullptr) {
  auto nonce__ = nonce ? _fbb.CreateVector<uint8_t>(*nonce) : 0;
  auto users__ = users ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::ByteArray>>(*users) : 0;
  auto input_hashes__ = input_hashes ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::ByteArray>>(*input_hashes) : 0;
  auto output_hash__ = output_hash ? _fbb.CreateVector<uint8_t>(*output_hash) : 0;
  auto output_sig__ = output_sig ? _fbb.CreateVector<uint8_t>(*output_sig) : 0;
  auto state_hash__ = state_hash ? _fbb.CreateVector<uint8_t>(*state_hash) : 0;
  auto patch_hash__ = patch_hash ? _fbb.CreateVector<uint8_t>(*patch_hash) : 0;
  return msg::fbuf::p2pmsg::CreateProposal_Message(
      _fbb,
      stage,
      time,
      roundtime,
      nonce__,
      users__,
      input_hashes__,
      output_hash__,
      output_sig__,
      state_hash__,
      patch_hash__);
}

struct Npl_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Npl_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct Npl_MessageBuilder {
  typedef Npl_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Npl_Message::VT_DATA, data);
  }
  explicit Npl_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Npl_MessageBuilder &operator=(const Npl_MessageBuilder &);
  flatbuffers::Offset<Npl_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Npl_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Npl_Message> CreateNpl_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  Npl_MessageBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Npl_Message> CreateNpl_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return msg::fbuf::p2pmsg::CreateNpl_Message(
      _fbb,
      data__);
}

struct History_Request_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef History_Request_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUIRED_LCL = 4
  };
  const flatbuffers::Vector<uint8_t> *required_lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_REQUIRED_LCL);
  }
  flatbuffers::Vector<uint8_t> *mutable_required_lcl() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_REQUIRED_LCL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REQUIRED_LCL) &&
           verifier.VerifyVector(required_lcl()) &&
           verifier.EndTable();
  }
};

struct History_Request_MessageBuilder {
  typedef History_Request_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_required_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> required_lcl) {
    fbb_.AddOffset(History_Request_Message::VT_REQUIRED_LCL, required_lcl);
  }
  explicit History_Request_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  History_Request_MessageBuilder &operator=(const History_Request_MessageBuilder &);
  flatbuffers::Offset<History_Request_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<History_Request_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<History_Request_Message> CreateHistory_Request_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> required_lcl = 0) {
  History_Request_MessageBuilder builder_(_fbb);
  builder_.add_required_lcl(required_lcl);
  return builder_.Finish();
}

inline flatbuffers::Offset<History_Request_Message> CreateHistory_Request_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *required_lcl = nullptr) {
  auto required_lcl__ = required_lcl ? _fbb.CreateVector<uint8_t>(*required_lcl) : 0;
  return msg::fbuf::p2pmsg::CreateHistory_Request_Message(
      _fbb,
      required_lcl__);
}

struct History_Response_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef History_Response_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUESTER_LCL = 4,
    VT_HIST_LEDGER_BLOCKS = 6,
    VT_ERROR = 8
  };
  const flatbuffers::Vector<uint8_t> *requester_lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_REQUESTER_LCL);
  }
  flatbuffers::Vector<uint8_t> *mutable_requester_lcl() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_REQUESTER_LCL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HistoryLedgerBlockPair>> *hist_ledger_blocks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HistoryLedgerBlockPair>> *>(VT_HIST_LEDGER_BLOCKS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HistoryLedgerBlockPair>> *mutable_hist_ledger_blocks() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HistoryLedgerBlockPair>> *>(VT_HIST_LEDGER_BLOCKS);
  }
  msg::fbuf::p2pmsg::Ledger_Response_Error error() const {
    return static_cast<msg::fbuf::p2pmsg::Ledger_Response_Error>(GetField<uint8_t>(VT_ERROR, 0));
  }
  bool mutate_error(msg::fbuf::p2pmsg::Ledger_Response_Error _error) {
    return SetField<uint8_t>(VT_ERROR, static_cast<uint8_t>(_error), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REQUESTER_LCL) &&
           verifier.VerifyVector(requester_lcl()) &&
           VerifyOffset(verifier, VT_HIST_LEDGER_BLOCKS) &&
           verifier.VerifyVector(hist_ledger_blocks()) &&
           verifier.VerifyVectorOfTables(hist_ledger_blocks()) &&
           VerifyField<uint8_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct History_Response_MessageBuilder {
  typedef History_Response_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_requester_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> requester_lcl) {
    fbb_.AddOffset(History_Response_Message::VT_REQUESTER_LCL, requester_lcl);
  }
  void add_hist_ledger_blocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HistoryLedgerBlockPair>>> hist_ledger_blocks) {
    fbb_.AddOffset(History_Response_Message::VT_HIST_LEDGER_BLOCKS, hist_ledger_blocks);
  }
  void add_error(msg::fbuf::p2pmsg::Ledger_Response_Error error) {
    fbb_.AddElement<uint8_t>(History_Response_Message::VT_ERROR, static_cast<uint8_t>(error), 0);
  }
  explicit History_Response_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  History_Response_MessageBuilder &operator=(const History_Response_MessageBuilder &);
  flatbuffers::Offset<History_Response_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<History_Response_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<History_Response_Message> CreateHistory_Response_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> requester_lcl = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HistoryLedgerBlockPair>>> hist_ledger_blocks = 0,
    msg::fbuf::p2pmsg::Ledger_Response_Error error = msg::fbuf::p2pmsg::Ledger_Response_Error_None) {
  History_Response_MessageBuilder builder_(_fbb);
  builder_.add_hist_ledger_blocks(hist_ledger_blocks);
  builder_.add_requester_lcl(requester_lcl);
  builder_.add_error(error);
  return builder_.Finish();
}

inline flatbuffers::Offset<History_Response_Message> CreateHistory_Response_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *requester_lcl = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::p2pmsg::HistoryLedgerBlockPair>> *hist_ledger_blocks = nullptr,
    msg::fbuf::p2pmsg::Ledger_Response_Error error = msg::fbuf::p2pmsg::Ledger_Response_Error_None) {
  auto requester_lcl__ = requester_lcl ? _fbb.CreateVector<uint8_t>(*requester_lcl) : 0;
  auto hist_ledger_blocks__ = hist_ledger_blocks ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::p2pmsg::HistoryLedgerBlockPair>>(*hist_ledger_blocks) : 0;
  return msg::fbuf::p2pmsg::CreateHistory_Response_Message(
      _fbb,
      requester_lcl__,
      hist_ledger_blocks__,
      error);
}

struct HistoryLedgerBlockPair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HistoryLedgerBlockPairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ_NO = 4,
    VT_LEDGER = 6
  };
  uint64_t seq_no() const {
    return GetField<uint64_t>(VT_SEQ_NO, 0);
  }
  bool mutate_seq_no(uint64_t _seq_no) {
    return SetField<uint64_t>(VT_SEQ_NO, _seq_no, 0);
  }
  const msg::fbuf::p2pmsg::HistoryLedgerBlock *ledger() const {
    return GetPointer<const msg::fbuf::p2pmsg::HistoryLedgerBlock *>(VT_LEDGER);
  }
  msg::fbuf::p2pmsg::HistoryLedgerBlock *mutable_ledger() {
    return GetPointer<msg::fbuf::p2pmsg::HistoryLedgerBlock *>(VT_LEDGER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SEQ_NO) &&
           VerifyOffset(verifier, VT_LEDGER) &&
           verifier.VerifyTable(ledger()) &&
           verifier.EndTable();
  }
};

struct HistoryLedgerBlockPairBuilder {
  typedef HistoryLedgerBlockPair Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_no(uint64_t seq_no) {
    fbb_.AddElement<uint64_t>(HistoryLedgerBlockPair::VT_SEQ_NO, seq_no, 0);
  }
  void add_ledger(flatbuffers::Offset<msg::fbuf::p2pmsg::HistoryLedgerBlock> ledger) {
    fbb_.AddOffset(HistoryLedgerBlockPair::VT_LEDGER, ledger);
  }
  explicit HistoryLedgerBlockPairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HistoryLedgerBlockPairBuilder &operator=(const HistoryLedgerBlockPairBuilder &);
  flatbuffers::Offset<HistoryLedgerBlockPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HistoryLedgerBlockPair>(end);
    return o;
  }
};

inline flatbuffers::Offset<HistoryLedgerBlockPair> CreateHistoryLedgerBlockPair(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq_no = 0,
    flatbuffers::Offset<msg::fbuf::p2pmsg::HistoryLedgerBlock> ledger = 0) {
  HistoryLedgerBlockPairBuilder builder_(_fbb);
  builder_.add_seq_no(seq_no);
  builder_.add_ledger(ledger);
  return builder_.Finish();
}

struct HistoryLedgerBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HistoryLedgerBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LCL = 4,
    VT_BLOCK_BUFFER = 6
  };
  const flatbuffers::Vector<uint8_t> *lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  flatbuffers::Vector<uint8_t> *mutable_lcl() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  const flatbuffers::Vector<uint8_t> *block_buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BLOCK_BUFFER);
  }
  flatbuffers::Vector<uint8_t> *mutable_block_buffer() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_BLOCK_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LCL) &&
           verifier.VerifyVector(lcl()) &&
           VerifyOffset(verifier, VT_BLOCK_BUFFER) &&
           verifier.VerifyVector(block_buffer()) &&
           verifier.EndTable();
  }
};

struct HistoryLedgerBlockBuilder {
  typedef HistoryLedgerBlock Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl) {
    fbb_.AddOffset(HistoryLedgerBlock::VT_LCL, lcl);
  }
  void add_block_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> block_buffer) {
    fbb_.AddOffset(HistoryLedgerBlock::VT_BLOCK_BUFFER, block_buffer);
  }
  explicit HistoryLedgerBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HistoryLedgerBlockBuilder &operator=(const HistoryLedgerBlockBuilder &);
  flatbuffers::Offset<HistoryLedgerBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HistoryLedgerBlock>(end);
    return o;
  }
};

inline flatbuffers::Offset<HistoryLedgerBlock> CreateHistoryLedgerBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> block_buffer = 0) {
  HistoryLedgerBlockBuilder builder_(_fbb);
  builder_.add_block_buffer(block_buffer);
  builder_.add_lcl(lcl);
  return builder_.Finish();
}

inline flatbuffers::Offset<HistoryLedgerBlock> CreateHistoryLedgerBlockDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *lcl = nullptr,
    const std::vector<uint8_t> *block_buffer = nullptr) {
  auto lcl__ = lcl ? _fbb.CreateVector<uint8_t>(*lcl) : 0;
  auto block_buffer__ = block_buffer ? _fbb.CreateVector<uint8_t>(*block_buffer) : 0;
  return msg::fbuf::p2pmsg::CreateHistoryLedgerBlock(
      _fbb,
      lcl__,
      block_buffer__);
}

struct Hpfs_Request_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Hpfs_Request_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOUNT_ID = 4,
    VT_PARENT_PATH = 6,
    VT_IS_FILE = 8,
    VT_BLOCK_ID = 10,
    VT_EXPECTED_HASH = 12
  };
  uint32_t mount_id() const {
    return GetField<uint32_t>(VT_MOUNT_ID, 0);
  }
  bool mutate_mount_id(uint32_t _mount_id) {
    return SetField<uint32_t>(VT_MOUNT_ID, _mount_id, 0);
  }
  const flatbuffers::String *parent_path() const {
    return GetPointer<const flatbuffers::String *>(VT_PARENT_PATH);
  }
  flatbuffers::String *mutable_parent_path() {
    return GetPointer<flatbuffers::String *>(VT_PARENT_PATH);
  }
  bool is_file() const {
    return GetField<uint8_t>(VT_IS_FILE, 0) != 0;
  }
  bool mutate_is_file(bool _is_file) {
    return SetField<uint8_t>(VT_IS_FILE, static_cast<uint8_t>(_is_file), 0);
  }
  int32_t block_id() const {
    return GetField<int32_t>(VT_BLOCK_ID, 0);
  }
  bool mutate_block_id(int32_t _block_id) {
    return SetField<int32_t>(VT_BLOCK_ID, _block_id, 0);
  }
  const flatbuffers::Vector<uint8_t> *expected_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_EXPECTED_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_expected_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_EXPECTED_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MOUNT_ID) &&
           VerifyOffset(verifier, VT_PARENT_PATH) &&
           verifier.VerifyString(parent_path()) &&
           VerifyField<uint8_t>(verifier, VT_IS_FILE) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_ID) &&
           VerifyOffset(verifier, VT_EXPECTED_HASH) &&
           verifier.VerifyVector(expected_hash()) &&
           verifier.EndTable();
  }
};

struct Hpfs_Request_MessageBuilder {
  typedef Hpfs_Request_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mount_id(uint32_t mount_id) {
    fbb_.AddElement<uint32_t>(Hpfs_Request_Message::VT_MOUNT_ID, mount_id, 0);
  }
  void add_parent_path(flatbuffers::Offset<flatbuffers::String> parent_path) {
    fbb_.AddOffset(Hpfs_Request_Message::VT_PARENT_PATH, parent_path);
  }
  void add_is_file(bool is_file) {
    fbb_.AddElement<uint8_t>(Hpfs_Request_Message::VT_IS_FILE, static_cast<uint8_t>(is_file), 0);
  }
  void add_block_id(int32_t block_id) {
    fbb_.AddElement<int32_t>(Hpfs_Request_Message::VT_BLOCK_ID, block_id, 0);
  }
  void add_expected_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> expected_hash) {
    fbb_.AddOffset(Hpfs_Request_Message::VT_EXPECTED_HASH, expected_hash);
  }
  explicit Hpfs_Request_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Hpfs_Request_MessageBuilder &operator=(const Hpfs_Request_MessageBuilder &);
  flatbuffers::Offset<Hpfs_Request_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Hpfs_Request_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hpfs_Request_Message> CreateHpfs_Request_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t mount_id = 0,
    flatbuffers::Offset<flatbuffers::String> parent_path = 0,
    bool is_file = false,
    int32_t block_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> expected_hash = 0) {
  Hpfs_Request_MessageBuilder builder_(_fbb);
  builder_.add_expected_hash(expected_hash);
  builder_.add_block_id(block_id);
  builder_.add_parent_path(parent_path);
  builder_.add_mount_id(mount_id);
  builder_.add_is_file(is_file);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hpfs_Request_Message> CreateHpfs_Request_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t mount_id = 0,
    const char *parent_path = nullptr,
    bool is_file = false,
    int32_t block_id = 0,
    const std::vector<uint8_t> *expected_hash = nullptr) {
  auto parent_path__ = parent_path ? _fbb.CreateString(parent_path) : 0;
  auto expected_hash__ = expected_hash ? _fbb.CreateVector<uint8_t>(*expected_hash) : 0;
  return msg::fbuf::p2pmsg::CreateHpfs_Request_Message(
      _fbb,
      mount_id,
      parent_path__,
      is_file,
      block_id,
      expected_hash__);
}

struct Hpfs_Response_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Hpfs_Response_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HPFS_RESPONSE_TYPE = 4,
    VT_HPFS_RESPONSE = 6,
    VT_HASH = 8,
    VT_PATH = 10,
    VT_MOUNT_ID = 12
  };
  msg::fbuf::p2pmsg::Hpfs_Response hpfs_response_type() const {
    return static_cast<msg::fbuf::p2pmsg::Hpfs_Response>(GetField<uint8_t>(VT_HPFS_RESPONSE_TYPE, 0));
  }
  const void *hpfs_response() const {
    return GetPointer<const void *>(VT_HPFS_RESPONSE);
  }
  template<typename T> const T *hpfs_response_as() const;
  const msg::fbuf::p2pmsg::File_HashMap_Response *hpfs_response_as_File_HashMap_Response() const {
    return hpfs_response_type() == msg::fbuf::p2pmsg::Hpfs_Response_File_HashMap_Response ? static_cast<const msg::fbuf::p2pmsg::File_HashMap_Response *>(hpfs_response()) : nullptr;
  }
  const msg::fbuf::p2pmsg::Block_Response *hpfs_response_as_Block_Response() const {
    return hpfs_response_type() == msg::fbuf::p2pmsg::Hpfs_Response_Block_Response ? static_cast<const msg::fbuf::p2pmsg::Block_Response *>(hpfs_response()) : nullptr;
  }
  const msg::fbuf::p2pmsg::Fs_Entry_Response *hpfs_response_as_Fs_Entry_Response() const {
    return hpfs_response_type() == msg::fbuf::p2pmsg::Hpfs_Response_Fs_Entry_Response ? static_cast<const msg::fbuf::p2pmsg::Fs_Entry_Response *>(hpfs_response()) : nullptr;
  }
  void *mutable_hpfs_response() {
    return GetPointer<void *>(VT_HPFS_RESPONSE);
  }
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  flatbuffers::String *mutable_path() {
    return GetPointer<flatbuffers::String *>(VT_PATH);
  }
  uint32_t mount_id() const {
    return GetField<uint32_t>(VT_MOUNT_ID, 0);
  }
  bool mutate_mount_id(uint32_t _mount_id) {
    return SetField<uint32_t>(VT_MOUNT_ID, _mount_id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HPFS_RESPONSE_TYPE) &&
           VerifyOffset(verifier, VT_HPFS_RESPONSE) &&
           VerifyHpfs_Response(verifier, hpfs_response(), hpfs_response_type()) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyVector(hash()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyField<uint32_t>(verifier, VT_MOUNT_ID) &&
           verifier.EndTable();
  }
};

template<> inline const msg::fbuf::p2pmsg::File_HashMap_Response *Hpfs_Response_Message::hpfs_response_as<msg::fbuf::p2pmsg::File_HashMap_Response>() const {
  return hpfs_response_as_File_HashMap_Response();
}

template<> inline const msg::fbuf::p2pmsg::Block_Response *Hpfs_Response_Message::hpfs_response_as<msg::fbuf::p2pmsg::Block_Response>() const {
  return hpfs_response_as_Block_Response();
}

template<> inline const msg::fbuf::p2pmsg::Fs_Entry_Response *Hpfs_Response_Message::hpfs_response_as<msg::fbuf::p2pmsg::Fs_Entry_Response>() const {
  return hpfs_response_as_Fs_Entry_Response();
}

struct Hpfs_Response_MessageBuilder {
  typedef Hpfs_Response_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hpfs_response_type(msg::fbuf::p2pmsg::Hpfs_Response hpfs_response_type) {
    fbb_.AddElement<uint8_t>(Hpfs_Response_Message::VT_HPFS_RESPONSE_TYPE, static_cast<uint8_t>(hpfs_response_type), 0);
  }
  void add_hpfs_response(flatbuffers::Offset<void> hpfs_response) {
    fbb_.AddOffset(Hpfs_Response_Message::VT_HPFS_RESPONSE, hpfs_response);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(Hpfs_Response_Message::VT_HASH, hash);
  }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(Hpfs_Response_Message::VT_PATH, path);
  }
  void add_mount_id(uint32_t mount_id) {
    fbb_.AddElement<uint32_t>(Hpfs_Response_Message::VT_MOUNT_ID, mount_id, 0);
  }
  explicit Hpfs_Response_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Hpfs_Response_MessageBuilder &operator=(const Hpfs_Response_MessageBuilder &);
  flatbuffers::Offset<Hpfs_Response_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Hpfs_Response_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hpfs_Response_Message> CreateHpfs_Response_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    msg::fbuf::p2pmsg::Hpfs_Response hpfs_response_type = msg::fbuf::p2pmsg::Hpfs_Response_NONE,
    flatbuffers::Offset<void> hpfs_response = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    uint32_t mount_id = 0) {
  Hpfs_Response_MessageBuilder builder_(_fbb);
  builder_.add_mount_id(mount_id);
  builder_.add_path(path);
  builder_.add_hash(hash);
  builder_.add_hpfs_response(hpfs_response);
  builder_.add_hpfs_response_type(hpfs_response_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hpfs_Response_Message> CreateHpfs_Response_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    msg::fbuf::p2pmsg::Hpfs_Response hpfs_response_type = msg::fbuf::p2pmsg::Hpfs_Response_NONE,
    flatbuffers::Offset<void> hpfs_response = 0,
    const std::vector<uint8_t> *hash = nullptr,
    const char *path = nullptr,
    uint32_t mount_id = 0) {
  auto hash__ = hash ? _fbb.CreateVector<uint8_t>(*hash) : 0;
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return msg::fbuf::p2pmsg::CreateHpfs_Response_Message(
      _fbb,
      hpfs_response_type,
      hpfs_response,
      hash__,
      path__,
      mount_id);
}

struct Fs_Entry_Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Fs_Entry_ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Hpfs_FS_Hash_Entry>> *entries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Hpfs_FS_Hash_Entry>> *>(VT_ENTRIES);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Hpfs_FS_Hash_Entry>> *mutable_entries() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Hpfs_FS_Hash_Entry>> *>(VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfTables(entries()) &&
           verifier.EndTable();
  }
};

struct Fs_Entry_ResponseBuilder {
  typedef Fs_Entry_Response Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Hpfs_FS_Hash_Entry>>> entries) {
    fbb_.AddOffset(Fs_Entry_Response::VT_ENTRIES, entries);
  }
  explicit Fs_Entry_ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Fs_Entry_ResponseBuilder &operator=(const Fs_Entry_ResponseBuilder &);
  flatbuffers::Offset<Fs_Entry_Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fs_Entry_Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fs_Entry_Response> CreateFs_Entry_Response(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Hpfs_FS_Hash_Entry>>> entries = 0) {
  Fs_Entry_ResponseBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fs_Entry_Response> CreateFs_Entry_ResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Hpfs_FS_Hash_Entry>> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::p2pmsg::Hpfs_FS_Hash_Entry>>(*entries) : 0;
  return msg::fbuf::p2pmsg::CreateFs_Entry_Response(
      _fbb,
      entries__);
}

struct File_HashMap_Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef File_HashMap_ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_LENGTH = 4,
    VT_HASH_MAP = 6
  };
  uint64_t file_length() const {
    return GetField<uint64_t>(VT_FILE_LENGTH, 0);
  }
  bool mutate_file_length(uint64_t _file_length) {
    return SetField<uint64_t>(VT_FILE_LENGTH, _file_length, 0);
  }
  const flatbuffers::Vector<uint8_t> *hash_map() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH_MAP);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash_map() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FILE_LENGTH) &&
           VerifyOffset(verifier, VT_HASH_MAP) &&
           verifier.VerifyVector(hash_map()) &&
           verifier.EndTable();
  }
};

struct File_HashMap_ResponseBuilder {
  typedef File_HashMap_Response Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file_length(uint64_t file_length) {
    fbb_.AddElement<uint64_t>(File_HashMap_Response::VT_FILE_LENGTH, file_length, 0);
  }
  void add_hash_map(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash_map) {
    fbb_.AddOffset(File_HashMap_Response::VT_HASH_MAP, hash_map);
  }
  explicit File_HashMap_ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  File_HashMap_ResponseBuilder &operator=(const File_HashMap_ResponseBuilder &);
  flatbuffers::Offset<File_HashMap_Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<File_HashMap_Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<File_HashMap_Response> CreateFile_HashMap_Response(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t file_length = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash_map = 0) {
  File_HashMap_ResponseBuilder builder_(_fbb);
  builder_.add_file_length(file_length);
  builder_.add_hash_map(hash_map);
  return builder_.Finish();
}

inline flatbuffers::Offset<File_HashMap_Response> CreateFile_HashMap_ResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t file_length = 0,
    const std::vector<uint8_t> *hash_map = nullptr) {
  auto hash_map__ = hash_map ? _fbb.CreateVector<uint8_t>(*hash_map) : 0;
  return msg::fbuf::p2pmsg::CreateFile_HashMap_Response(
      _fbb,
      file_length,
      hash_map__);
}

struct Block_Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Block_ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_ID = 4,
    VT_DATA = 6
  };
  uint32_t block_id() const {
    return GetField<uint32_t>(VT_BLOCK_ID, 0);
  }
  bool mutate_block_id(uint32_t _block_id) {
    return SetField<uint32_t>(VT_BLOCK_ID, _block_id, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BLOCK_ID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct Block_ResponseBuilder {
  typedef Block_Response Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_id(uint32_t block_id) {
    fbb_.AddElement<uint32_t>(Block_Response::VT_BLOCK_ID, block_id, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Block_Response::VT_DATA, data);
  }
  explicit Block_ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Block_ResponseBuilder &operator=(const Block_ResponseBuilder &);
  flatbuffers::Offset<Block_Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Block_Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Block_Response> CreateBlock_Response(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t block_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  Block_ResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_block_id(block_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Block_Response> CreateBlock_ResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t block_id = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return msg::fbuf::p2pmsg::CreateBlock_Response(
      _fbb,
      block_id,
      data__);
}

struct Hpfs_FS_Hash_Entry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Hpfs_FS_Hash_EntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_IS_FILE = 6,
    VT_HASH = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool is_file() const {
    return GetField<uint8_t>(VT_IS_FILE, 0) != 0;
  }
  bool mutate_is_file(bool _is_file) {
    return SetField<uint8_t>(VT_IS_FILE, static_cast<uint8_t>(_is_file), 0);
  }
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_IS_FILE) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyVector(hash()) &&
           verifier.EndTable();
  }
};

struct Hpfs_FS_Hash_EntryBuilder {
  typedef Hpfs_FS_Hash_Entry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Hpfs_FS_Hash_Entry::VT_NAME, name);
  }
  void add_is_file(bool is_file) {
    fbb_.AddElement<uint8_t>(Hpfs_FS_Hash_Entry::VT_IS_FILE, static_cast<uint8_t>(is_file), 0);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(Hpfs_FS_Hash_Entry::VT_HASH, hash);
  }
  explicit Hpfs_FS_Hash_EntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Hpfs_FS_Hash_EntryBuilder &operator=(const Hpfs_FS_Hash_EntryBuilder &);
  flatbuffers::Offset<Hpfs_FS_Hash_Entry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Hpfs_FS_Hash_Entry>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hpfs_FS_Hash_Entry> CreateHpfs_FS_Hash_Entry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool is_file = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0) {
  Hpfs_FS_Hash_EntryBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_name(name);
  builder_.add_is_file(is_file);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hpfs_FS_Hash_Entry> CreateHpfs_FS_Hash_EntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool is_file = false,
    const std::vector<uint8_t> *hash = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto hash__ = hash ? _fbb.CreateVector<uint8_t>(*hash) : 0;
  return msg::fbuf::p2pmsg::CreateHpfs_FS_Hash_Entry(
      _fbb,
      name__,
      is_file,
      hash__);
}

struct Peer_Requirement_Announcement_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Peer_Requirement_Announcement_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEED_CONSENSUS_MSG_FORWARDING = 4
  };
  bool need_consensus_msg_forwarding() const {
    return GetField<uint8_t>(VT_NEED_CONSENSUS_MSG_FORWARDING, 0) != 0;
  }
  bool mutate_need_consensus_msg_forwarding(bool _need_consensus_msg_forwarding) {
    return SetField<uint8_t>(VT_NEED_CONSENSUS_MSG_FORWARDING, static_cast<uint8_t>(_need_consensus_msg_forwarding), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NEED_CONSENSUS_MSG_FORWARDING) &&
           verifier.EndTable();
  }
};

struct Peer_Requirement_Announcement_MessageBuilder {
  typedef Peer_Requirement_Announcement_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_need_consensus_msg_forwarding(bool need_consensus_msg_forwarding) {
    fbb_.AddElement<uint8_t>(Peer_Requirement_Announcement_Message::VT_NEED_CONSENSUS_MSG_FORWARDING, static_cast<uint8_t>(need_consensus_msg_forwarding), 0);
  }
  explicit Peer_Requirement_Announcement_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Peer_Requirement_Announcement_MessageBuilder &operator=(const Peer_Requirement_Announcement_MessageBuilder &);
  flatbuffers::Offset<Peer_Requirement_Announcement_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Peer_Requirement_Announcement_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Peer_Requirement_Announcement_Message> CreatePeer_Requirement_Announcement_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool need_consensus_msg_forwarding = false) {
  Peer_Requirement_Announcement_MessageBuilder builder_(_fbb);
  builder_.add_need_consensus_msg_forwarding(need_consensus_msg_forwarding);
  return builder_.Finish();
}

struct Available_Capacity_Announcement_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Available_Capacity_Announcement_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AVAILABLE_CAPACITY = 4,
    VT_TIMESTAMP = 6
  };
  int16_t available_capacity() const {
    return GetField<int16_t>(VT_AVAILABLE_CAPACITY, 0);
  }
  bool mutate_available_capacity(int16_t _available_capacity) {
    return SetField<int16_t>(VT_AVAILABLE_CAPACITY, _available_capacity, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_AVAILABLE_CAPACITY) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct Available_Capacity_Announcement_MessageBuilder {
  typedef Available_Capacity_Announcement_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_available_capacity(int16_t available_capacity) {
    fbb_.AddElement<int16_t>(Available_Capacity_Announcement_Message::VT_AVAILABLE_CAPACITY, available_capacity, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Available_Capacity_Announcement_Message::VT_TIMESTAMP, timestamp, 0);
  }
  explicit Available_Capacity_Announcement_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Available_Capacity_Announcement_MessageBuilder &operator=(const Available_Capacity_Announcement_MessageBuilder &);
  flatbuffers::Offset<Available_Capacity_Announcement_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Available_Capacity_Announcement_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Available_Capacity_Announcement_Message> CreateAvailable_Capacity_Announcement_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t available_capacity = 0,
    uint64_t timestamp = 0) {
  Available_Capacity_Announcement_MessageBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_available_capacity(available_capacity);
  return builder_.Finish();
}

struct Peer_List_Request_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Peer_List_Request_MessageBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct Peer_List_Request_MessageBuilder {
  typedef Peer_List_Request_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Peer_List_Request_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Peer_List_Request_MessageBuilder &operator=(const Peer_List_Request_MessageBuilder &);
  flatbuffers::Offset<Peer_List_Request_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Peer_List_Request_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Peer_List_Request_Message> CreatePeer_List_Request_Message(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Peer_List_Request_MessageBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Peer_List_Response_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Peer_List_Response_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEER_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Peer_Properties>> *peer_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Peer_Properties>> *>(VT_PEER_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Peer_Properties>> *mutable_peer_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Peer_Properties>> *>(VT_PEER_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PEER_LIST) &&
           verifier.VerifyVector(peer_list()) &&
           verifier.VerifyVectorOfTables(peer_list()) &&
           verifier.EndTable();
  }
};

struct Peer_List_Response_MessageBuilder {
  typedef Peer_List_Response_Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peer_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Peer_Properties>>> peer_list) {
    fbb_.AddOffset(Peer_List_Response_Message::VT_PEER_LIST, peer_list);
  }
  explicit Peer_List_Response_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Peer_List_Response_MessageBuilder &operator=(const Peer_List_Response_MessageBuilder &);
  flatbuffers::Offset<Peer_List_Response_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Peer_List_Response_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Peer_List_Response_Message> CreatePeer_List_Response_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Peer_Properties>>> peer_list = 0) {
  Peer_List_Response_MessageBuilder builder_(_fbb);
  builder_.add_peer_list(peer_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<Peer_List_Response_Message> CreatePeer_List_Response_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<msg::fbuf::p2pmsg::Peer_Properties>> *peer_list = nullptr) {
  auto peer_list__ = peer_list ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::p2pmsg::Peer_Properties>>(*peer_list) : 0;
  return msg::fbuf::p2pmsg::CreatePeer_List_Response_Message(
      _fbb,
      peer_list__);
}

struct Peer_Properties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Peer_PropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOST_ADDRESS = 4,
    VT_PORT = 6,
    VT_AVAILABLE_CAPACITY = 8,
    VT_TIMESTAMP = 10
  };
  const flatbuffers::String *host_address() const {
    return GetPointer<const flatbuffers::String *>(VT_HOST_ADDRESS);
  }
  flatbuffers::String *mutable_host_address() {
    return GetPointer<flatbuffers::String *>(VT_HOST_ADDRESS);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool mutate_port(uint16_t _port) {
    return SetField<uint16_t>(VT_PORT, _port, 0);
  }
  int16_t available_capacity() const {
    return GetField<int16_t>(VT_AVAILABLE_CAPACITY, 0);
  }
  bool mutate_available_capacity(int16_t _available_capacity) {
    return SetField<int16_t>(VT_AVAILABLE_CAPACITY, _available_capacity, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HOST_ADDRESS) &&
           verifier.VerifyString(host_address()) &&
           VerifyField<uint16_t>(verifier, VT_PORT) &&
           VerifyField<int16_t>(verifier, VT_AVAILABLE_CAPACITY) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct Peer_PropertiesBuilder {
  typedef Peer_Properties Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_host_address(flatbuffers::Offset<flatbuffers::String> host_address) {
    fbb_.AddOffset(Peer_Properties::VT_HOST_ADDRESS, host_address);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(Peer_Properties::VT_PORT, port, 0);
  }
  void add_available_capacity(int16_t available_capacity) {
    fbb_.AddElement<int16_t>(Peer_Properties::VT_AVAILABLE_CAPACITY, available_capacity, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Peer_Properties::VT_TIMESTAMP, timestamp, 0);
  }
  explicit Peer_PropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Peer_PropertiesBuilder &operator=(const Peer_PropertiesBuilder &);
  flatbuffers::Offset<Peer_Properties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Peer_Properties>(end);
    return o;
  }
};

inline flatbuffers::Offset<Peer_Properties> CreatePeer_Properties(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> host_address = 0,
    uint16_t port = 0,
    int16_t available_capacity = 0,
    uint64_t timestamp = 0) {
  Peer_PropertiesBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_host_address(host_address);
  builder_.add_available_capacity(available_capacity);
  builder_.add_port(port);
  return builder_.Finish();
}

inline flatbuffers::Offset<Peer_Properties> CreatePeer_PropertiesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *host_address = nullptr,
    uint16_t port = 0,
    int16_t available_capacity = 0,
    uint64_t timestamp = 0) {
  auto host_address__ = host_address ? _fbb.CreateString(host_address) : 0;
  return msg::fbuf::p2pmsg::CreatePeer_Properties(
      _fbb,
      host_address__,
      port,
      available_capacity,
      timestamp);
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_Peer_Challenge_Response_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Peer_Challenge_Response_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Peer_Challenge_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Peer_Challenge_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_NonUnl_Proposal_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::NonUnl_Proposal_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Proposal_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Proposal_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Npl_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Npl_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Hpfs_Request_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Hpfs_Request_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Hpfs_Response_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Hpfs_Response_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_History_Request_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::History_Request_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_History_Response_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::History_Response_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Peer_Requirement_Announcement_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Peer_Requirement_Announcement_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Peer_List_Request_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Peer_List_Request_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Peer_List_Response_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Peer_List_Response_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Available_Capacity_Announcement_Message: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Available_Capacity_Announcement_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyHpfs_Response(flatbuffers::Verifier &verifier, const void *obj, Hpfs_Response type) {
  switch (type) {
    case Hpfs_Response_NONE: {
      return true;
    }
    case Hpfs_Response_File_HashMap_Response: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::File_HashMap_Response *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Hpfs_Response_Block_Response: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Block_Response *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Hpfs_Response_Fs_Entry_Response: {
      auto ptr = reinterpret_cast<const msg::fbuf::p2pmsg::Fs_Entry_Response *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyHpfs_ResponseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyHpfs_Response(
        verifier,  values->Get(i), types->GetEnum<Hpfs_Response>(i))) {
      return false;
    }
  }
  return true;
}

inline const msg::fbuf::p2pmsg::Content *GetContent(const void *buf) {
  return flatbuffers::GetRoot<msg::fbuf::p2pmsg::Content>(buf);
}

inline const msg::fbuf::p2pmsg::Content *GetSizePrefixedContent(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<msg::fbuf::p2pmsg::Content>(buf);
}

inline Content *GetMutableContent(void *buf) {
  return flatbuffers::GetMutableRoot<Content>(buf);
}

inline bool VerifyContentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<msg::fbuf::p2pmsg::Content>(nullptr);
}

inline bool VerifySizePrefixedContentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<msg::fbuf::p2pmsg::Content>(nullptr);
}

inline void FinishContentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<msg::fbuf::p2pmsg::Content> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedContentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<msg::fbuf::p2pmsg::Content> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace p2pmsg
}  // namespace fbuf
}  // namespace msg

#endif  // FLATBUFFERS_GENERATED_P2PMSGCONTENT_MSG_FBUF_P2PMSG_H_
