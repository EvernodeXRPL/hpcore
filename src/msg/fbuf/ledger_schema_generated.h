// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LEDGERSCHEMA_MSG_FBUF_LEDGER_H_
#define FLATBUFFERS_GENERATED_LEDGERSCHEMA_MSG_FBUF_LEDGER_H_

#include "flatbuffers/flatbuffers.h"

#include "common_schema_generated.h"

namespace msg {
namespace fbuf {
namespace ledger {

struct LedgerBlock;
struct LedgerBlockBuilder;

struct RawInput;
struct RawInputBuilder;

struct Input;
struct InputBuilder;

enum Input_Protocol {
  Input_Protocol_JSON = 0,
  Input_Protocol_BSON = 1,
  Input_Protocol_MIN = Input_Protocol_JSON,
  Input_Protocol_MAX = Input_Protocol_BSON
};

inline const Input_Protocol (&EnumValuesInput_Protocol())[2] {
  static const Input_Protocol values[] = {
    Input_Protocol_JSON,
    Input_Protocol_BSON
  };
  return values;
}

inline const char * const *EnumNamesInput_Protocol() {
  static const char * const names[3] = {
    "JSON",
    "BSON",
    nullptr
  };
  return names;
}

inline const char *EnumNameInput_Protocol(Input_Protocol e) {
  if (flatbuffers::IsOutRange(e, Input_Protocol_JSON, Input_Protocol_BSON)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInput_Protocol()[index];
}

struct LedgerBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LedgerBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ_NO = 4,
    VT_TIME = 6,
    VT_LCL = 8,
    VT_STATE = 10,
    VT_USERS = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS = 16,
    VT_RAW_INPUTS = 18
  };
  uint64_t seq_no() const {
    return GetField<uint64_t>(VT_SEQ_NO, 0);
  }
  bool mutate_seq_no(uint64_t _seq_no) {
    return SetField<uint64_t>(VT_SEQ_NO, _seq_no, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  const flatbuffers::Vector<uint8_t> *lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  flatbuffers::Vector<uint8_t> *mutable_lcl() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  const flatbuffers::Vector<uint8_t> *state() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_STATE);
  }
  flatbuffers::Vector<uint8_t> *mutable_state() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_STATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *users() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *>(VT_USERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *mutable_users() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *>(VT_USERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *>(VT_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *mutable_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *>(VT_OUTPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *mutable_outputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>> *raw_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>> *>(VT_RAW_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>> *mutable_raw_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>> *>(VT_RAW_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SEQ_NO) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_LCL) &&
           verifier.VerifyVector(lcl()) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyVector(state()) &&
           VerifyOffset(verifier, VT_USERS) &&
           verifier.VerifyVector(users()) &&
           verifier.VerifyVectorOfTables(users()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_RAW_INPUTS) &&
           verifier.VerifyVector(raw_inputs()) &&
           verifier.VerifyVectorOfTables(raw_inputs()) &&
           verifier.EndTable();
  }
};

struct LedgerBlockBuilder {
  typedef LedgerBlock Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_no(uint64_t seq_no) {
    fbb_.AddElement<uint64_t>(LedgerBlock::VT_SEQ_NO, seq_no, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(LedgerBlock::VT_TIME, time, 0);
  }
  void add_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl) {
    fbb_.AddOffset(LedgerBlock::VT_LCL, lcl);
  }
  void add_state(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> state) {
    fbb_.AddOffset(LedgerBlock::VT_STATE, state);
  }
  void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>>> users) {
    fbb_.AddOffset(LedgerBlock::VT_USERS, users);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>>> inputs) {
    fbb_.AddOffset(LedgerBlock::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>>> outputs) {
    fbb_.AddOffset(LedgerBlock::VT_OUTPUTS, outputs);
  }
  void add_raw_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>>> raw_inputs) {
    fbb_.AddOffset(LedgerBlock::VT_RAW_INPUTS, raw_inputs);
  }
  explicit LedgerBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LedgerBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LedgerBlock>(end);
    return o;
  }
};

inline flatbuffers::Offset<LedgerBlock> CreateLedgerBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq_no = 0,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> state = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>>> users = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ByteArray>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>>> raw_inputs = 0) {
  LedgerBlockBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_seq_no(seq_no);
  builder_.add_raw_inputs(raw_inputs);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_users(users);
  builder_.add_state(state);
  builder_.add_lcl(lcl);
  return builder_.Finish();
}

inline flatbuffers::Offset<LedgerBlock> CreateLedgerBlockDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq_no = 0,
    uint64_t time = 0,
    const std::vector<uint8_t> *lcl = nullptr,
    const std::vector<uint8_t> *state = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *users = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::ByteArray>> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>> *raw_inputs = nullptr) {
  auto lcl__ = lcl ? _fbb.CreateVector<uint8_t>(*lcl) : 0;
  auto state__ = state ? _fbb.CreateVector<uint8_t>(*state) : 0;
  auto users__ = users ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::ByteArray>>(*users) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::ByteArray>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::ByteArray>>(*outputs) : 0;
  auto raw_inputs__ = raw_inputs ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::ledger::RawInput>>(*raw_inputs) : 0;
  return msg::fbuf::ledger::CreateLedgerBlock(
      _fbb,
      seq_no,
      time,
      lcl__,
      state__,
      users__,
      inputs__,
      outputs__,
      raw_inputs__);
}

struct RawInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RawInputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH = 4,
    VT_INPUT = 6
  };
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  const msg::fbuf::ledger::Input *input() const {
    return GetPointer<const msg::fbuf::ledger::Input *>(VT_INPUT);
  }
  msg::fbuf::ledger::Input *mutable_input() {
    return GetPointer<msg::fbuf::ledger::Input *>(VT_INPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyVector(hash()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           verifier.EndTable();
  }
};

struct RawInputBuilder {
  typedef RawInput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(RawInput::VT_HASH, hash);
  }
  void add_input(flatbuffers::Offset<msg::fbuf::ledger::Input> input) {
    fbb_.AddOffset(RawInput::VT_INPUT, input);
  }
  explicit RawInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RawInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RawInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<RawInput> CreateRawInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0,
    flatbuffers::Offset<msg::fbuf::ledger::Input> input = 0) {
  RawInputBuilder builder_(_fbb);
  builder_.add_input(input);
  builder_.add_hash(hash);
  return builder_.Finish();
}

inline flatbuffers::Offset<RawInput> CreateRawInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *hash = nullptr,
    flatbuffers::Offset<msg::fbuf::ledger::Input> input = 0) {
  auto hash__ = hash ? _fbb.CreateVector<uint8_t>(*hash) : 0;
  return msg::fbuf::ledger::CreateRawInput(
      _fbb,
      hash__,
      input);
}

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_INPUT_CONTAINER = 6,
    VT_SIG = 8,
    VT_PROTOCOL = 10
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const flatbuffers::Vector<uint8_t> *input_container() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INPUT_CONTAINER);
  }
  flatbuffers::Vector<uint8_t> *mutable_input_container() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_INPUT_CONTAINER);
  }
  const flatbuffers::Vector<uint8_t> *sig() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  flatbuffers::Vector<uint8_t> *mutable_sig() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  msg::fbuf::ledger::Input_Protocol protocol() const {
    return static_cast<msg::fbuf::ledger::Input_Protocol>(GetField<uint8_t>(VT_PROTOCOL, 0));
  }
  bool mutate_protocol(msg::fbuf::ledger::Input_Protocol _protocol) {
    return SetField<uint8_t>(VT_PROTOCOL, static_cast<uint8_t>(_protocol), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_INPUT_CONTAINER) &&
           verifier.VerifyVector(input_container()) &&
           VerifyOffset(verifier, VT_SIG) &&
           verifier.VerifyVector(sig()) &&
           VerifyField<uint8_t>(verifier, VT_PROTOCOL) &&
           verifier.EndTable();
  }
};

struct InputBuilder {
  typedef Input Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(Input::VT_PUBKEY, pubkey);
  }
  void add_input_container(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_container) {
    fbb_.AddOffset(Input::VT_INPUT_CONTAINER, input_container);
  }
  void add_sig(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig) {
    fbb_.AddOffset(Input::VT_SIG, sig);
  }
  void add_protocol(msg::fbuf::ledger::Input_Protocol protocol) {
    fbb_.AddElement<uint8_t>(Input::VT_PROTOCOL, static_cast<uint8_t>(protocol), 0);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_container = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sig = 0,
    msg::fbuf::ledger::Input_Protocol protocol = msg::fbuf::ledger::Input_Protocol_JSON) {
  InputBuilder builder_(_fbb);
  builder_.add_sig(sig);
  builder_.add_input_container(input_container);
  builder_.add_pubkey(pubkey);
  builder_.add_protocol(protocol);
  return builder_.Finish();
}

inline flatbuffers::Offset<Input> CreateInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    const std::vector<uint8_t> *input_container = nullptr,
    const std::vector<uint8_t> *sig = nullptr,
    msg::fbuf::ledger::Input_Protocol protocol = msg::fbuf::ledger::Input_Protocol_JSON) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto input_container__ = input_container ? _fbb.CreateVector<uint8_t>(*input_container) : 0;
  auto sig__ = sig ? _fbb.CreateVector<uint8_t>(*sig) : 0;
  return msg::fbuf::ledger::CreateInput(
      _fbb,
      pubkey__,
      input_container__,
      sig__,
      protocol);
}

inline const msg::fbuf::ledger::LedgerBlock *GetLedgerBlock(const void *buf) {
  return flatbuffers::GetRoot<msg::fbuf::ledger::LedgerBlock>(buf);
}

inline const msg::fbuf::ledger::LedgerBlock *GetSizePrefixedLedgerBlock(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<msg::fbuf::ledger::LedgerBlock>(buf);
}

inline LedgerBlock *GetMutableLedgerBlock(void *buf) {
  return flatbuffers::GetMutableRoot<LedgerBlock>(buf);
}

inline bool VerifyLedgerBlockBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<msg::fbuf::ledger::LedgerBlock>(nullptr);
}

inline bool VerifySizePrefixedLedgerBlockBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<msg::fbuf::ledger::LedgerBlock>(nullptr);
}

inline void FinishLedgerBlockBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<msg::fbuf::ledger::LedgerBlock> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLedgerBlockBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<msg::fbuf::ledger::LedgerBlock> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace ledger
}  // namespace fbuf
}  // namespace msg

#endif  // FLATBUFFERS_GENERATED_LEDGERSCHEMA_MSG_FBUF_LEDGER_H_
