// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LEDGERBLOBSCHEMA_MSG_FBUF_LEDGERMSG_H_
#define FLATBUFFERS_GENERATED_LEDGERBLOBSCHEMA_MSG_FBUF_LEDGERMSG_H_

#include "flatbuffers/flatbuffers.h"

namespace msg {
namespace fbuf {
namespace ledgermsg {

struct LedgerBlob;
struct LedgerBlobBuilder;

struct RawInputCollection;
struct RawInputCollectionBuilder;

struct RawInput;
struct RawInputBuilder;

struct RawOutputCollection;
struct RawOutputCollectionBuilder;

struct RawOutput;
struct RawOutputBuilder;

struct LedgerBlob FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LedgerBlobBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEDGER_HASH = 4,
    VT_RAW_INPUTS = 6,
    VT_RAW_OUTPUTS = 8
  };
  const flatbuffers::Vector<uint8_t> *ledger_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LEDGER_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_ledger_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_LEDGER_HASH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInputCollection>> *raw_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInputCollection>> *>(VT_RAW_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInputCollection>> *mutable_raw_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInputCollection>> *>(VT_RAW_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutputCollection>> *raw_outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutputCollection>> *>(VT_RAW_OUTPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutputCollection>> *mutable_raw_outputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutputCollection>> *>(VT_RAW_OUTPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LEDGER_HASH) &&
           verifier.VerifyVector(ledger_hash()) &&
           VerifyOffset(verifier, VT_RAW_INPUTS) &&
           verifier.VerifyVector(raw_inputs()) &&
           verifier.VerifyVectorOfTables(raw_inputs()) &&
           VerifyOffset(verifier, VT_RAW_OUTPUTS) &&
           verifier.VerifyVector(raw_outputs()) &&
           verifier.VerifyVectorOfTables(raw_outputs()) &&
           verifier.EndTable();
  }
};

struct LedgerBlobBuilder {
  typedef LedgerBlob Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ledger_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ledger_hash) {
    fbb_.AddOffset(LedgerBlob::VT_LEDGER_HASH, ledger_hash);
  }
  void add_raw_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInputCollection>>> raw_inputs) {
    fbb_.AddOffset(LedgerBlob::VT_RAW_INPUTS, raw_inputs);
  }
  void add_raw_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutputCollection>>> raw_outputs) {
    fbb_.AddOffset(LedgerBlob::VT_RAW_OUTPUTS, raw_outputs);
  }
  explicit LedgerBlobBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LedgerBlob> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LedgerBlob>(end);
    return o;
  }
};

inline flatbuffers::Offset<LedgerBlob> CreateLedgerBlob(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ledger_hash = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInputCollection>>> raw_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutputCollection>>> raw_outputs = 0) {
  LedgerBlobBuilder builder_(_fbb);
  builder_.add_raw_outputs(raw_outputs);
  builder_.add_raw_inputs(raw_inputs);
  builder_.add_ledger_hash(ledger_hash);
  return builder_.Finish();
}

inline flatbuffers::Offset<LedgerBlob> CreateLedgerBlobDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *ledger_hash = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInputCollection>> *raw_inputs = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutputCollection>> *raw_outputs = nullptr) {
  auto ledger_hash__ = ledger_hash ? _fbb.CreateVector<uint8_t>(*ledger_hash) : 0;
  auto raw_inputs__ = raw_inputs ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInputCollection>>(*raw_inputs) : 0;
  auto raw_outputs__ = raw_outputs ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutputCollection>>(*raw_outputs) : 0;
  return msg::fbuf::ledgermsg::CreateLedgerBlob(
      _fbb,
      ledger_hash__,
      raw_inputs__,
      raw_outputs__);
}

struct RawInputCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RawInputCollectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_INPUTS = 6
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInput>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInput>> *>(VT_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInput>> *mutable_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInput>> *>(VT_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           verifier.EndTable();
  }
};

struct RawInputCollectionBuilder {
  typedef RawInputCollection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(RawInputCollection::VT_PUBKEY, pubkey);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInput>>> inputs) {
    fbb_.AddOffset(RawInputCollection::VT_INPUTS, inputs);
  }
  explicit RawInputCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RawInputCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RawInputCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<RawInputCollection> CreateRawInputCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInput>>> inputs = 0) {
  RawInputCollectionBuilder builder_(_fbb);
  builder_.add_inputs(inputs);
  builder_.add_pubkey(pubkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<RawInputCollection> CreateRawInputCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInput>> *inputs = nullptr) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawInput>>(*inputs) : 0;
  return msg::fbuf::ledgermsg::CreateRawInputCollection(
      _fbb,
      pubkey__,
      inputs__);
}

struct RawInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RawInputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4
  };
  const flatbuffers::Vector<uint8_t> *input() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INPUT);
  }
  flatbuffers::Vector<uint8_t> *mutable_input() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_INPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           verifier.EndTable();
  }
};

struct RawInputBuilder {
  typedef RawInput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input) {
    fbb_.AddOffset(RawInput::VT_INPUT, input);
  }
  explicit RawInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RawInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RawInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<RawInput> CreateRawInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input = 0) {
  RawInputBuilder builder_(_fbb);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<RawInput> CreateRawInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *input = nullptr) {
  auto input__ = input ? _fbb.CreateVector<uint8_t>(*input) : 0;
  return msg::fbuf::ledgermsg::CreateRawInput(
      _fbb,
      input__);
}

struct RawOutputCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RawOutputCollectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_OUTPUTS = 6
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutput>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutput>> *>(VT_OUTPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutput>> *mutable_outputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutput>> *>(VT_OUTPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           verifier.EndTable();
  }
};

struct RawOutputCollectionBuilder {
  typedef RawOutputCollection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(RawOutputCollection::VT_PUBKEY, pubkey);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutput>>> outputs) {
    fbb_.AddOffset(RawOutputCollection::VT_OUTPUTS, outputs);
  }
  explicit RawOutputCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RawOutputCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RawOutputCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<RawOutputCollection> CreateRawOutputCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutput>>> outputs = 0) {
  RawOutputCollectionBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_pubkey(pubkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<RawOutputCollection> CreateRawOutputCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    const std::vector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutput>> *outputs = nullptr) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<msg::fbuf::ledgermsg::RawOutput>>(*outputs) : 0;
  return msg::fbuf::ledgermsg::CreateRawOutputCollection(
      _fbb,
      pubkey__,
      outputs__);
}

struct RawOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RawOutputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT = 4
  };
  const flatbuffers::Vector<uint8_t> *output() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OUTPUT);
  }
  flatbuffers::Vector<uint8_t> *mutable_output() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           verifier.EndTable();
  }
};

struct RawOutputBuilder {
  typedef RawOutput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output) {
    fbb_.AddOffset(RawOutput::VT_OUTPUT, output);
  }
  explicit RawOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RawOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RawOutput>(end);
    return o;
  }
};

inline flatbuffers::Offset<RawOutput> CreateRawOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output = 0) {
  RawOutputBuilder builder_(_fbb);
  builder_.add_output(output);
  return builder_.Finish();
}

inline flatbuffers::Offset<RawOutput> CreateRawOutputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *output = nullptr) {
  auto output__ = output ? _fbb.CreateVector<uint8_t>(*output) : 0;
  return msg::fbuf::ledgermsg::CreateRawOutput(
      _fbb,
      output__);
}

inline const msg::fbuf::ledgermsg::LedgerBlob *GetLedgerBlob(const void *buf) {
  return flatbuffers::GetRoot<msg::fbuf::ledgermsg::LedgerBlob>(buf);
}

inline const msg::fbuf::ledgermsg::LedgerBlob *GetSizePrefixedLedgerBlob(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<msg::fbuf::ledgermsg::LedgerBlob>(buf);
}

inline LedgerBlob *GetMutableLedgerBlob(void *buf) {
  return flatbuffers::GetMutableRoot<LedgerBlob>(buf);
}

inline bool VerifyLedgerBlobBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<msg::fbuf::ledgermsg::LedgerBlob>(nullptr);
}

inline bool VerifySizePrefixedLedgerBlobBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<msg::fbuf::ledgermsg::LedgerBlob>(nullptr);
}

inline void FinishLedgerBlobBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<msg::fbuf::ledgermsg::LedgerBlob> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLedgerBlobBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<msg::fbuf::ledgermsg::LedgerBlob> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace ledgermsg
}  // namespace fbuf
}  // namespace msg

#endif  // FLATBUFFERS_GENERATED_LEDGERBLOBSCHEMA_MSG_FBUF_LEDGERMSG_H_
