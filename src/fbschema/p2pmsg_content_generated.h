// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_P2PMSGCONTENT_FBSCHEMA_P2PMSG_H_
#define FLATBUFFERS_GENERATED_P2PMSGCONTENT_FBSCHEMA_P2PMSG_H_

#include "flatbuffers/flatbuffers.h"

#include "common_schema_generated.h"

namespace fbschema {
namespace p2pmsg {

struct UserSubmittedMessage;

struct UserSubmittedMessageGroup;

struct Content;

struct NonUnl_Proposal_Message;

struct Proposal_Message;

struct Npl_Message;

struct State_Request_Message;
struct History_Request_Message;

struct History_Response_Message;

struct HistoryLedgerPair;

struct HistoryLedger
struct StateDifference;

struct State;

enum Message {
  Message_NONE = 0,
  Message_NonUnl_Proposal_Message = 1,
  Message_Proposal_Message = 2,
  Message_Npl_Message = 3,
  Message_State_Request_Message = 4,
  Message_MIN = Message_NONE,
  Message_MAX = Message_State_Request_Message
};

inline const Message (&EnumValuesMessage())[5] {
  Message_History_Request_Message = 4,
  Message_History_Response_Message = 5,
  Message_MIN = Message_NONE,
  Message_MAX = Message_History_Response_Message
};

inline const Message (&EnumValuesMessage())[6] {
  static const Message values[] = {
    Message_NONE,
    Message_NonUnl_Proposal_Message,
    Message_Proposal_Message,
    Message_Npl_Message,
    Message_State_Request_Message,
    Message_History_Request_Message,
    Message_History_Response_Message
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[] = {
    "NONE",
    "NonUnl_Proposal_Message",
    "Proposal_Message",
    "Npl_Message",
    "State_Request_Message",
    "History_Request_Message",
    "History_Response_Message",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (e < Message_NONE || e > Message_History_Response_Message) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<NonUnl_Proposal_Message> {
  static const Message enum_value = Message_NonUnl_Proposal_Message;
};

template<> struct MessageTraits<Proposal_Message> {
  static const Message enum_value = Message_Proposal_Message;
};

template<> struct MessageTraits<Npl_Message> {
  static const Message enum_value = Message_Npl_Message;
};

template<> struct MessageTraits<History_Request_Message> {
  static const Message enum_value = Message_History_Request_Message;
};

template<> struct MessageTraits<History_Response_Message> {
  static const Message enum_value = Message_History_Response_Message;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct UserSubmittedMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4,
    VT_SIGNATURE = 6
  };
  const flatbuffers::Vector<uint8_t> *content() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONTENT);
  }
  flatbuffers::Vector<uint8_t> *mutable_content() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CONTENT);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  flatbuffers::Vector<uint8_t> *mutable_signature() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           verifier.EndTable();
  }
};

struct UserSubmittedMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> content) {
    fbb_.AddOffset(UserSubmittedMessage::VT_CONTENT, content);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(UserSubmittedMessage::VT_SIGNATURE, signature);
  }
  explicit UserSubmittedMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserSubmittedMessageBuilder &operator=(const UserSubmittedMessageBuilder &);
  flatbuffers::Offset<UserSubmittedMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserSubmittedMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserSubmittedMessage> CreateUserSubmittedMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> content = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0) {
  UserSubmittedMessageBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_content(content);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserSubmittedMessage> CreateUserSubmittedMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *content = nullptr,
    const std::vector<uint8_t> *signature = nullptr) {
  auto content__ = content ? _fbb.CreateVector<uint8_t>(*content) : 0;
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  return fbschema::p2pmsg::CreateUserSubmittedMessage(
      _fbb,
      content__,
      signature__);
}

struct UserSubmittedMessageGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_MESSAGES = 6
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>> *>(VT_MESSAGES);
  }
  flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>> *mutable_messages() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>> *>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct UserSubmittedMessageGroupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(UserSubmittedMessageGroup::VT_PUBKEY, pubkey);
  }
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>>> messages) {
    fbb_.AddOffset(UserSubmittedMessageGroup::VT_MESSAGES, messages);
  }
  explicit UserSubmittedMessageGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserSubmittedMessageGroupBuilder &operator=(const UserSubmittedMessageGroupBuilder &);
  flatbuffers::Offset<UserSubmittedMessageGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserSubmittedMessageGroup>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserSubmittedMessageGroup> CreateUserSubmittedMessageGroup(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>>> messages = 0) {
  UserSubmittedMessageGroupBuilder builder_(_fbb);
  builder_.add_messages(messages);
  builder_.add_pubkey(pubkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserSubmittedMessageGroup> CreateUserSubmittedMessageGroupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    const std::vector<flatbuffers::Offset<UserSubmittedMessage>> *messages = nullptr) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<UserSubmittedMessage>>(*messages) : 0;
  return fbschema::p2pmsg::CreateUserSubmittedMessageGroup(
      _fbb,
      pubkey__,
      messages__);
}

struct Content FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  Message message_type() const {
    return static_cast<Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  bool mutate_message_type(Message _message_type) {
    return SetField<uint8_t>(VT_MESSAGE_TYPE, static_cast<uint8_t>(_message_type), 0);
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const NonUnl_Proposal_Message *message_as_NonUnl_Proposal_Message() const {
    return message_type() == Message_NonUnl_Proposal_Message ? static_cast<const NonUnl_Proposal_Message *>(message()) : nullptr;
  }
  const Proposal_Message *message_as_Proposal_Message() const {
    return message_type() == Message_Proposal_Message ? static_cast<const Proposal_Message *>(message()) : nullptr;
  }
  const Npl_Message *message_as_Npl_Message() const {
    return message_type() == Message_Npl_Message ? static_cast<const Npl_Message *>(message()) : nullptr;
  }
  const State_Request_Message *message_as_State_Request_Message() const {
    return message_type() == Message_State_Request_Message ? static_cast<const State_Request_Message *>(message()) : nullptr;
  const History_Request_Message *message_as_History_Request_Message() const {
    return message_type() == Message_History_Request_Message ? static_cast<const History_Request_Message *>(message()) : nullptr;
  }
  const History_Response_Message *message_as_History_Response_Message() const {
    return message_type() == Message_History_Response_Message ? static_cast<const History_Response_Message *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const NonUnl_Proposal_Message *Content::message_as<NonUnl_Proposal_Message>() const {
  return message_as_NonUnl_Proposal_Message();
}

template<> inline const Proposal_Message *Content::message_as<Proposal_Message>() const {
  return message_as_Proposal_Message();
}

template<> inline const Npl_Message *Content::message_as<Npl_Message>() const {
  return message_as_Npl_Message();
}

template<> inline const History_Request_Message *Content::message_as<History_Request_Message>() const {
  return message_as_History_Request_Message();
}

template<> inline const History_Response_Message *Content::message_as<History_Response_Message>() const {
  return message_as_History_Response_Message();
}

struct ContentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Message message_type) {
    fbb_.AddElement<uint8_t>(Content::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Content::VT_MESSAGE, message);
  }
  explicit ContentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContentBuilder &operator=(const ContentBuilder &);
  flatbuffers::Offset<Content> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Content>(end);
    return o;
  }
};

inline flatbuffers::Offset<Content> CreateContent(
    flatbuffers::FlatBufferBuilder &_fbb,
    Message message_type = Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  ContentBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct NonUnl_Proposal_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERMESSAGES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>> *usermessages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>> *>(VT_USERMESSAGES);
  }
  flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>> *mutable_usermessages() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>> *>(VT_USERMESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USERMESSAGES) &&
           verifier.VerifyVector(usermessages()) &&
           verifier.VerifyVectorOfTables(usermessages()) &&
           verifier.EndTable();
  }
};

struct NonUnl_Proposal_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_usermessages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>>> usermessages) {
    fbb_.AddOffset(NonUnl_Proposal_Message::VT_USERMESSAGES, usermessages);
  }
  explicit NonUnl_Proposal_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonUnl_Proposal_MessageBuilder &operator=(const NonUnl_Proposal_MessageBuilder &);
  flatbuffers::Offset<NonUnl_Proposal_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonUnl_Proposal_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonUnl_Proposal_Message> CreateNonUnl_Proposal_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>>> usermessages = 0) {
  NonUnl_Proposal_MessageBuilder builder_(_fbb);
  builder_.add_usermessages(usermessages);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonUnl_Proposal_Message> CreateNonUnl_Proposal_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<UserSubmittedMessageGroup>> *usermessages = nullptr) {
  auto usermessages__ = usermessages ? _fbb.CreateVector<flatbuffers::Offset<UserSubmittedMessageGroup>>(*usermessages) : 0;
  return fbschema::p2pmsg::CreateNonUnl_Proposal_Message(
      _fbb,
      usermessages__);
}

struct Proposal_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STAGE = 4,
    VT_TIME = 6,
    VT_USERS = 8,
    VT_HASH_INPUTS = 10,
    VT_HASH_OUTPUTS = 12,
    VT_STATE = 14
  };
  uint8_t stage() const {
    return GetField<uint8_t>(VT_STAGE, 0);
  }
  bool mutate_stage(uint8_t _stage) {
    return SetField<uint8_t>(VT_STAGE, _stage, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *users() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_USERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *mutable_users() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_USERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *hash_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_HASH_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *mutable_hash_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_HASH_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *hash_outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_HASH_OUTPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *mutable_hash_outputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_HASH_OUTPUTS);
  }
  const State *state() const {
    return GetPointer<const State *>(VT_STATE);
  }
  State *mutable_state() {
    return GetPointer<State *>(VT_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STAGE) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_USERS) &&
           verifier.VerifyVector(users()) &&
           verifier.VerifyVectorOfTables(users()) &&
           VerifyOffset(verifier, VT_HASH_INPUTS) &&
           verifier.VerifyVector(hash_inputs()) &&
           verifier.VerifyVectorOfTables(hash_inputs()) &&
           VerifyOffset(verifier, VT_HASH_OUTPUTS) &&
           verifier.VerifyVector(hash_outputs()) &&
           verifier.VerifyVectorOfTables(hash_outputs()) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyTable(state()) &&
           verifier.EndTable();
  }
};

struct Proposal_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stage(uint8_t stage) {
    fbb_.AddElement<uint8_t>(Proposal_Message::VT_STAGE, stage, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(Proposal_Message::VT_TIME, time, 0);
  }
  void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> users) {
    fbb_.AddOffset(Proposal_Message::VT_USERS, users);
  }
  void add_hash_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> hash_inputs) {
    fbb_.AddOffset(Proposal_Message::VT_HASH_INPUTS, hash_inputs);
  }
  void add_hash_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> hash_outputs) {
    fbb_.AddOffset(Proposal_Message::VT_HASH_OUTPUTS, hash_outputs);
  }
  void add_state(flatbuffers::Offset<State> state) {
    fbb_.AddOffset(Proposal_Message::VT_STATE, state);
  }
  explicit Proposal_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Proposal_MessageBuilder &operator=(const Proposal_MessageBuilder &);
  flatbuffers::Offset<Proposal_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Proposal_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Proposal_Message> CreateProposal_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t stage = 0,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> users = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> hash_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> hash_outputs = 0,
    flatbuffers::Offset<State> state = 0) {
  Proposal_MessageBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_state(state);
  builder_.add_hash_outputs(hash_outputs);
  builder_.add_hash_inputs(hash_inputs);
  builder_.add_users(users);
  builder_.add_stage(stage);
  return builder_.Finish();
}

inline flatbuffers::Offset<Proposal_Message> CreateProposal_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t stage = 0,
    uint64_t time = 0,
    const std::vector<flatbuffers::Offset<fbschema::ByteArray>> *users = nullptr,
    const std::vector<flatbuffers::Offset<fbschema::ByteArray>> *hash_inputs = nullptr,
    const std::vector<flatbuffers::Offset<fbschema::ByteArray>> *hash_outputs = nullptr,
    flatbuffers::Offset<State> state = 0) {
  auto users__ = users ? _fbb.CreateVector<flatbuffers::Offset<fbschema::ByteArray>>(*users) : 0;
  auto hash_inputs__ = hash_inputs ? _fbb.CreateVector<flatbuffers::Offset<fbschema::ByteArray>>(*hash_inputs) : 0;
  auto hash_outputs__ = hash_outputs ? _fbb.CreateVector<flatbuffers::Offset<fbschema::ByteArray>>(*hash_outputs) : 0;
  return fbschema::p2pmsg::CreateProposal_Message(
      _fbb,
      stage,
      time,
      users__,
      hash_inputs__,
      hash_outputs__,
      state);
}

struct Npl_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct Npl_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Npl_Message::VT_DATA, data);
  }
  explicit Npl_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Npl_MessageBuilder &operator=(const Npl_MessageBuilder &);
  flatbuffers::Offset<Npl_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Npl_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Npl_Message> CreateNpl_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  Npl_MessageBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Npl_Message> CreateNpl_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fbschema::p2pmsg::CreateNpl_Message(
      _fbb,
      data__);
}

struct State_Request_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE_HASH = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *state_hash() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_STATE_HASH);
  }
  flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *mutable_state_hash() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_STATE_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATE_HASH) &&
           verifier.VerifyVector(state_hash()) &&
           verifier.VerifyVectorOfTables(state_hash()) &&
struct History_Request_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINIMUM_LCL = 4,
    VT_REQUIRED_LCL = 6
  };
  const flatbuffers::Vector<uint8_t> *minimum_lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MINIMUM_LCL);
  }
  flatbuffers::Vector<uint8_t> *mutable_minimum_lcl() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_MINIMUM_LCL);
  }
  const flatbuffers::Vector<uint8_t> *required_lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_REQUIRED_LCL);
  }
  flatbuffers::Vector<uint8_t> *mutable_required_lcl() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_REQUIRED_LCL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MINIMUM_LCL) &&
           verifier.VerifyVector(minimum_lcl()) &&
           VerifyOffset(verifier, VT_REQUIRED_LCL) &&
           verifier.VerifyVector(required_lcl()) &&
           verifier.EndTable();
  }
};

struct History_Request_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minimum_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> minimum_lcl) {
    fbb_.AddOffset(History_Request_Message::VT_MINIMUM_LCL, minimum_lcl);
  }
  void add_required_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> required_lcl) {
    fbb_.AddOffset(History_Request_Message::VT_REQUIRED_LCL, required_lcl);
  }
  explicit History_Request_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  History_Request_MessageBuilder &operator=(const History_Request_MessageBuilder &);
  flatbuffers::Offset<History_Request_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<History_Request_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<History_Request_Message> CreateHistory_Request_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> minimum_lcl = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> required_lcl = 0) {
  History_Request_MessageBuilder builder_(_fbb);
  builder_.add_required_lcl(required_lcl);
  builder_.add_minimum_lcl(minimum_lcl);
  return builder_.Finish();
}

inline flatbuffers::Offset<History_Request_Message> CreateHistory_Request_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *minimum_lcl = nullptr,
    const std::vector<uint8_t> *required_lcl = nullptr) {
  auto minimum_lcl__ = minimum_lcl ? _fbb.CreateVector<uint8_t>(*minimum_lcl) : 0;
  auto required_lcl__ = required_lcl ? _fbb.CreateVector<uint8_t>(*required_lcl) : 0;
  return fbschema::p2pmsg::CreateHistory_Request_Message(
      _fbb,
      minimum_lcl__,
      required_lcl__);
}

struct History_Response_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HIST_LEDGERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>> *hist_ledgers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>> *>(VT_HIST_LEDGERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>> *mutable_hist_ledgers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>> *>(VT_HIST_LEDGERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HIST_LEDGERS) &&
           verifier.VerifyVector(hist_ledgers()) &&
           verifier.VerifyVectorOfTables(hist_ledgers()) &&
           verifier.EndTable();
  }
};

struct History_Response_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hist_ledgers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>>> hist_ledgers) {
    fbb_.AddOffset(History_Response_Message::VT_HIST_LEDGERS, hist_ledgers);
  }
  explicit History_Response_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  History_Response_MessageBuilder &operator=(const History_Response_MessageBuilder &);
  flatbuffers::Offset<History_Response_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<History_Response_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<History_Response_Message> CreateHistory_Response_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>>> hist_ledgers = 0) {
  History_Response_MessageBuilder builder_(_fbb);
  builder_.add_hist_ledgers(hist_ledgers);
  return builder_.Finish();
}

inline flatbuffers::Offset<History_Response_Message> CreateHistory_Response_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<HistoryLedgerPair>> *hist_ledgers = nullptr) {
  auto hist_ledgers__ = hist_ledgers ? _fbb.CreateVector<flatbuffers::Offset<HistoryLedgerPair>>(*hist_ledgers) : 0;
  return fbschema::p2pmsg::CreateHistory_Response_Message(
      _fbb,
      hist_ledgers__);
}

struct HistoryLedgerPair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ_NO = 4,
    VT_LEDGER = 6
  };
  uint64_t seq_no() const {
    return GetField<uint64_t>(VT_SEQ_NO, 0);
  }
  bool mutate_seq_no(uint64_t _seq_no) {
    return SetField<uint64_t>(VT_SEQ_NO, _seq_no, 0);
  }
  const HistoryLedger *ledger() const {
    return GetPointer<const HistoryLedger *>(VT_LEDGER);
  }
  HistoryLedger *mutable_ledger() {
    return GetPointer<HistoryLedger *>(VT_LEDGER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SEQ_NO) &&
           VerifyOffset(verifier, VT_LEDGER) &&
           verifier.VerifyTable(ledger()) &&
           verifier.EndTable();
  }
};

struct HistoryLedgerPairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_no(uint64_t seq_no) {
    fbb_.AddElement<uint64_t>(HistoryLedgerPair::VT_SEQ_NO, seq_no, 0);
  }
  void add_ledger(flatbuffers::Offset<HistoryLedger> ledger) {
    fbb_.AddOffset(HistoryLedgerPair::VT_LEDGER, ledger);
  }
  explicit HistoryLedgerPairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HistoryLedgerPairBuilder &operator=(const HistoryLedgerPairBuilder &);
  flatbuffers::Offset<HistoryLedgerPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HistoryLedgerPair>(end);
    return o;
  }
};

inline flatbuffers::Offset<HistoryLedgerPair> CreateHistoryLedgerPair(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq_no = 0,
    flatbuffers::Offset<HistoryLedger> ledger = 0) {
  HistoryLedgerPairBuilder builder_(_fbb);
  builder_.add_seq_no(seq_no);
  builder_.add_ledger(ledger);
  return builder_.Finish();
}

struct HistoryLedger FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LCL = 4,
    VT_RAW_LEDGER = 6
  };
  const flatbuffers::Vector<uint8_t> *lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  flatbuffers::Vector<uint8_t> *mutable_lcl() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  const flatbuffers::Vector<uint8_t> *raw_ledger() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_RAW_LEDGER);
  }
  flatbuffers::Vector<uint8_t> *mutable_raw_ledger() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_RAW_LEDGER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LCL) &&
           verifier.VerifyVector(lcl()) &&
           VerifyOffset(verifier, VT_RAW_LEDGER) &&
           verifier.VerifyVector(raw_ledger()) &&
           verifier.EndTable();
  }
};

struct State_Request_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state_hash(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> state_hash) {
    fbb_.AddOffset(State_Request_Message::VT_STATE_HASH, state_hash);
  }
  explicit State_Request_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  State_Request_MessageBuilder &operator=(const State_Request_MessageBuilder &);
  flatbuffers::Offset<State_Request_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State_Request_Message>(end);
struct HistoryLedgerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl) {
    fbb_.AddOffset(HistoryLedger::VT_LCL, lcl);
  }
  void add_raw_ledger(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_ledger) {
    fbb_.AddOffset(HistoryLedger::VT_RAW_LEDGER, raw_ledger);
  }
  explicit HistoryLedgerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HistoryLedgerBuilder &operator=(const HistoryLedgerBuilder &);
  flatbuffers::Offset<HistoryLedger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HistoryLedger>(end);
    return o;
  }
};

inline flatbuffers::Offset<State_Request_Message> CreateState_Request_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> state_hash = 0) {
  State_Request_MessageBuilder builder_(_fbb);
  builder_.add_state_hash(state_hash);
  return builder_.Finish();
}

inline flatbuffers::Offset<State_Request_Message> CreateState_Request_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<fbschema::ByteArray>> *state_hash = nullptr) {
  auto state_hash__ = state_hash ? _fbb.CreateVector<flatbuffers::Offset<fbschema::ByteArray>>(*state_hash) : 0;
  return fbschema::p2pmsg::CreateState_Request_Message(
      _fbb,
      state_hash__);
inline flatbuffers::Offset<HistoryLedger> CreateHistoryLedger(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_ledger = 0) {
  HistoryLedgerBuilder builder_(_fbb);
  builder_.add_raw_ledger(raw_ledger);
  builder_.add_lcl(lcl);
  return builder_.Finish();
}

inline flatbuffers::Offset<HistoryLedger> CreateHistoryLedgerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *lcl = nullptr,
    const std::vector<uint8_t> *raw_ledger = nullptr) {
  auto lcl__ = lcl ? _fbb.CreateVector<uint8_t>(*lcl) : 0;
  auto raw_ledger__ = raw_ledger ? _fbb.CreateVector<uint8_t>(*raw_ledger) : 0;
  return fbschema::p2pmsg::CreateHistoryLedger(
      _fbb,
      lcl__,
      raw_ledger__);
}

struct StateDifference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CREATED = 4,
    VT_UPDATED = 6,
    VT_DELETED = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *created() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *>(VT_CREATED);
  }
  flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *mutable_created() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *>(VT_CREATED);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *updated() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *>(VT_UPDATED);
  }
  flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *mutable_updated() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *>(VT_UPDATED);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *deleted() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *>(VT_DELETED);
  }
  flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *mutable_deleted() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *>(VT_DELETED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CREATED) &&
           verifier.VerifyVector(created()) &&
           verifier.VerifyVectorOfTables(created()) &&
           VerifyOffset(verifier, VT_UPDATED) &&
           verifier.VerifyVector(updated()) &&
           verifier.VerifyVectorOfTables(updated()) &&
           VerifyOffset(verifier, VT_DELETED) &&
           verifier.VerifyVector(deleted()) &&
           verifier.VerifyVectorOfTables(deleted()) &&
           verifier.EndTable();
  }
};

struct StateDifferenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_created(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>> created) {
    fbb_.AddOffset(StateDifference::VT_CREATED, created);
  }
  void add_updated(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>> updated) {
    fbb_.AddOffset(StateDifference::VT_UPDATED, updated);
  }
  void add_deleted(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>> deleted) {
    fbb_.AddOffset(StateDifference::VT_DELETED, deleted);
  }
  explicit StateDifferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateDifferenceBuilder &operator=(const StateDifferenceBuilder &);
  flatbuffers::Offset<StateDifference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StateDifference>(end);
    return o;
  }
};

inline flatbuffers::Offset<StateDifference> CreateStateDifference(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>> created = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>> updated = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>> deleted = 0) {
  StateDifferenceBuilder builder_(_fbb);
  builder_.add_deleted(deleted);
  builder_.add_updated(updated);
  builder_.add_created(created);
  return builder_.Finish();
}

inline flatbuffers::Offset<StateDifference> CreateStateDifferenceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *created = nullptr,
    const std::vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *updated = nullptr,
    const std::vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *deleted = nullptr) {
  auto created__ = created ? _fbb.CreateVector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>(*created) : 0;
  auto updated__ = updated ? _fbb.CreateVector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>(*updated) : 0;
  auto deleted__ = deleted ? _fbb.CreateVector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>(*deleted) : 0;
  return fbschema::p2pmsg::CreateStateDifference(
      _fbb,
      created__,
      updated__,
      deleted__);
}

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PREVIOUS = 4,
    VT_CURRENT = 6,
    VT_DIFFERENCE = 8,
    VT_PATCH = 10
  };
  const flatbuffers::Vector<uint8_t> *previous() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PREVIOUS);
  }
  flatbuffers::Vector<uint8_t> *mutable_previous() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PREVIOUS);
  }
  const flatbuffers::Vector<uint8_t> *current() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CURRENT);
  }
  flatbuffers::Vector<uint8_t> *mutable_current() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CURRENT);
  }
  const StateDifference *difference() const {
    return GetPointer<const StateDifference *>(VT_DIFFERENCE);
  }
  StateDifference *mutable_difference() {
    return GetPointer<StateDifference *>(VT_DIFFERENCE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *patch() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *>(VT_PATCH);
  }
  flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *mutable_patch() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *>(VT_PATCH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PREVIOUS) &&
           verifier.VerifyVector(previous()) &&
           VerifyOffset(verifier, VT_CURRENT) &&
           verifier.VerifyVector(current()) &&
           VerifyOffset(verifier, VT_DIFFERENCE) &&
           verifier.VerifyTable(difference()) &&
           VerifyOffset(verifier, VT_PATCH) &&
           verifier.VerifyVector(patch()) &&
           verifier.VerifyVectorOfTables(patch()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_previous(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> previous) {
    fbb_.AddOffset(State::VT_PREVIOUS, previous);
  }
  void add_current(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> current) {
    fbb_.AddOffset(State::VT_CURRENT, current);
  }
  void add_difference(flatbuffers::Offset<StateDifference> difference) {
    fbb_.AddOffset(State::VT_DIFFERENCE, difference);
  }
  void add_patch(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>> patch) {
    fbb_.AddOffset(State::VT_PATCH, patch);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> previous = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> current = 0,
    flatbuffers::Offset<StateDifference> difference = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>> patch = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_patch(patch);
  builder_.add_difference(difference);
  builder_.add_current(current);
  builder_.add_previous(previous);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *previous = nullptr,
    const std::vector<uint8_t> *current = nullptr,
    flatbuffers::Offset<StateDifference> difference = 0,
    const std::vector<flatbuffers::Offset<fbschema::BytesKeyValuePair>> *patch = nullptr) {
  auto previous__ = previous ? _fbb.CreateVector<uint8_t>(*previous) : 0;
  auto current__ = current ? _fbb.CreateVector<uint8_t>(*current) : 0;
  auto patch__ = patch ? _fbb.CreateVector<flatbuffers::Offset<fbschema::BytesKeyValuePair>>(*patch) : 0;
  return fbschema::p2pmsg::CreateState(
      _fbb,
      previous__,
      current__,
      difference,
      patch__);
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_NonUnl_Proposal_Message: {
      auto ptr = reinterpret_cast<const NonUnl_Proposal_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Proposal_Message: {
      auto ptr = reinterpret_cast<const Proposal_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Npl_Message: {
      auto ptr = reinterpret_cast<const Npl_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_State_Request_Message: {
      auto ptr = reinterpret_cast<const State_Request_Message *>(obj);
    case Message_History_Request_Message: {
      auto ptr = reinterpret_cast<const History_Request_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_History_Response_Message: {
      auto ptr = reinterpret_cast<const History_Response_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const fbschema::p2pmsg::Content *GetContent(const void *buf) {
  return flatbuffers::GetRoot<fbschema::p2pmsg::Content>(buf);
}

inline const fbschema::p2pmsg::Content *GetSizePrefixedContent(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<fbschema::p2pmsg::Content>(buf);
}

inline Content *GetMutableContent(void *buf) {
  return flatbuffers::GetMutableRoot<Content>(buf);
}

inline bool VerifyContentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fbschema::p2pmsg::Content>(nullptr);
}

inline bool VerifySizePrefixedContentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fbschema::p2pmsg::Content>(nullptr);
}

inline void FinishContentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fbschema::p2pmsg::Content> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedContentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fbschema::p2pmsg::Content> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace p2pmsg
}  // namespace fbschema

#endif  // FLATBUFFERS_GENERATED_P2PMSGCONTENT_FBSCHEMA_P2PMSG_H_
