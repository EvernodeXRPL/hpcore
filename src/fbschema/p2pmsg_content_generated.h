// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_P2PMSGCONTENT_FBSCHEMA_P2PMSG_H_
#define FLATBUFFERS_GENERATED_P2PMSGCONTENT_FBSCHEMA_P2PMSG_H_

#include "flatbuffers/flatbuffers.h"

#include "common_schema_generated.h"

namespace fbschema {
namespace p2pmsg {

struct UserSubmittedMessage;

struct UserSubmittedMessageGroup;

struct Content;

struct NonUnl_Proposal_Message;

struct Proposal_Message;

struct Npl_Message;

struct History_Request_Message;

struct History_Response_Message;

struct HistoryLedgerPair;

struct HistoryLedger;

struct State_Request_Message;

struct State_Response_Message;

struct Content_Response;

struct File_HashMap_Response;

struct Block_Response;

struct State_FS_Hash_Entry;

enum Message {
  Message_NONE = 0,
  Message_NonUnl_Proposal_Message = 1,
  Message_Proposal_Message = 2,
  Message_Npl_Message = 3,
  Message_State_Request_Message = 4,
  Message_State_Response_Message = 5,
  Message_History_Request_Message = 6,
  Message_History_Response_Message = 7,
  Message_MIN = Message_NONE,
  Message_MAX = Message_History_Response_Message
};

inline const Message (&EnumValuesMessage())[8] {
  static const Message values[] = {
    Message_NONE,
    Message_NonUnl_Proposal_Message,
    Message_Proposal_Message,
    Message_Npl_Message,
    Message_State_Request_Message,
    Message_State_Response_Message,
    Message_History_Request_Message,
    Message_History_Response_Message
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[] = {
    "NONE",
    "NonUnl_Proposal_Message",
    "Proposal_Message",
    "Npl_Message",
    "State_Request_Message",
    "State_Response_Message",
    "History_Request_Message",
    "History_Response_Message",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (e < Message_NONE || e > Message_History_Response_Message) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<NonUnl_Proposal_Message> {
  static const Message enum_value = Message_NonUnl_Proposal_Message;
};

template<> struct MessageTraits<Proposal_Message> {
  static const Message enum_value = Message_Proposal_Message;
};

template<> struct MessageTraits<Npl_Message> {
  static const Message enum_value = Message_Npl_Message;
};

template<> struct MessageTraits<State_Request_Message> {
  static const Message enum_value = Message_State_Request_Message;
};

template<> struct MessageTraits<State_Response_Message> {
  static const Message enum_value = Message_State_Response_Message;
};

template<> struct MessageTraits<History_Request_Message> {
  static const Message enum_value = Message_History_Request_Message;
};

template<> struct MessageTraits<History_Response_Message> {
  static const Message enum_value = Message_History_Response_Message;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Ledger_Response_Error {
  Ledger_Response_Error_None = 0,
  Ledger_Response_Error_Invalid_Min_Ledger = 1,
  Ledger_Response_Error_Req_Ledger_Not_Found = 2,
  Ledger_Response_Error_MIN = Ledger_Response_Error_None,
  Ledger_Response_Error_MAX = Ledger_Response_Error_Req_Ledger_Not_Found
};

inline const Ledger_Response_Error (&EnumValuesLedger_Response_Error())[3] {
  static const Ledger_Response_Error values[] = {
    Ledger_Response_Error_None,
    Ledger_Response_Error_Invalid_Min_Ledger,
    Ledger_Response_Error_Req_Ledger_Not_Found
  };
  return values;
}

inline const char * const *EnumNamesLedger_Response_Error() {
  static const char * const names[] = {
    "None",
    "Invalid_Min_Ledger",
    "Req_Ledger_Not_Found",
    nullptr
  };
  return names;
}

inline const char *EnumNameLedger_Response_Error(Ledger_Response_Error e) {
  if (e < Ledger_Response_Error_None || e > Ledger_Response_Error_Req_Ledger_Not_Found) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLedger_Response_Error()[index];
}

enum State_Response {
  State_Response_NONE = 0,
  State_Response_File_HashMap_Response = 1,
  State_Response_Block_Response = 2,
  State_Response_Content_Response = 3,
  State_Response_MIN = State_Response_NONE,
  State_Response_MAX = State_Response_Content_Response
};

inline const State_Response (&EnumValuesState_Response())[4] {
  static const State_Response values[] = {
    State_Response_NONE,
    State_Response_File_HashMap_Response,
    State_Response_Block_Response,
    State_Response_Content_Response
  };
  return values;
}

inline const char * const *EnumNamesState_Response() {
  static const char * const names[] = {
    "NONE",
    "File_HashMap_Response",
    "Block_Response",
    "Content_Response",
    nullptr
  };
  return names;
}

inline const char *EnumNameState_Response(State_Response e) {
  if (e < State_Response_NONE || e > State_Response_Content_Response) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesState_Response()[index];
}

template<typename T> struct State_ResponseTraits {
  static const State_Response enum_value = State_Response_NONE;
};

template<> struct State_ResponseTraits<File_HashMap_Response> {
  static const State_Response enum_value = State_Response_File_HashMap_Response;
};

template<> struct State_ResponseTraits<Block_Response> {
  static const State_Response enum_value = State_Response_Block_Response;
};

template<> struct State_ResponseTraits<Content_Response> {
  static const State_Response enum_value = State_Response_Content_Response;
};

bool VerifyState_Response(flatbuffers::Verifier &verifier, const void *obj, State_Response type);
bool VerifyState_ResponseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct UserSubmittedMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4,
    VT_SIGNATURE = 6
  };
  const flatbuffers::Vector<uint8_t> *content() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONTENT);
  }
  flatbuffers::Vector<uint8_t> *mutable_content() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CONTENT);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  flatbuffers::Vector<uint8_t> *mutable_signature() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           verifier.EndTable();
  }
};

struct UserSubmittedMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> content) {
    fbb_.AddOffset(UserSubmittedMessage::VT_CONTENT, content);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(UserSubmittedMessage::VT_SIGNATURE, signature);
  }
  explicit UserSubmittedMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserSubmittedMessageBuilder &operator=(const UserSubmittedMessageBuilder &);
  flatbuffers::Offset<UserSubmittedMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserSubmittedMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserSubmittedMessage> CreateUserSubmittedMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> content = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0) {
  UserSubmittedMessageBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_content(content);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserSubmittedMessage> CreateUserSubmittedMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *content = nullptr,
    const std::vector<uint8_t> *signature = nullptr) {
  auto content__ = content ? _fbb.CreateVector<uint8_t>(*content) : 0;
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  return fbschema::p2pmsg::CreateUserSubmittedMessage(
      _fbb,
      content__,
      signature__);
}

struct UserSubmittedMessageGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_MESSAGES = 6
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>> *>(VT_MESSAGES);
  }
  flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>> *mutable_messages() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>> *>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct UserSubmittedMessageGroupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(UserSubmittedMessageGroup::VT_PUBKEY, pubkey);
  }
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>>> messages) {
    fbb_.AddOffset(UserSubmittedMessageGroup::VT_MESSAGES, messages);
  }
  explicit UserSubmittedMessageGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserSubmittedMessageGroupBuilder &operator=(const UserSubmittedMessageGroupBuilder &);
  flatbuffers::Offset<UserSubmittedMessageGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserSubmittedMessageGroup>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserSubmittedMessageGroup> CreateUserSubmittedMessageGroup(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessage>>> messages = 0) {
  UserSubmittedMessageGroupBuilder builder_(_fbb);
  builder_.add_messages(messages);
  builder_.add_pubkey(pubkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserSubmittedMessageGroup> CreateUserSubmittedMessageGroupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    const std::vector<flatbuffers::Offset<UserSubmittedMessage>> *messages = nullptr) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<UserSubmittedMessage>>(*messages) : 0;
  return fbschema::p2pmsg::CreateUserSubmittedMessageGroup(
      _fbb,
      pubkey__,
      messages__);
}

struct Content FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  Message message_type() const {
    return static_cast<Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  bool mutate_message_type(Message _message_type) {
    return SetField<uint8_t>(VT_MESSAGE_TYPE, static_cast<uint8_t>(_message_type), 0);
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const NonUnl_Proposal_Message *message_as_NonUnl_Proposal_Message() const {
    return message_type() == Message_NonUnl_Proposal_Message ? static_cast<const NonUnl_Proposal_Message *>(message()) : nullptr;
  }
  const Proposal_Message *message_as_Proposal_Message() const {
    return message_type() == Message_Proposal_Message ? static_cast<const Proposal_Message *>(message()) : nullptr;
  }
  const Npl_Message *message_as_Npl_Message() const {
    return message_type() == Message_Npl_Message ? static_cast<const Npl_Message *>(message()) : nullptr;
  }
  const State_Request_Message *message_as_State_Request_Message() const {
    return message_type() == Message_State_Request_Message ? static_cast<const State_Request_Message *>(message()) : nullptr;
  }
  const State_Response_Message *message_as_State_Response_Message() const {
    return message_type() == Message_State_Response_Message ? static_cast<const State_Response_Message *>(message()) : nullptr;
  }
  const History_Request_Message *message_as_History_Request_Message() const {
    return message_type() == Message_History_Request_Message ? static_cast<const History_Request_Message *>(message()) : nullptr;
  }
  const History_Response_Message *message_as_History_Response_Message() const {
    return message_type() == Message_History_Response_Message ? static_cast<const History_Response_Message *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const NonUnl_Proposal_Message *Content::message_as<NonUnl_Proposal_Message>() const {
  return message_as_NonUnl_Proposal_Message();
}

template<> inline const Proposal_Message *Content::message_as<Proposal_Message>() const {
  return message_as_Proposal_Message();
}

template<> inline const Npl_Message *Content::message_as<Npl_Message>() const {
  return message_as_Npl_Message();
}

template<> inline const State_Request_Message *Content::message_as<State_Request_Message>() const {
  return message_as_State_Request_Message();
}

template<> inline const State_Response_Message *Content::message_as<State_Response_Message>() const {
  return message_as_State_Response_Message();
}

template<> inline const History_Request_Message *Content::message_as<History_Request_Message>() const {
  return message_as_History_Request_Message();
}

template<> inline const History_Response_Message *Content::message_as<History_Response_Message>() const {
  return message_as_History_Response_Message();
}

struct ContentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Message message_type) {
    fbb_.AddElement<uint8_t>(Content::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Content::VT_MESSAGE, message);
  }
  explicit ContentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContentBuilder &operator=(const ContentBuilder &);
  flatbuffers::Offset<Content> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Content>(end);
    return o;
  }
};

inline flatbuffers::Offset<Content> CreateContent(
    flatbuffers::FlatBufferBuilder &_fbb,
    Message message_type = Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  ContentBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct NonUnl_Proposal_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERMESSAGES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>> *usermessages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>> *>(VT_USERMESSAGES);
  }
  flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>> *mutable_usermessages() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>> *>(VT_USERMESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USERMESSAGES) &&
           verifier.VerifyVector(usermessages()) &&
           verifier.VerifyVectorOfTables(usermessages()) &&
           verifier.EndTable();
  }
};

struct NonUnl_Proposal_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_usermessages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>>> usermessages) {
    fbb_.AddOffset(NonUnl_Proposal_Message::VT_USERMESSAGES, usermessages);
  }
  explicit NonUnl_Proposal_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonUnl_Proposal_MessageBuilder &operator=(const NonUnl_Proposal_MessageBuilder &);
  flatbuffers::Offset<NonUnl_Proposal_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonUnl_Proposal_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonUnl_Proposal_Message> CreateNonUnl_Proposal_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserSubmittedMessageGroup>>> usermessages = 0) {
  NonUnl_Proposal_MessageBuilder builder_(_fbb);
  builder_.add_usermessages(usermessages);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonUnl_Proposal_Message> CreateNonUnl_Proposal_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<UserSubmittedMessageGroup>> *usermessages = nullptr) {
  auto usermessages__ = usermessages ? _fbb.CreateVector<flatbuffers::Offset<UserSubmittedMessageGroup>>(*usermessages) : 0;
  return fbschema::p2pmsg::CreateNonUnl_Proposal_Message(
      _fbb,
      usermessages__);
}

struct Proposal_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STAGE = 4,
    VT_TIME = 6,
    VT_USERS = 8,
    VT_HASH_INPUTS = 10,
    VT_HASH_OUTPUTS = 12,
    VT_PREV_STATE_HASH = 14,
    VT_CURR_STATE_HASH = 16
  };
  uint8_t stage() const {
    return GetField<uint8_t>(VT_STAGE, 0);
  }
  bool mutate_stage(uint8_t _stage) {
    return SetField<uint8_t>(VT_STAGE, _stage, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *users() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_USERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *mutable_users() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_USERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *hash_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_HASH_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *mutable_hash_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_HASH_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *hash_outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_HASH_OUTPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *mutable_hash_outputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>> *>(VT_HASH_OUTPUTS);
  }
  const flatbuffers::Vector<uint8_t> *prev_state_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PREV_STATE_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_prev_state_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PREV_STATE_HASH);
  }
  const flatbuffers::Vector<uint8_t> *curr_state_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CURR_STATE_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_curr_state_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CURR_STATE_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STAGE) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_USERS) &&
           verifier.VerifyVector(users()) &&
           verifier.VerifyVectorOfTables(users()) &&
           VerifyOffset(verifier, VT_HASH_INPUTS) &&
           verifier.VerifyVector(hash_inputs()) &&
           verifier.VerifyVectorOfTables(hash_inputs()) &&
           VerifyOffset(verifier, VT_HASH_OUTPUTS) &&
           verifier.VerifyVector(hash_outputs()) &&
           verifier.VerifyVectorOfTables(hash_outputs()) &&
           VerifyOffset(verifier, VT_PREV_STATE_HASH) &&
           verifier.VerifyVector(prev_state_hash()) &&
           VerifyOffset(verifier, VT_CURR_STATE_HASH) &&
           verifier.VerifyVector(curr_state_hash()) &&
           verifier.EndTable();
  }
};

struct Proposal_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stage(uint8_t stage) {
    fbb_.AddElement<uint8_t>(Proposal_Message::VT_STAGE, stage, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(Proposal_Message::VT_TIME, time, 0);
  }
  void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> users) {
    fbb_.AddOffset(Proposal_Message::VT_USERS, users);
  }
  void add_hash_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> hash_inputs) {
    fbb_.AddOffset(Proposal_Message::VT_HASH_INPUTS, hash_inputs);
  }
  void add_hash_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> hash_outputs) {
    fbb_.AddOffset(Proposal_Message::VT_HASH_OUTPUTS, hash_outputs);
  }
  void add_prev_state_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prev_state_hash) {
    fbb_.AddOffset(Proposal_Message::VT_PREV_STATE_HASH, prev_state_hash);
  }
  void add_curr_state_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> curr_state_hash) {
    fbb_.AddOffset(Proposal_Message::VT_CURR_STATE_HASH, curr_state_hash);
  }
  explicit Proposal_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Proposal_MessageBuilder &operator=(const Proposal_MessageBuilder &);
  flatbuffers::Offset<Proposal_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Proposal_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Proposal_Message> CreateProposal_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t stage = 0,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> users = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> hash_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fbschema::ByteArray>>> hash_outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prev_state_hash = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> curr_state_hash = 0) {
  Proposal_MessageBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_curr_state_hash(curr_state_hash);
  builder_.add_prev_state_hash(prev_state_hash);
  builder_.add_hash_outputs(hash_outputs);
  builder_.add_hash_inputs(hash_inputs);
  builder_.add_users(users);
  builder_.add_stage(stage);
  return builder_.Finish();
}

inline flatbuffers::Offset<Proposal_Message> CreateProposal_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t stage = 0,
    uint64_t time = 0,
    const std::vector<flatbuffers::Offset<fbschema::ByteArray>> *users = nullptr,
    const std::vector<flatbuffers::Offset<fbschema::ByteArray>> *hash_inputs = nullptr,
    const std::vector<flatbuffers::Offset<fbschema::ByteArray>> *hash_outputs = nullptr,
    const std::vector<uint8_t> *prev_state_hash = nullptr,
    const std::vector<uint8_t> *curr_state_hash = nullptr) {
  auto users__ = users ? _fbb.CreateVector<flatbuffers::Offset<fbschema::ByteArray>>(*users) : 0;
  auto hash_inputs__ = hash_inputs ? _fbb.CreateVector<flatbuffers::Offset<fbschema::ByteArray>>(*hash_inputs) : 0;
  auto hash_outputs__ = hash_outputs ? _fbb.CreateVector<flatbuffers::Offset<fbschema::ByteArray>>(*hash_outputs) : 0;
  auto prev_state_hash__ = prev_state_hash ? _fbb.CreateVector<uint8_t>(*prev_state_hash) : 0;
  auto curr_state_hash__ = curr_state_hash ? _fbb.CreateVector<uint8_t>(*curr_state_hash) : 0;
  return fbschema::p2pmsg::CreateProposal_Message(
      _fbb,
      stage,
      time,
      users__,
      hash_inputs__,
      hash_outputs__,
      prev_state_hash__,
      curr_state_hash__);
}

struct Npl_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct Npl_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Npl_Message::VT_DATA, data);
  }
  explicit Npl_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Npl_MessageBuilder &operator=(const Npl_MessageBuilder &);
  flatbuffers::Offset<Npl_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Npl_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Npl_Message> CreateNpl_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  Npl_MessageBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Npl_Message> CreateNpl_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fbschema::p2pmsg::CreateNpl_Message(
      _fbb,
      data__);
}

struct History_Request_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINIMUM_LCL = 4,
    VT_REQUIRED_LCL = 6
  };
  const flatbuffers::Vector<uint8_t> *minimum_lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MINIMUM_LCL);
  }
  flatbuffers::Vector<uint8_t> *mutable_minimum_lcl() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_MINIMUM_LCL);
  }
  const flatbuffers::Vector<uint8_t> *required_lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_REQUIRED_LCL);
  }
  flatbuffers::Vector<uint8_t> *mutable_required_lcl() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_REQUIRED_LCL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MINIMUM_LCL) &&
           verifier.VerifyVector(minimum_lcl()) &&
           VerifyOffset(verifier, VT_REQUIRED_LCL) &&
           verifier.VerifyVector(required_lcl()) &&
           verifier.EndTable();
  }
};

struct History_Request_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minimum_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> minimum_lcl) {
    fbb_.AddOffset(History_Request_Message::VT_MINIMUM_LCL, minimum_lcl);
  }
  void add_required_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> required_lcl) {
    fbb_.AddOffset(History_Request_Message::VT_REQUIRED_LCL, required_lcl);
  }
  explicit History_Request_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  History_Request_MessageBuilder &operator=(const History_Request_MessageBuilder &);
  flatbuffers::Offset<History_Request_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<History_Request_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<History_Request_Message> CreateHistory_Request_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> minimum_lcl = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> required_lcl = 0) {
  History_Request_MessageBuilder builder_(_fbb);
  builder_.add_required_lcl(required_lcl);
  builder_.add_minimum_lcl(minimum_lcl);
  return builder_.Finish();
}

inline flatbuffers::Offset<History_Request_Message> CreateHistory_Request_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *minimum_lcl = nullptr,
    const std::vector<uint8_t> *required_lcl = nullptr) {
  auto minimum_lcl__ = minimum_lcl ? _fbb.CreateVector<uint8_t>(*minimum_lcl) : 0;
  auto required_lcl__ = required_lcl ? _fbb.CreateVector<uint8_t>(*required_lcl) : 0;
  return fbschema::p2pmsg::CreateHistory_Request_Message(
      _fbb,
      minimum_lcl__,
      required_lcl__);
}

struct History_Response_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HIST_LEDGERS = 4,
    VT_ERROR = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>> *hist_ledgers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>> *>(VT_HIST_LEDGERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>> *mutable_hist_ledgers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>> *>(VT_HIST_LEDGERS);
  }
  Ledger_Response_Error error() const {
    return static_cast<Ledger_Response_Error>(GetField<uint8_t>(VT_ERROR, 0));
  }
  bool mutate_error(Ledger_Response_Error _error) {
    return SetField<uint8_t>(VT_ERROR, static_cast<uint8_t>(_error), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HIST_LEDGERS) &&
           verifier.VerifyVector(hist_ledgers()) &&
           verifier.VerifyVectorOfTables(hist_ledgers()) &&
           VerifyField<uint8_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct History_Response_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hist_ledgers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>>> hist_ledgers) {
    fbb_.AddOffset(History_Response_Message::VT_HIST_LEDGERS, hist_ledgers);
  }
  void add_error(Ledger_Response_Error error) {
    fbb_.AddElement<uint8_t>(History_Response_Message::VT_ERROR, static_cast<uint8_t>(error), 0);
  }
  explicit History_Response_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  History_Response_MessageBuilder &operator=(const History_Response_MessageBuilder &);
  flatbuffers::Offset<History_Response_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<History_Response_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<History_Response_Message> CreateHistory_Response_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HistoryLedgerPair>>> hist_ledgers = 0,
    Ledger_Response_Error error = Ledger_Response_Error_None) {
  History_Response_MessageBuilder builder_(_fbb);
  builder_.add_hist_ledgers(hist_ledgers);
  builder_.add_error(error);
  return builder_.Finish();
}

inline flatbuffers::Offset<History_Response_Message> CreateHistory_Response_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<HistoryLedgerPair>> *hist_ledgers = nullptr,
    Ledger_Response_Error error = Ledger_Response_Error_None) {
  auto hist_ledgers__ = hist_ledgers ? _fbb.CreateVector<flatbuffers::Offset<HistoryLedgerPair>>(*hist_ledgers) : 0;
  return fbschema::p2pmsg::CreateHistory_Response_Message(
      _fbb,
      hist_ledgers__,
      error);
}

struct HistoryLedgerPair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ_NO = 4,
    VT_LEDGER = 6
  };
  uint64_t seq_no() const {
    return GetField<uint64_t>(VT_SEQ_NO, 0);
  }
  bool mutate_seq_no(uint64_t _seq_no) {
    return SetField<uint64_t>(VT_SEQ_NO, _seq_no, 0);
  }
  const HistoryLedger *ledger() const {
    return GetPointer<const HistoryLedger *>(VT_LEDGER);
  }
  HistoryLedger *mutable_ledger() {
    return GetPointer<HistoryLedger *>(VT_LEDGER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SEQ_NO) &&
           VerifyOffset(verifier, VT_LEDGER) &&
           verifier.VerifyTable(ledger()) &&
           verifier.EndTable();
  }
};

struct HistoryLedgerPairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_no(uint64_t seq_no) {
    fbb_.AddElement<uint64_t>(HistoryLedgerPair::VT_SEQ_NO, seq_no, 0);
  }
  void add_ledger(flatbuffers::Offset<HistoryLedger> ledger) {
    fbb_.AddOffset(HistoryLedgerPair::VT_LEDGER, ledger);
  }
  explicit HistoryLedgerPairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HistoryLedgerPairBuilder &operator=(const HistoryLedgerPairBuilder &);
  flatbuffers::Offset<HistoryLedgerPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HistoryLedgerPair>(end);
    return o;
  }
};

inline flatbuffers::Offset<HistoryLedgerPair> CreateHistoryLedgerPair(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq_no = 0,
    flatbuffers::Offset<HistoryLedger> ledger = 0) {
  HistoryLedgerPairBuilder builder_(_fbb);
  builder_.add_seq_no(seq_no);
  builder_.add_ledger(ledger);
  return builder_.Finish();
}

struct HistoryLedger FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_LCL = 6,
    VT_RAW_LEDGER = 8
  };
  const flatbuffers::Vector<uint8_t> *state() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_STATE);
  }
  flatbuffers::Vector<uint8_t> *mutable_state() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_STATE);
  }
  const flatbuffers::Vector<uint8_t> *lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  flatbuffers::Vector<uint8_t> *mutable_lcl() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  const flatbuffers::Vector<uint8_t> *raw_ledger() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_RAW_LEDGER);
  }
  flatbuffers::Vector<uint8_t> *mutable_raw_ledger() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_RAW_LEDGER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyVector(state()) &&
           VerifyOffset(verifier, VT_LCL) &&
           verifier.VerifyVector(lcl()) &&
           VerifyOffset(verifier, VT_RAW_LEDGER) &&
           verifier.VerifyVector(raw_ledger()) &&
           verifier.EndTable();
  }
};

struct HistoryLedgerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> state) {
    fbb_.AddOffset(HistoryLedger::VT_STATE, state);
  }
  void add_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl) {
    fbb_.AddOffset(HistoryLedger::VT_LCL, lcl);
  }
  void add_raw_ledger(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_ledger) {
    fbb_.AddOffset(HistoryLedger::VT_RAW_LEDGER, raw_ledger);
  }
  explicit HistoryLedgerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HistoryLedgerBuilder &operator=(const HistoryLedgerBuilder &);
  flatbuffers::Offset<HistoryLedger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HistoryLedger>(end);
    return o;
  }
};

inline flatbuffers::Offset<HistoryLedger> CreateHistoryLedger(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> state = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_ledger = 0) {
  HistoryLedgerBuilder builder_(_fbb);
  builder_.add_raw_ledger(raw_ledger);
  builder_.add_lcl(lcl);
  builder_.add_state(state);
  return builder_.Finish();
}

inline flatbuffers::Offset<HistoryLedger> CreateHistoryLedgerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *state = nullptr,
    const std::vector<uint8_t> *lcl = nullptr,
    const std::vector<uint8_t> *raw_ledger = nullptr) {
  auto state__ = state ? _fbb.CreateVector<uint8_t>(*state) : 0;
  auto lcl__ = lcl ? _fbb.CreateVector<uint8_t>(*lcl) : 0;
  auto raw_ledger__ = raw_ledger ? _fbb.CreateVector<uint8_t>(*raw_ledger) : 0;
  return fbschema::p2pmsg::CreateHistoryLedger(
      _fbb,
      state__,
      lcl__,
      raw_ledger__);
}

struct State_Request_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARENT_PATH = 4,
    VT_BLOCK_ID = 6
  };
  const flatbuffers::String *parent_path() const {
    return GetPointer<const flatbuffers::String *>(VT_PARENT_PATH);
  }
  flatbuffers::String *mutable_parent_path() {
    return GetPointer<flatbuffers::String *>(VT_PARENT_PATH);
  }
  int32_t block_id() const {
    return GetField<int32_t>(VT_BLOCK_ID, 0);
  }
  bool mutate_block_id(int32_t _block_id) {
    return SetField<int32_t>(VT_BLOCK_ID, _block_id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARENT_PATH) &&
           verifier.VerifyString(parent_path()) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_ID) &&
           verifier.EndTable();
  }
};

struct State_Request_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_parent_path(flatbuffers::Offset<flatbuffers::String> parent_path) {
    fbb_.AddOffset(State_Request_Message::VT_PARENT_PATH, parent_path);
  }
  void add_block_id(int32_t block_id) {
    fbb_.AddElement<int32_t>(State_Request_Message::VT_BLOCK_ID, block_id, 0);
  }
  explicit State_Request_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  State_Request_MessageBuilder &operator=(const State_Request_MessageBuilder &);
  flatbuffers::Offset<State_Request_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State_Request_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<State_Request_Message> CreateState_Request_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> parent_path = 0,
    int32_t block_id = 0) {
  State_Request_MessageBuilder builder_(_fbb);
  builder_.add_block_id(block_id);
  builder_.add_parent_path(parent_path);
  return builder_.Finish();
}

inline flatbuffers::Offset<State_Request_Message> CreateState_Request_MessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *parent_path = nullptr,
    int32_t block_id = 0) {
  auto parent_path__ = parent_path ? _fbb.CreateString(parent_path) : 0;
  return fbschema::p2pmsg::CreateState_Request_Message(
      _fbb,
      parent_path__,
      block_id);
}

struct State_Response_Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE_RESPONSE_TYPE = 4,
    VT_STATE_RESPONSE = 6
  };
  State_Response state_response_type() const {
    return static_cast<State_Response>(GetField<uint8_t>(VT_STATE_RESPONSE_TYPE, 0));
  }
  bool mutate_state_response_type(State_Response _state_response_type) {
    return SetField<uint8_t>(VT_STATE_RESPONSE_TYPE, static_cast<uint8_t>(_state_response_type), 0);
  }
  const void *state_response() const {
    return GetPointer<const void *>(VT_STATE_RESPONSE);
  }
  template<typename T> const T *state_response_as() const;
  const File_HashMap_Response *state_response_as_File_HashMap_Response() const {
    return state_response_type() == State_Response_File_HashMap_Response ? static_cast<const File_HashMap_Response *>(state_response()) : nullptr;
  }
  const Block_Response *state_response_as_Block_Response() const {
    return state_response_type() == State_Response_Block_Response ? static_cast<const Block_Response *>(state_response()) : nullptr;
  }
  const Content_Response *state_response_as_Content_Response() const {
    return state_response_type() == State_Response_Content_Response ? static_cast<const Content_Response *>(state_response()) : nullptr;
  }
  void *mutable_state_response() {
    return GetPointer<void *>(VT_STATE_RESPONSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE_RESPONSE_TYPE) &&
           VerifyOffset(verifier, VT_STATE_RESPONSE) &&
           VerifyState_Response(verifier, state_response(), state_response_type()) &&
           verifier.EndTable();
  }
};

template<> inline const File_HashMap_Response *State_Response_Message::state_response_as<File_HashMap_Response>() const {
  return state_response_as_File_HashMap_Response();
}

template<> inline const Block_Response *State_Response_Message::state_response_as<Block_Response>() const {
  return state_response_as_Block_Response();
}

template<> inline const Content_Response *State_Response_Message::state_response_as<Content_Response>() const {
  return state_response_as_Content_Response();
}

struct State_Response_MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state_response_type(State_Response state_response_type) {
    fbb_.AddElement<uint8_t>(State_Response_Message::VT_STATE_RESPONSE_TYPE, static_cast<uint8_t>(state_response_type), 0);
  }
  void add_state_response(flatbuffers::Offset<void> state_response) {
    fbb_.AddOffset(State_Response_Message::VT_STATE_RESPONSE, state_response);
  }
  explicit State_Response_MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  State_Response_MessageBuilder &operator=(const State_Response_MessageBuilder &);
  flatbuffers::Offset<State_Response_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State_Response_Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<State_Response_Message> CreateState_Response_Message(
    flatbuffers::FlatBufferBuilder &_fbb,
    State_Response state_response_type = State_Response_NONE,
    flatbuffers::Offset<void> state_response = 0) {
  State_Response_MessageBuilder builder_(_fbb);
  builder_.add_state_response(state_response);
  builder_.add_state_response_type(state_response_type);
  return builder_.Finish();
}

struct Content_Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FULL_PATH = 4,
    VT_CONTENT = 6
  };
  const flatbuffers::String *full_path() const {
    return GetPointer<const flatbuffers::String *>(VT_FULL_PATH);
  }
  flatbuffers::String *mutable_full_path() {
    return GetPointer<flatbuffers::String *>(VT_FULL_PATH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<State_FS_Hash_Entry>> *content() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<State_FS_Hash_Entry>> *>(VT_CONTENT);
  }
  flatbuffers::Vector<flatbuffers::Offset<State_FS_Hash_Entry>> *mutable_content() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<State_FS_Hash_Entry>> *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FULL_PATH) &&
           verifier.VerifyString(full_path()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           verifier.VerifyVectorOfTables(content()) &&
           verifier.EndTable();
  }
};

struct Content_ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_full_path(flatbuffers::Offset<flatbuffers::String> full_path) {
    fbb_.AddOffset(Content_Response::VT_FULL_PATH, full_path);
  }
  void add_content(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<State_FS_Hash_Entry>>> content) {
    fbb_.AddOffset(Content_Response::VT_CONTENT, content);
  }
  explicit Content_ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Content_ResponseBuilder &operator=(const Content_ResponseBuilder &);
  flatbuffers::Offset<Content_Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Content_Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Content_Response> CreateContent_Response(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> full_path = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<State_FS_Hash_Entry>>> content = 0) {
  Content_ResponseBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_full_path(full_path);
  return builder_.Finish();
}

inline flatbuffers::Offset<Content_Response> CreateContent_ResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *full_path = nullptr,
    const std::vector<flatbuffers::Offset<State_FS_Hash_Entry>> *content = nullptr) {
  auto full_path__ = full_path ? _fbb.CreateString(full_path) : 0;
  auto content__ = content ? _fbb.CreateVector<flatbuffers::Offset<State_FS_Hash_Entry>>(*content) : 0;
  return fbschema::p2pmsg::CreateContent_Response(
      _fbb,
      full_path__,
      content__);
}

struct File_HashMap_Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FULL_PATH = 4,
    VT_HASH_MAP = 6
  };
  const flatbuffers::String *full_path() const {
    return GetPointer<const flatbuffers::String *>(VT_FULL_PATH);
  }
  flatbuffers::String *mutable_full_path() {
    return GetPointer<flatbuffers::String *>(VT_FULL_PATH);
  }
  const flatbuffers::Vector<uint8_t> *hash_map() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH_MAP);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash_map() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FULL_PATH) &&
           verifier.VerifyString(full_path()) &&
           VerifyOffset(verifier, VT_HASH_MAP) &&
           verifier.VerifyVector(hash_map()) &&
           verifier.EndTable();
  }
};

struct File_HashMap_ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_full_path(flatbuffers::Offset<flatbuffers::String> full_path) {
    fbb_.AddOffset(File_HashMap_Response::VT_FULL_PATH, full_path);
  }
  void add_hash_map(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash_map) {
    fbb_.AddOffset(File_HashMap_Response::VT_HASH_MAP, hash_map);
  }
  explicit File_HashMap_ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  File_HashMap_ResponseBuilder &operator=(const File_HashMap_ResponseBuilder &);
  flatbuffers::Offset<File_HashMap_Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<File_HashMap_Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<File_HashMap_Response> CreateFile_HashMap_Response(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> full_path = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash_map = 0) {
  File_HashMap_ResponseBuilder builder_(_fbb);
  builder_.add_hash_map(hash_map);
  builder_.add_full_path(full_path);
  return builder_.Finish();
}

inline flatbuffers::Offset<File_HashMap_Response> CreateFile_HashMap_ResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *full_path = nullptr,
    const std::vector<uint8_t> *hash_map = nullptr) {
  auto full_path__ = full_path ? _fbb.CreateString(full_path) : 0;
  auto hash_map__ = hash_map ? _fbb.CreateVector<uint8_t>(*hash_map) : 0;
  return fbschema::p2pmsg::CreateFile_HashMap_Response(
      _fbb,
      full_path__,
      hash_map__);
}

struct Block_Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FULL_PATH = 4,
    VT_BLOCK_ID = 6,
    VT_DATA = 8
  };
  const flatbuffers::String *full_path() const {
    return GetPointer<const flatbuffers::String *>(VT_FULL_PATH);
  }
  flatbuffers::String *mutable_full_path() {
    return GetPointer<flatbuffers::String *>(VT_FULL_PATH);
  }
  uint32_t block_id() const {
    return GetField<uint32_t>(VT_BLOCK_ID, 0);
  }
  bool mutate_block_id(uint32_t _block_id) {
    return SetField<uint32_t>(VT_BLOCK_ID, _block_id, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FULL_PATH) &&
           verifier.VerifyString(full_path()) &&
           VerifyField<uint32_t>(verifier, VT_BLOCK_ID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct Block_ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_full_path(flatbuffers::Offset<flatbuffers::String> full_path) {
    fbb_.AddOffset(Block_Response::VT_FULL_PATH, full_path);
  }
  void add_block_id(uint32_t block_id) {
    fbb_.AddElement<uint32_t>(Block_Response::VT_BLOCK_ID, block_id, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Block_Response::VT_DATA, data);
  }
  explicit Block_ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Block_ResponseBuilder &operator=(const Block_ResponseBuilder &);
  flatbuffers::Offset<Block_Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Block_Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Block_Response> CreateBlock_Response(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> full_path = 0,
    uint32_t block_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  Block_ResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_block_id(block_id);
  builder_.add_full_path(full_path);
  return builder_.Finish();
}

inline flatbuffers::Offset<Block_Response> CreateBlock_ResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *full_path = nullptr,
    uint32_t block_id = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto full_path__ = full_path ? _fbb.CreateString(full_path) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fbschema::p2pmsg::CreateBlock_Response(
      _fbb,
      full_path__,
      block_id,
      data__);
}

struct State_FS_Hash_Entry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FULL_PATH = 4,
    VT_IS_FILE = 6,
    VT_FILE_HASH = 8
  };
  const flatbuffers::String *full_path() const {
    return GetPointer<const flatbuffers::String *>(VT_FULL_PATH);
  }
  flatbuffers::String *mutable_full_path() {
    return GetPointer<flatbuffers::String *>(VT_FULL_PATH);
  }
  bool is_file() const {
    return GetField<uint8_t>(VT_IS_FILE, 0) != 0;
  }
  bool mutate_is_file(bool _is_file) {
    return SetField<uint8_t>(VT_IS_FILE, static_cast<uint8_t>(_is_file), 0);
  }
  const flatbuffers::Vector<uint8_t> *file_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FILE_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_file_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_FILE_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FULL_PATH) &&
           verifier.VerifyString(full_path()) &&
           VerifyField<uint8_t>(verifier, VT_IS_FILE) &&
           VerifyOffset(verifier, VT_FILE_HASH) &&
           verifier.VerifyVector(file_hash()) &&
           verifier.EndTable();
  }
};

struct State_FS_Hash_EntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_full_path(flatbuffers::Offset<flatbuffers::String> full_path) {
    fbb_.AddOffset(State_FS_Hash_Entry::VT_FULL_PATH, full_path);
  }
  void add_is_file(bool is_file) {
    fbb_.AddElement<uint8_t>(State_FS_Hash_Entry::VT_IS_FILE, static_cast<uint8_t>(is_file), 0);
  }
  void add_file_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> file_hash) {
    fbb_.AddOffset(State_FS_Hash_Entry::VT_FILE_HASH, file_hash);
  }
  explicit State_FS_Hash_EntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  State_FS_Hash_EntryBuilder &operator=(const State_FS_Hash_EntryBuilder &);
  flatbuffers::Offset<State_FS_Hash_Entry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State_FS_Hash_Entry>(end);
    return o;
  }
};

inline flatbuffers::Offset<State_FS_Hash_Entry> CreateState_FS_Hash_Entry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> full_path = 0,
    bool is_file = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> file_hash = 0) {
  State_FS_Hash_EntryBuilder builder_(_fbb);
  builder_.add_file_hash(file_hash);
  builder_.add_full_path(full_path);
  builder_.add_is_file(is_file);
  return builder_.Finish();
}

inline flatbuffers::Offset<State_FS_Hash_Entry> CreateState_FS_Hash_EntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *full_path = nullptr,
    bool is_file = false,
    const std::vector<uint8_t> *file_hash = nullptr) {
  auto full_path__ = full_path ? _fbb.CreateString(full_path) : 0;
  auto file_hash__ = file_hash ? _fbb.CreateVector<uint8_t>(*file_hash) : 0;
  return fbschema::p2pmsg::CreateState_FS_Hash_Entry(
      _fbb,
      full_path__,
      is_file,
      file_hash__);
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_NonUnl_Proposal_Message: {
      auto ptr = reinterpret_cast<const NonUnl_Proposal_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Proposal_Message: {
      auto ptr = reinterpret_cast<const Proposal_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Npl_Message: {
      auto ptr = reinterpret_cast<const Npl_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_State_Request_Message: {
      auto ptr = reinterpret_cast<const State_Request_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_State_Response_Message: {
      auto ptr = reinterpret_cast<const State_Response_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_History_Request_Message: {
      auto ptr = reinterpret_cast<const History_Request_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_History_Response_Message: {
      auto ptr = reinterpret_cast<const History_Response_Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyState_Response(flatbuffers::Verifier &verifier, const void *obj, State_Response type) {
  switch (type) {
    case State_Response_NONE: {
      return true;
    }
    case State_Response_File_HashMap_Response: {
      auto ptr = reinterpret_cast<const File_HashMap_Response *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case State_Response_Block_Response: {
      auto ptr = reinterpret_cast<const Block_Response *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case State_Response_Content_Response: {
      auto ptr = reinterpret_cast<const Content_Response *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyState_ResponseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyState_Response(
        verifier,  values->Get(i), types->GetEnum<State_Response>(i))) {
      return false;
    }
  }
  return true;
}

inline const fbschema::p2pmsg::Content *GetContent(const void *buf) {
  return flatbuffers::GetRoot<fbschema::p2pmsg::Content>(buf);
}

inline const fbschema::p2pmsg::Content *GetSizePrefixedContent(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<fbschema::p2pmsg::Content>(buf);
}

inline Content *GetMutableContent(void *buf) {
  return flatbuffers::GetMutableRoot<Content>(buf);
}

inline bool VerifyContentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fbschema::p2pmsg::Content>(nullptr);
}

inline bool VerifySizePrefixedContentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fbschema::p2pmsg::Content>(nullptr);
}

inline void FinishContentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fbschema::p2pmsg::Content> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedContentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fbschema::p2pmsg::Content> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace p2pmsg
}  // namespace fbschema

#endif  // FLATBUFFERS_GENERATED_P2PMSGCONTENT_FBSCHEMA_P2PMSG_H_
