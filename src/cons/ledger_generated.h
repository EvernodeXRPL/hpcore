// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LEDGER_CONS_H_
#define FLATBUFFERS_GENERATED_LEDGER_CONS_H_

#include "flatbuffers/flatbuffers.h"

namespace cons {

struct Ledger;

struct Input;

struct InputList;

struct Output;

struct State;

struct StateDifference;

struct BytesKeyValuePair;

struct ByteArray;

struct Ledger FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_LCL = 6,
    VT_USERS = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS = 12,
    VT_STATE = 14
  };
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  const flatbuffers::Vector<uint8_t> *lcl() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  flatbuffers::Vector<uint8_t> *mutable_lcl() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_LCL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ByteArray>> *users() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ByteArray>> *>(VT_USERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<ByteArray>> *mutable_users() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ByteArray>> *>(VT_USERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Input>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Input>> *>(VT_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Input>> *mutable_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Input>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Output>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Output>> *>(VT_OUTPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Output>> *mutable_outputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Output>> *>(VT_OUTPUTS);
  }
  const State *state() const {
    return GetPointer<const State *>(VT_STATE);
  }
  State *mutable_state() {
    return GetPointer<State *>(VT_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_LCL) &&
           verifier.VerifyVector(lcl()) &&
           VerifyOffset(verifier, VT_USERS) &&
           verifier.VerifyVector(users()) &&
           verifier.VerifyVectorOfTables(users()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyTable(state()) &&
           verifier.EndTable();
  }
};

struct LedgerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(Ledger::VT_TIME, time, 0);
  }
  void add_lcl(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl) {
    fbb_.AddOffset(Ledger::VT_LCL, lcl);
  }
  void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ByteArray>>> users) {
    fbb_.AddOffset(Ledger::VT_USERS, users);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Input>>> inputs) {
    fbb_.AddOffset(Ledger::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Output>>> outputs) {
    fbb_.AddOffset(Ledger::VT_OUTPUTS, outputs);
  }
  void add_state(flatbuffers::Offset<State> state) {
    fbb_.AddOffset(Ledger::VT_STATE, state);
  }
  explicit LedgerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LedgerBuilder &operator=(const LedgerBuilder &);
  flatbuffers::Offset<Ledger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ledger>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ledger> CreateLedger(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lcl = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ByteArray>>> users = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Input>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Output>>> outputs = 0,
    flatbuffers::Offset<State> state = 0) {
  LedgerBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_state(state);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_users(users);
  builder_.add_lcl(lcl);
  return builder_.Finish();
}

inline flatbuffers::Offset<Ledger> CreateLedgerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time = 0,
    const std::vector<uint8_t> *lcl = nullptr,
    const std::vector<flatbuffers::Offset<ByteArray>> *users = nullptr,
    const std::vector<flatbuffers::Offset<Input>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<Output>> *outputs = nullptr,
    flatbuffers::Offset<State> state = 0) {
  auto lcl__ = lcl ? _fbb.CreateVector<uint8_t>(*lcl) : 0;
  auto users__ = users ? _fbb.CreateVector<flatbuffers::Offset<ByteArray>>(*users) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<Input>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<Output>>(*outputs) : 0;
  return cons::CreateLedger(
      _fbb,
      time,
      lcl__,
      users__,
      inputs__,
      outputs__,
      state);
}

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_INPUT = 6
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const InputList *input() const {
    return GetPointer<const InputList *>(VT_INPUT);
  }
  InputList *mutable_input() {
    return GetPointer<InputList *>(VT_INPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           verifier.EndTable();
  }
};

struct InputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(Input::VT_PUBKEY, pubkey);
  }
  void add_input(flatbuffers::Offset<InputList> input) {
    fbb_.AddOffset(Input::VT_INPUT, input);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputBuilder &operator=(const InputBuilder &);
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<InputList> input = 0) {
  InputBuilder builder_(_fbb);
  builder_.add_input(input);
  builder_.add_pubkey(pubkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Input> CreateInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    flatbuffers::Offset<InputList> input = 0) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  return cons::CreateInput(
      _fbb,
      pubkey__,
      input);
}

struct InputList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH = 4,
    VT_INPUTS = 6
  };
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *>(VT_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *mutable_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *>(VT_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyVector(hash()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           verifier.EndTable();
  }
};

struct InputListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(InputList::VT_HASH, hash);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>>> inputs) {
    fbb_.AddOffset(InputList::VT_INPUTS, inputs);
  }
  explicit InputListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputListBuilder &operator=(const InputListBuilder &);
  flatbuffers::Offset<InputList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputList>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputList> CreateInputList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>>> inputs = 0) {
  InputListBuilder builder_(_fbb);
  builder_.add_inputs(inputs);
  builder_.add_hash(hash);
  return builder_.Finish();
}

inline flatbuffers::Offset<InputList> CreateInputListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *hash = nullptr,
    const std::vector<flatbuffers::Offset<BytesKeyValuePair>> *inputs = nullptr) {
  auto hash__ = hash ? _fbb.CreateVector<uint8_t>(*hash) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<BytesKeyValuePair>>(*inputs) : 0;
  return cons::CreateInputList(
      _fbb,
      hash__,
      inputs__);
}

struct Output FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBKEY = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::Vector<uint8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_pubkey() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PUBKEY);
  }
  const BytesKeyValuePair *output() const {
    return GetPointer<const BytesKeyValuePair *>(VT_OUTPUT);
  }
  BytesKeyValuePair *mutable_output() {
    return GetPointer<BytesKeyValuePair *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.VerifyVector(pubkey()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyTable(output()) &&
           verifier.EndTable();
  }
};

struct OutputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey) {
    fbb_.AddOffset(Output::VT_PUBKEY, pubkey);
  }
  void add_output(flatbuffers::Offset<BytesKeyValuePair> output) {
    fbb_.AddOffset(Output::VT_OUTPUT, output);
  }
  explicit OutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OutputBuilder &operator=(const OutputBuilder &);
  flatbuffers::Offset<Output> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Output>(end);
    return o;
  }
};

inline flatbuffers::Offset<Output> CreateOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pubkey = 0,
    flatbuffers::Offset<BytesKeyValuePair> output = 0) {
  OutputBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_pubkey(pubkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Output> CreateOutputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pubkey = nullptr,
    flatbuffers::Offset<BytesKeyValuePair> output = 0) {
  auto pubkey__ = pubkey ? _fbb.CreateVector<uint8_t>(*pubkey) : 0;
  return cons::CreateOutput(
      _fbb,
      pubkey__,
      output);
}

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PREVIOUS = 4,
    VT_CURRENT = 6,
    VT_DIFFERENCE = 8,
    VT_PATCH = 10
  };
  const flatbuffers::Vector<uint8_t> *previous() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PREVIOUS);
  }
  flatbuffers::Vector<uint8_t> *mutable_previous() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PREVIOUS);
  }
  const flatbuffers::Vector<uint8_t> *current() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CURRENT);
  }
  flatbuffers::Vector<uint8_t> *mutable_current() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CURRENT);
  }
  const StateDifference *difference() const {
    return GetPointer<const StateDifference *>(VT_DIFFERENCE);
  }
  StateDifference *mutable_difference() {
    return GetPointer<StateDifference *>(VT_DIFFERENCE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *patch() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *>(VT_PATCH);
  }
  flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *mutable_patch() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *>(VT_PATCH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PREVIOUS) &&
           verifier.VerifyVector(previous()) &&
           VerifyOffset(verifier, VT_CURRENT) &&
           verifier.VerifyVector(current()) &&
           VerifyOffset(verifier, VT_DIFFERENCE) &&
           verifier.VerifyTable(difference()) &&
           VerifyOffset(verifier, VT_PATCH) &&
           verifier.VerifyVector(patch()) &&
           verifier.VerifyVectorOfTables(patch()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_previous(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> previous) {
    fbb_.AddOffset(State::VT_PREVIOUS, previous);
  }
  void add_current(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> current) {
    fbb_.AddOffset(State::VT_CURRENT, current);
  }
  void add_difference(flatbuffers::Offset<StateDifference> difference) {
    fbb_.AddOffset(State::VT_DIFFERENCE, difference);
  }
  void add_patch(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>>> patch) {
    fbb_.AddOffset(State::VT_PATCH, patch);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> previous = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> current = 0,
    flatbuffers::Offset<StateDifference> difference = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>>> patch = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_patch(patch);
  builder_.add_difference(difference);
  builder_.add_current(current);
  builder_.add_previous(previous);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *previous = nullptr,
    const std::vector<uint8_t> *current = nullptr,
    flatbuffers::Offset<StateDifference> difference = 0,
    const std::vector<flatbuffers::Offset<BytesKeyValuePair>> *patch = nullptr) {
  auto previous__ = previous ? _fbb.CreateVector<uint8_t>(*previous) : 0;
  auto current__ = current ? _fbb.CreateVector<uint8_t>(*current) : 0;
  auto patch__ = patch ? _fbb.CreateVector<flatbuffers::Offset<BytesKeyValuePair>>(*patch) : 0;
  return cons::CreateState(
      _fbb,
      previous__,
      current__,
      difference,
      patch__);
}

struct StateDifference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CREATED = 4,
    VT_UPDATED = 6,
    VT_DELETED = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *created() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *>(VT_CREATED);
  }
  flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *mutable_created() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *>(VT_CREATED);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *updated() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *>(VT_UPDATED);
  }
  flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *mutable_updated() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *>(VT_UPDATED);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *deleted() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *>(VT_DELETED);
  }
  flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *mutable_deleted() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>> *>(VT_DELETED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CREATED) &&
           verifier.VerifyVector(created()) &&
           verifier.VerifyVectorOfTables(created()) &&
           VerifyOffset(verifier, VT_UPDATED) &&
           verifier.VerifyVector(updated()) &&
           verifier.VerifyVectorOfTables(updated()) &&
           VerifyOffset(verifier, VT_DELETED) &&
           verifier.VerifyVector(deleted()) &&
           verifier.VerifyVectorOfTables(deleted()) &&
           verifier.EndTable();
  }
};

struct StateDifferenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_created(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>>> created) {
    fbb_.AddOffset(StateDifference::VT_CREATED, created);
  }
  void add_updated(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>>> updated) {
    fbb_.AddOffset(StateDifference::VT_UPDATED, updated);
  }
  void add_deleted(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>>> deleted) {
    fbb_.AddOffset(StateDifference::VT_DELETED, deleted);
  }
  explicit StateDifferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateDifferenceBuilder &operator=(const StateDifferenceBuilder &);
  flatbuffers::Offset<StateDifference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StateDifference>(end);
    return o;
  }
};

inline flatbuffers::Offset<StateDifference> CreateStateDifference(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>>> created = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>>> updated = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BytesKeyValuePair>>> deleted = 0) {
  StateDifferenceBuilder builder_(_fbb);
  builder_.add_deleted(deleted);
  builder_.add_updated(updated);
  builder_.add_created(created);
  return builder_.Finish();
}

inline flatbuffers::Offset<StateDifference> CreateStateDifferenceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BytesKeyValuePair>> *created = nullptr,
    const std::vector<flatbuffers::Offset<BytesKeyValuePair>> *updated = nullptr,
    const std::vector<flatbuffers::Offset<BytesKeyValuePair>> *deleted = nullptr) {
  auto created__ = created ? _fbb.CreateVector<flatbuffers::Offset<BytesKeyValuePair>>(*created) : 0;
  auto updated__ = updated ? _fbb.CreateVector<flatbuffers::Offset<BytesKeyValuePair>>(*updated) : 0;
  auto deleted__ = deleted ? _fbb.CreateVector<flatbuffers::Offset<BytesKeyValuePair>>(*deleted) : 0;
  return cons::CreateStateDifference(
      _fbb,
      created__,
      updated__,
      deleted__);
}

struct BytesKeyValuePair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::Vector<uint8_t> *key() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_KEY);
  }
  flatbuffers::Vector<uint8_t> *mutable_key() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_KEY);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<uint8_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyVector(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct BytesKeyValuePairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> key) {
    fbb_.AddOffset(BytesKeyValuePair::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(BytesKeyValuePair::VT_VALUE, value);
  }
  explicit BytesKeyValuePairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BytesKeyValuePairBuilder &operator=(const BytesKeyValuePairBuilder &);
  flatbuffers::Offset<BytesKeyValuePair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BytesKeyValuePair>(end);
    return o;
  }
};

inline flatbuffers::Offset<BytesKeyValuePair> CreateBytesKeyValuePair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> key = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  BytesKeyValuePairBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<BytesKeyValuePair> CreateBytesKeyValuePairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *key = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto key__ = key ? _fbb.CreateVector<uint8_t>(*key) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return cons::CreateBytesKeyValuePair(
      _fbb,
      key__,
      value__);
}

struct ByteArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARRAY = 4
  };
  const flatbuffers::Vector<uint8_t> *array() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ARRAY);
  }
  flatbuffers::Vector<uint8_t> *mutable_array() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_ARRAY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARRAY) &&
           verifier.VerifyVector(array()) &&
           verifier.EndTable();
  }
};

struct ByteArrayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_array(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> array) {
    fbb_.AddOffset(ByteArray::VT_ARRAY, array);
  }
  explicit ByteArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ByteArrayBuilder &operator=(const ByteArrayBuilder &);
  flatbuffers::Offset<ByteArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ByteArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<ByteArray> CreateByteArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> array = 0) {
  ByteArrayBuilder builder_(_fbb);
  builder_.add_array(array);
  return builder_.Finish();
}

inline flatbuffers::Offset<ByteArray> CreateByteArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *array = nullptr) {
  auto array__ = array ? _fbb.CreateVector<uint8_t>(*array) : 0;
  return cons::CreateByteArray(
      _fbb,
      array__);
}

inline const cons::Ledger *GetLedger(const void *buf) {
  return flatbuffers::GetRoot<cons::Ledger>(buf);
}

inline const cons::Ledger *GetSizePrefixedLedger(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<cons::Ledger>(buf);
}

inline Ledger *GetMutableLedger(void *buf) {
  return flatbuffers::GetMutableRoot<Ledger>(buf);
}

inline bool VerifyLedgerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<cons::Ledger>(nullptr);
}

inline bool VerifySizePrefixedLedgerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<cons::Ledger>(nullptr);
}

inline void FinishLedgerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cons::Ledger> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLedgerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cons::Ledger> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace cons

#endif  // FLATBUFFERS_GENERATED_LEDGER_CONS_H_
