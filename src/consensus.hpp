#ifndef _HP_CONS_
#define _HP_CONS_

#include "pchheader.hpp"
#include "util.hpp"
#include "sc.hpp"
#include "p2p/p2p.hpp"
#include "usr/user_input.hpp"
#include "hpfs/h32.hpp"
#include "sc.hpp"

namespace consensus
{
    /**
     * Represents a contract input that takes part in consensus.
     */
    struct candidate_user_input
    {
        const std::string userpubkey;
        const uint64_t maxledgerseqno = 0;
        std::string input;

        candidate_user_input(const std::string userpubkey, const std::string input, const uint64_t maxledgerseqno)
            : userpubkey(std::move(userpubkey)), input(std::move(input)), maxledgerseqno(maxledgerseqno)
        {
        }
    };

    /**
     * Represents a contract output that takes part in consensus.
     */
    struct candidate_user_output
    {
        const std::string userpubkey;
        std::string output;

        candidate_user_output(const std::string userpubkey, const std::string output)
            : userpubkey(std::move(userpubkey)), output(std::move(output))
        {
        }
    };

    /**
     * This is used to store consensus information
     */
    struct consensus_context
    {
        // The map of proposals that are being collected as consensus stages are progressing.
        // peer public key is the key.
        // todo: having a queue of proposals against peer pubkey.
        std::unordered_map<std::string, const p2p::proposal> candidate_proposals;

        // Set of user pubkeys that is said to be connected to the cluster. This will be cleared in each round.
        std::unordered_set<std::string> candidate_users;

        // Map of candidate user inputs with input hash as map key. Inputs will stay here until they
        // achieve consensus or expire (due to maxledgerseqno). Input hash is globally unique among inputs
        // from all users. We will use this map to feed inputs into the contract once consensus is achieved.
        std::unordered_map<std::string, candidate_user_input> candidate_user_inputs;

        // Map of outputs generated by the contract with output hash is the map key. Outputs will stay
        // here until the end of the current consensus round. Output hash is globally unique among outputs for
        // all users. We will use this map to distribute outputs back to connected users once consensus is achieved.
        std::unordered_map<std::string, candidate_user_output> candidate_user_outputs;

        util::rollover_hashset recent_userinput_hashes;

        uint8_t stage = 0;
        uint64_t time_now = 0;
        hpfs::h32 state = hpfs::h32_empty;

        uint16_t stage_time = 0;                 // Time allocated to a consensus stage.
        uint16_t stage_reset_wait_threshold = 0; // Minimum stage wait time to reset the stage.

        std::mutex state_sync_lock;
        sc::execution_context contract_ctx;
        bool is_shutting_down = false;

        std::thread consensus_thread;

        consensus_context()
            : recent_userinput_hashes(200)
        {
        }
    };

    struct vote_counter
    {
        std::map<uint64_t, int32_t> time;
        std::map<std::string, int32_t> lcl;
        std::map<std::string, int32_t> users;
        std::map<std::string, int32_t> inputs;
        std::map<std::string, int32_t> outputs;
        std::map<hpfs::h32, int32_t> state;
    };

    int init();

    void deinit();

    void wait();

    void run_consensus();

    int consensus();

    void purify_candidate_proposals();

    bool wait_and_proceed_stage(uint64_t &stage_start);

    void broadcast_nonunl_proposal();

    bool push_npl_message(p2p::npl_message &npl_message);

    void verify_and_populate_candidate_user_inputs(const uint64_t lcl_seq_no);

    bool verify_appbill_check(std::string_view pubkey, const size_t input_len);

    p2p::proposal create_stage0_proposal(std::string_view lcl);

    p2p::proposal create_stage123_proposal(vote_counter &votes, std::string_view lcl);

    void broadcast_proposal(const p2p::proposal &p);

    void check_lcl_votes(bool &is_desync, bool &should_request_history, std::string &majority_lcl, vote_counter &votes, std::string_view lcl);

    void check_state_votes(bool &is_desync, hpfs::h32 &majority_state, vote_counter &votes);

    float_t get_stage_threshold(const uint8_t stage);

    void timewait_stage(const bool reset, const uint64_t time);

    uint64_t get_ledger_time_resolution(const uint64_t time);

    uint64_t get_stage_time_resolution(const uint64_t time);

    int apply_ledger(const p2p::proposal &proposal, const uint64_t lcl_seq_no, std::string_view lcl);

    void dispatch_user_outputs(const p2p::proposal &cons_prop, const uint64_t lcl_seq_no, std::string_view lcl);

    void feed_user_inputs_to_contract_bufmap(sc::contract_bufmap_t &bufmap, const p2p::proposal &cons_prop);

    void extract_user_outputs_from_contract_bufmap(sc::contract_bufmap_t &bufmap);

    template <typename T>
    void increment(std::map<T, int32_t> &counter, const T &candidate);

    int get_initial_state_hash(hpfs::h32 &hash);

    void on_state_sync_completion(const hpfs::h32 new_state);

} // namespace consensus

#endif
