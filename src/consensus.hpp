#ifndef _HP_CONS_
#define _HP_CONS_

#include "pchheader.hpp"
#include "util/util.hpp"
#include "util/buffer_store.hpp"
#include "sc.hpp"
#include "p2p/p2p.hpp"
#include "usr/user_input.hpp"
#include "hpfs/h32.hpp"
#include "sc.hpp"

namespace consensus
{
    /**
     * Represents a contract input that takes part in consensus.
     */
    struct candidate_user_input
    {
        const std::string userpubkey;
        const uint64_t maxledgerseqno = 0;
        const util::buffer_view input;

        candidate_user_input(const std::string userpubkey, const util::buffer_view input, const uint64_t maxledgerseqno)
            : userpubkey(std::move(userpubkey)), input(input), maxledgerseqno(maxledgerseqno)
        {
        }
    };

    /**
     * Represents a contract output that takes part in consensus.
     */
    struct candidate_user_output
    {
        const std::string userpubkey;
        std::list<sc::contract_output> outputs;

        candidate_user_output(const std::string userpubkey, const std::list<sc::contract_output> outputs)
            : userpubkey(std::move(userpubkey)), outputs(std::move(outputs))
        {
        }
    };

    /**
     * This is used to store consensus information
     */
    struct consensus_context
    {
        // The map of proposals that are being collected as consensus stages are progressing.
        // peer public key is the key.
        // todo: having a queue of proposals against peer pubkey.
        std::unordered_map<std::string, const p2p::proposal> candidate_proposals;

        // Set of user pubkeys that is said to be connected to the cluster. This will be cleared in each round.
        std::set<std::string> candidate_users;

        // Map of candidate user inputs with input hash as map key. Inputs will stay here until they
        // achieve consensus or expire (due to maxledgerseqno). Input hash is globally unique among inputs
        // from all users. We will use this map to feed inputs into the contract once consensus is achieved.
        std::unordered_map<std::string, candidate_user_input> candidate_user_inputs;

        // Map of outputs generated by the contract with output hash is the map key. Outputs will stay
        // here until the end of the current consensus round. Output hash is globally unique among outputs for
        // all users. We will use this map to distribute outputs back to connected users once consensus is achieved.
        std::unordered_map<std::string, candidate_user_output> candidate_user_outputs;

        uint8_t stage = 1;
        uint64_t time_now = 0;
        uint16_t stage_time = 0;                 // Time allocated to a consensus stage.
        uint16_t stage_reset_wait_threshold = 0; // Minimum stage wait time to reset the stage.

        std::optional<sc::execution_context> contract_ctx;
        std::mutex contract_ctx_mutex;
        bool is_shutting_down = false;

        std::thread consensus_thread;
    };

    struct vote_counter
    {
        std::map<uint64_t, uint32_t> time;
        std::map<std::string, uint32_t> nonce;
        std::map<std::string, uint32_t> lcl;
        std::map<std::string, uint32_t> users;
        std::map<std::string, uint32_t> inputs;
        std::map<std::string, uint32_t> outputs;
        std::map<hpfs::h32, uint32_t> state;
        std::map<std::string, uint32_t> unl;
    };

    int init();

    void deinit();

    void wait();

    void run_consensus();

    int consensus();

    bool is_in_sync(std::string_view lcl, const size_t unl_count, vote_counter &votes);

    void revise_candidate_proposals();

    bool wait_and_proceed_stage(uint64_t &stage_start);

    void broadcast_nonunl_proposal();

    bool push_npl_message(p2p::npl_message &npl_message);

    int verify_and_populate_candidate_user_inputs(const uint64_t lcl_seq_no);

    p2p::proposal create_stage0_proposal(std::string_view lcl, hpfs::h32 state, std::string_view unl_hash);

    p2p::proposal create_stage123_proposal(const float_t vote_threshold, vote_counter &votes, std::string_view lcl, const size_t unl_count, const hpfs::h32 state, std::string_view unl_hash);

    void broadcast_proposal(const p2p::proposal &p);

    bool check_lcl_votes(bool &is_desync, std::string &majority_lcl, vote_counter &votes, std::string_view lcl, const size_t unl_count);

    void check_state_votes(bool &is_desync, hpfs::h32 &majority_state, vote_counter &votes);

    void check_unl_votes(bool &is_desync, std::string &majority_unl, vote_counter &votes);

    void timewait_stage(const bool reset, const uint64_t time);

    uint64_t get_ledger_time_resolution(const uint64_t time);

    uint64_t get_stage_time_resolution(const uint64_t time);

    int update_ledger_and_execute_contract(const p2p::proposal &proposal, std::string &new_lcl, hpfs::h32 &new_state);

    void dispatch_user_outputs(const p2p::proposal &cons_prop, const uint64_t lcl_seq_no, std::string_view lcl);

    int feed_user_inputs_to_contract_bufmap(sc::contract_bufmap_t &bufmap, const p2p::proposal &cons_prop);

    void extract_user_outputs_from_contract_bufmap(sc::contract_bufmap_t &bufmap);

    template <typename T>
    void increment(std::map<T, uint32_t> &counter, const T &candidate);

    int get_initial_state_hash(hpfs::h32 &hash);

    bool push_control_message(const std::string &control_msg);

} // namespace consensus

#endif
